<use f='googletest-1.12.1/googlemock/include/gmock/gmock-actions.h' l='958' c='_ZN7testing8internal12ReturnAction4ImplC1EOT_'/>
<use f='googletest-1.12.1/googlemock/include/gmock/gmock-actions.h' l='962' c='_ZN7testing8internal12ReturnAction4ImplC1ERKT_'/>
<def f='googletest-1.12.1/googlemock/include/gmock/gmock-actions.h' l='979' ll='1076'/>
<use f='googletest-1.12.1/googlemock/include/gmock/gmock-actions.h' l='1078'/>
<doc f='googletest-1.12.1/googlemock/include/gmock/gmock-actions.h' l='968'>// We put our state on the heap so that the compiler-generated copy/move
    // constructors work correctly even when U is a reference-like type. This is
    // necessary only because we eagerly create State::value (see the note on
    // that symbol for details). If we instead had only the input value as a
    // member then the default constructors would work fine.
    //
    // For example, when R is std::string and U is std::string_view, value is a
    // reference to the string backed by input_value. The copy constructor would
    // copy both, so that we wind up with a new input_value object (with the
    // same contents) and a reference to the *old* input_value object rather
    // than the new one.</doc>
<fun r='_ZN7testing8internal12ReturnAction4Impl5StateC1ERKT_'/>
<fun r='_ZN7testing8internal12ReturnAction4Impl5StateC1EOT_'/>
<mbr r='testing::internal::ReturnAction::Impl::State::input_value' t='R'/>
<mbr r='testing::internal::ReturnAction::Impl::State::value' t='U'/>
