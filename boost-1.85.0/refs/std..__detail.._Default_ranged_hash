<def f='include/c++/9/bits/hashtable_policy.h' l='441'/>
<use f='include/c++/9/bits/hashtable_policy.h' l='1253'/>
<use f='include/c++/9/bits/hashtable_policy.h' l='1265'/>
<use f='include/c++/9/bits/hashtable_policy.h' l='1284' c='_ZNSt8__detail15_Hash_code_baseIT_T0_T1_T2_T3_NS_20_Default_ranged_hashELb0EEC1ERKS3_RKS4_RKS5_RKS6_'/>
<use f='include/c++/9/bits/hashtable_policy.h' l='1347'/>
<use f='include/c++/9/bits/hashtable_policy.h' l='1355'/>
<use f='include/c++/9/bits/hashtable_policy.h' l='1376' c='_ZNSt8__detail15_Hash_code_baseIT_T0_T1_T2_T3_NS_20_Default_ranged_hashELb1EEC1ERKS3_RKS4_RKS5_RKS6_'/>
<use f='include/c++/9/bits/unordered_set.h' l='50'/>
<use f='include/c++/9/bits/unordered_set.h' l='66'/>
<use f='include/c++/9/bits/unordered_map.h' l='52'/>
<use f='include/c++/9/bits/unordered_map.h' l='69'/>
<size>1</size>
<doc f='include/c++/9/bits/hashtable_policy.h' l='436'>/// Default ranged hash function H.  In principle it should be a
  /// function object composed from objects of type H1 and H2 such that
  /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
  /// h1 and h2.  So instead we&apos;ll just use a tag to tell class template
  /// hashtable to do that composition.</doc>
