<inh f='include/unicode/uobject.h' l='223' c='icu_66::UObject'/>
<def f='include/unicode/format.h' l='98' ll='302'/>
<use f='include/unicode/format.h' l='114' c='_ZNK6icu_666FormateqERKS0_'/>
<use f='include/unicode/format.h' l='123' c='_ZNK6icu_666FormatneERKS0_'/>
<use f='include/unicode/format.h' l='131' c='_ZNK6icu_666Format5cloneEv'/>
<use f='include/unicode/format.h' l='279' c='_ZN6icu_666FormatC1ERKS0_'/>
<use f='include/unicode/format.h' l='284' c='_ZN6icu_666FormataSERKS0_'/>
<use f='include/unicode/format.h' l='284' c='_ZN6icu_666FormataSERKS0_'/>
<ovr f='include/unicode/numfmt.h' l='175' c='icu_66::NumberFormat'/>
<use f='include/unicode/numfmt.h' l='175'/>
<use f='include/unicode/numfmt.h' l='279' c='_ZNK6icu_6612NumberFormateqERKNS_6FormatE'/>
<ovr f='include/unicode/datefmt.h' l='156' c='icu_66::DateFormat'/>
<use f='include/unicode/datefmt.h' l='156'/>
<use f='include/unicode/datefmt.h' l='238' c='_ZNK6icu_6610DateFormateqERKNS_6FormatE'/>
<ovr f='include/unicode/tzfmt.h' l='274' c='icu_66::TimeZoneFormat'/>
<use f='include/unicode/tzfmt.h' l='274'/>
<use f='include/unicode/tzfmt.h' l='302' c='_ZNK6icu_6614TimeZoneFormateqERKNS_6FormatE'/>
<use f='include/unicode/smpdtfmt.h' l='879' c='_ZNK6icu_6616SimpleDateFormateqERKNS_6FormatE'/>
<use f='include/unicode/decimfmt.h' l='912' c='_ZNK6icu_6613DecimalFormateqERKNS_6FormatE'/>
<use f='include/unicode/rbnf.h' l='710' c='_ZNK6icu_6621RuleBasedNumberFormateqERKNS_6FormatE'/>
<size>328</size>
<doc f='include/unicode/format.h' l='48'>/**
 * Base class for all formats.  This is an abstract base class which
 * specifies the protocol for classes which convert other objects or
 * values, such as numeric values and dates, and their string
 * representations.  In some cases these representations may be
 * localized or contain localized characters or strings.  For example,
 * a numeric formatter such as DecimalFormat may convert a numeric
 * value such as 12345 to the string &quot;$12,345&quot;.  It may also parse
 * the string back into a numeric value.  A date and time formatter
 * like SimpleDateFormat may represent a specific date, encoded
 * numerically, as a string such as &quot;Wednesday, February 26, 1997 AD&quot;.
 * &lt;P&gt;
 * Many of the concrete subclasses of Format employ the notion of
 * a pattern.  A pattern is a string representation of the rules which
 * govern the interconversion between values and strings.  For example,
 * a DecimalFormat object may be associated with the pattern
 * &quot;$#,##0.00;($#,##0.00)&quot;, which is a common US English format for
 * currency values, yielding strings such as &quot;$1,234.45&quot; for 1234.45,
 * and &quot;($987.65)&quot; for 987.6543.  The specific syntax of a pattern
 * is defined by each subclass.
 * &lt;P&gt;
 * Even though many subclasses use patterns, the notion of a pattern
 * is not inherent to Format classes in general, and is not part of
 * the explicit base class protocol.
 * &lt;P&gt;
 * Two complex formatting classes bear mentioning.  These are
 * MessageFormat and ChoiceFormat.  ChoiceFormat is a subclass of
 * NumberFormat which allows the user to format different number ranges
 * as strings.  For instance, 0 may be represented as &quot;no files&quot;, 1 as
 * &quot;one file&quot;, and any number greater than 1 as &quot;many files&quot;.
 * MessageFormat is a formatter which utilizes other Format objects to
 * format a string containing with multiple values.  For instance,
 * A MessageFormat object might produce the string &quot;There are no files
 * on the disk MyDisk on February 27, 1997.&quot; given the arguments 0,
 * &quot;MyDisk&quot;, and the date value of 2/27/97.  See the ChoiceFormat
 * and MessageFormat headers for further information.
 * &lt;P&gt;
 * If formatting is unsuccessful, a failing UErrorCode is returned when
 * the Format cannot format the type of object, otherwise if there is
 * something illformed about the the Unicode replacement character
 * 0xFFFD is returned.
 * &lt;P&gt;
 * If there is no match when parsing, a parse failure UErrorCode is
 * retured for methods which take no ParsePosition.  For the method
 * that takes a ParsePosition, the index parameter is left unchanged.
 * &lt;P&gt;
 * &lt;em&gt;User subclasses are not supported.&lt;/em&gt; While clients may write
 * subclasses, such code will not necessarily work and will not be
 * guaranteed to work stably from release to release.
 */</doc>
<fun r='_ZN6icu_666FormatD1Ev'/>
<fun r='_ZNK6icu_666FormateqERKS0_'/>
<fun r='_ZNK6icu_666FormatneERKS0_'/>
<fun r='_ZNK6icu_666Format5cloneEv'/>
<fun r='_ZNK6icu_666Format6formatERKNS_11FormattableERNS_13UnicodeStringER10UErrorCode'/>
<fun r='_ZNK6icu_666Format6formatERKNS_11FormattableERNS_13UnicodeStringERNS_13FieldPositionER10UErrorCode'/>
<fun r='_ZNK6icu_666Format6formatERKNS_11FormattableERNS_13UnicodeStringEPNS_21FieldPositionIteratorER10UErrorCode'/>
<fun r='_ZNK6icu_666Format11parseObjectERKNS_13UnicodeStringERNS_11FormattableERNS_13ParsePositionE'/>
<fun r='_ZNK6icu_666Format11parseObjectERKNS_13UnicodeStringERNS_11FormattableER10UErrorCode'/>
<fun r='_ZNK6icu_666Format9getLocaleE18ULocDataLocaleTypeR10UErrorCode'/>
<fun r='_ZNK6icu_666Format11getLocaleIDE18ULocDataLocaleTypeR10UErrorCode'/>
<fun r='_ZN6icu_666Format12setLocaleIDsEPKcS2_'/>
<fun r='_ZN6icu_666FormatC1Ev'/>
<fun r='_ZN6icu_666FormatC1ERKS0_'/>
<fun r='_ZN6icu_666FormataSERKS0_'/>
<fun r='_ZN6icu_666Format11syntaxErrorERKNS_13UnicodeStringEiR11UParseError'/>
<mbr r='icu_66::Format::actualLocale' o='64' t='char[157]'/>
<mbr r='icu_66::Format::validLocale' o='1320' t='char[157]'/>
