<def f='boost-1.85.0/libs/json/include/boost/json/value_stack.hpp' l='112' ll='496'/>
<use f='boost-1.85.0/libs/json/include/boost/json/value_stack.hpp' l='157' c='_ZN5boost4json11value_stackC1ERKS1_'/>
<use f='boost-1.85.0/libs/json/include/boost/json/value_stack.hpp' l='160' c='_ZN5boost4json11value_stackaSERKS1_'/>
<use f='boost-1.85.0/libs/json/include/boost/json/value_stack.hpp' l='161' c='_ZN5boost4json11value_stackaSERKS1_'/>
<use f='boost-1.85.0/libs/json/include/boost/json/detail/handler.hpp' l='38'/>
<size>64</size>
<doc f='boost-1.85.0/libs/json/include/boost/json/value_stack.hpp' l='24'>/** A stack of @ref value elements, for building a document.

    This stack of @ref value allows iterative construction of a JSON document
    in memory. The implementation uses temporary internal storage to buffer
    elements so that arrays, objects, and strings in the document are
    constructed using a single memory allocation. This improves performance
    and makes efficient use of the `boost::container::pmr::memory_resource`
    used to create the resulting @ref value.

    Temporary storage used by the implementation initially comes from an
    optional memory buffer owned by the caller. If that storage is exhausted,
    then memory is obtained dynamically from the
    `boost::container::pmr::memory_resource` provided on construction.

    @par Usage

    Construct the stack with an optional initial temporary buffer, and a
    @ref storage_ptr to use for more storage when the initial buffer is
    exhausted. Then to build a @ref value, first call @ref reset and
    optionally specify the `boost::container::pmr::memory_resource` which will
    be used for the value. Then push elements onto the stack by calling the
    corresponding functions. After the document has been fully created, call
    @ref release to acquire ownership of the top-level @ref value.

    @par Performance

    The initial buffer and any dynamically allocated
    temporary buffers are retained until the stack
    is destroyed. This improves performance when using
    a single stack instance to produce multiple
    values.

    @par Example

    The following code constructs a @ref value which
    when serialized produces a JSON object with three
    elements. It uses a local buffer for the temporary
    storage, and a separate local buffer for the storage
    of the resulting value. No memory is dynamically
    allocated; this shows how to construct a value
    without using the heap.

    @code

    // This example builds a json::value without any dynamic memory allocations:

    // Construct the value stack using a local buffer
    unsigned char temp[4096];
    value_stack st( storage_ptr(), temp, sizeof(temp) );

    // Create a static resource with a local initial buffer
    unsigned char buf[4096];
    static_resource mr( buf, sizeof(buf) );

    // All values on the stack will use `mr`
    st.reset(&amp;mr);

    // Push the key/value pair &quot;a&quot;:1.
    st.push_key(&quot;a&quot;);
    st.push_int64(1);

    // Push &quot;b&quot;:null
    st.push_key(&quot;b&quot;);
    st.push_null();

    // Push &quot;c&quot;:&quot;hello&quot;
    st.push_key(&quot;c&quot;);
    st.push_string(&quot;hello&quot;);

    // Pop the three key/value pairs and push an object with those three values.
    st.push_object(3);

    // Pop the object from the stack and take ownership.
    value jv = st.release();

    assert( serialize(jv) == &quot;{\&quot;a\&quot;:1,\&quot;b\&quot;:null,\&quot;c\&quot;:\&quot;hello\&quot;}&quot; );

    // At this point we could re-use the stack by calling reset

    @endcode

    @par Thread Safety

    Distinct instances may be accessed concurrently.
    Non-const member functions of a shared instance
    may not be called concurrently with any other
    member functions of that instance.
*/</doc>
<mbr r='boost::json::value_stack::st_' o='0' t='boost::json::value_stack::stack'/>
<mbr r='boost::json::value_stack::sp_' o='448' t='boost::json::storage_ptr'/>
<fun r='_ZN5boost4json11value_stackC1ERKS1_'/>
<fun r='_ZN5boost4json11value_stackaSERKS1_'/>
<fun r='_ZN5boost4json11value_stackD1Ev'/>
<fun r='_ZN5boost4json11value_stackC1ENS0_11storage_ptrEPhm'/>
<fun r='_ZN5boost4json11value_stack5resetENS0_11storage_ptrE'/>
<fun r='_ZN5boost4json11value_stack7releaseEv'/>
<fun r='_ZN5boost4json11value_stack10push_arrayEm'/>
<fun r='_ZN5boost4json11value_stack11push_objectEm'/>
<fun r='_ZN5boost4json11value_stack10push_charsENS_4core17basic_string_viewIcEE'/>
<fun r='_ZN5boost4json11value_stack8push_keyENS_4core17basic_string_viewIcEE'/>
<fun r='_ZN5boost4json11value_stack11push_stringENS_4core17basic_string_viewIcEE'/>
<fun r='_ZN5boost4json11value_stack10push_int64El'/>
<fun r='_ZN5boost4json11value_stack11push_uint64Em'/>
<fun r='_ZN5boost4json11value_stack11push_doubleEd'/>
<fun r='_ZN5boost4json11value_stack9push_boolEb'/>
<fun r='_ZN5boost4json11value_stack9push_nullEv'/>
<fun r='_ZN5boost4json11value_stackD1Ev'/>
<fun r='_ZN5boost4json11value_stackC1ENS0_11storage_ptrEPhm'/>
<fun r='_ZN5boost4json11value_stack5resetENS0_11storage_ptrE'/>
<fun r='_ZN5boost4json11value_stack7releaseEv'/>
<fun r='_ZN5boost4json11value_stack10push_arrayEm'/>
<fun r='_ZN5boost4json11value_stack11push_objectEm'/>
<fun r='_ZN5boost4json11value_stack10push_charsENS_4core17basic_string_viewIcEE'/>
<fun r='_ZN5boost4json11value_stack8push_keyENS_4core17basic_string_viewIcEE'/>
<fun r='_ZN5boost4json11value_stack11push_stringENS_4core17basic_string_viewIcEE'/>
<fun r='_ZN5boost4json11value_stack10push_int64El'/>
<fun r='_ZN5boost4json11value_stack11push_uint64Em'/>
<fun r='_ZN5boost4json11value_stack11push_doubleEd'/>
<fun r='_ZN5boost4json11value_stack9push_boolEb'/>
<fun r='_ZN5boost4json11value_stack9push_nullEv'/>
