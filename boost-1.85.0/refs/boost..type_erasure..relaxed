<inh f='boost-1.85.0/libs/mpl/include/boost/mpl/vector/aux_/vector0.hpp' l='30' c='boost::mpl::vector0'/>
<def f='boost-1.85.0/libs/type_erasure/include/boost/type_erasure/relaxed.hpp' l='68'/>
<use f='boost-1.85.0/libs/type_erasure/include/boost/type_erasure/relaxed.hpp' l='84'/>
<size>1</size>
<doc f='boost-1.85.0/libs/type_erasure/include/boost/type_erasure/relaxed.hpp' l='45'>/**
 * This special concept enables various useful default behavior that
 * makes @ref any act like an ordinary object.  By default @ref any
 * forwards all operations to the underlying type, and provides only
 * the operations that are specified in its @c Concept.
 *
 * In detail, @ref relaxed enables the following:
 * - A raw value can be assigned to an @ref any.  This will replace
 *   the value stored by the @ref any.  (But note that if @ref assignable
 *   is present, it takes priority.)
 * - assignment of @ref any uses the constructor if it can&apos;t
 *   use @ref assignable (either because @ref assignable is missing,
 *   or because the stored types do not match).
 * - default construction of @ref any is allowed and creates a null any.
 * - @ref equality_comparable &quot;equality_comparable&quot;: If the types do not
 *   match, it will return false.
 * - @ref less_than_comparable &quot;less_than_comparable&quot;: If the types do not
 *   match, the ordering will be according to
 *   @c std::type_info::before.
 * - if the arguments to any other function do not match, it will throw
 *   a @ref bad_function_call exception instead of having undefined
 *   behavior.
 */</doc>
