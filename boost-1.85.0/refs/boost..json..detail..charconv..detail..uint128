<def f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/emulated128.hpp' l='22' ll='57'/>
<use f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/emulated128.hpp' l='27' c='_ZNR5boost4json6detail8charconv6detail7uint128pLEm'/>
<use f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/emulated128.hpp' l='73' c='_ZN5boost4json6detail8charconv6detail7umul128Emm'/>
<use f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/emulated128.hpp' l='145' c='_ZN5boost4json6detail8charconv6detail16umul192_upper128EmNS3_7uint128E'/>
<use f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/emulated128.hpp' l='145' c='_ZN5boost4json6detail8charconv6detail16umul192_upper128EmNS3_7uint128E'/>
<use f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/emulated128.hpp' l='175' c='_ZN5boost4json6detail8charconv6detail16umul192_lower128EmNS3_7uint128E'/>
<use f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/emulated128.hpp' l='175' c='_ZN5boost4json6detail8charconv6detail16umul192_lower128EmNS3_7uint128E'/>
<use f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/compute_float64.hpp' l='106' c='_ZN5boost4json6detail8charconv6detail15compute_float64ElmbRb'/>
<size>16</size>
<doc f='boost-1.85.0/libs/json/include/boost/json/detail/charconv/detail/emulated128.hpp' l='17'>// Compilers might support built-in 128-bit integer types. However, it seems that
// emulating them with a pair of 64-bit integers actually produces a better code,
// so we avoid using those built-ins. That said, they are still useful for
// implementing 64-bit x 64-bit -&gt; 128-bit multiplication.</doc>
<mbr r='boost::json::detail::charconv::detail::uint128::high' o='0' t='std::uint64_t'/>
<mbr r='boost::json::detail::charconv::detail::uint128::low' o='64' t='std::uint64_t'/>
<fun r='_ZNR5boost4json6detail8charconv6detail7uint128pLEm'/>
