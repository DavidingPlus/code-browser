<dec f='boost-1.85.0/libs/program_options/include/boost/program_options/options_description.hpp' l='77' type='void boost::program_options::option_description::option_description(const char * name, const boost::program_options::value_semantic * s)'/>
<doc f='boost-1.85.0/libs/program_options/include/boost/program_options/options_description.hpp' l='53'>/** Initializes the object with the passed data.

            Note: it would be nice to make the second parameter auto_ptr,
            to explicitly pass ownership. Unfortunately, it&apos;s often needed to
            create objects of types derived from &apos;value_semantic&apos;:
               options_description d;
               d.add_options()(&quot;a&quot;, parameter&lt;int&gt;(&quot;n&quot;)-&gt;default_value(1));
            Here, the static type returned by &apos;parameter&apos; should be derived
            from value_semantic.

            Alas, derived-&gt;base conversion for auto_ptr does not really work,
            see
            http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2000/n1232.pdf
            http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#84

            So, we have to use plain old pointers. Besides, users are not
            expected to use the constructor directly.

            
            The &apos;name&apos; parameter is interpreted by the following rules:
            - if there&apos;s no &quot;,&quot; character in &apos;name&apos;, it specifies long name
            - otherwise, the part before &quot;,&quot; specifies long name and the part
            after \-- short name.
        */</doc>
<def f='boost-1.85.0/libs/program_options/src/options_description.cpp' l='52' ll='58' type='void boost::program_options::option_description::option_description(const char * names, const boost::program_options::value_semantic * s)'/>
<use f='boost-1.85.0/libs/program_options/src/options_description.cpp' l='281' u='c' c='_ZN5boost15program_options29options_description_easy_initclEPKcPKNS0_14value_semanticE'/>
