<dec f='include/c++/9/bits/regex_executor.h' l='155' type='bool std::__detail::_Executor::_M_main_dispatch(std::__detail::_Executor::_Match_mode __match_mode, std::__detail::_Executor::__bfs )'/>
<def f='include/c++/9/bits/regex_executor.tcc' l='113' ll='142' type='bool std::__detail::_Executor::_M_main_dispatch(std::__detail::_Executor::_Match_mode __match_mode, std::__detail::_Executor::__bfs )'/>
<doc f='include/c++/9/bits/regex_executor.tcc' l='91'>// ------------------------------------------------------------
  //
  // BFS mode:
  //
  // Russ Cox&apos;s article (http://swtch.com/~rsc/regexp/regexp1.html)
  // explained this algorithm clearly.
  //
  // It first computes epsilon closure (states that can be achieved without
  // consuming characters) for every state that&apos;s still matching,
  // using the same DFS algorithm, but doesn&apos;t re-enter states (using
  // _M_states._M_visited to check), nor follow _S_opcode_match.
  //
  // Then apply DFS using every _S_opcode_match (in _M_states._M_match_queue)
  // as the start state.
  //
  // It significantly reduces potential duplicate states, so has a better
  // upper bound; but it requires more overhead.
  //
  // Time complexity: \Omega(match_length * match_results.size())
  //                  O(match_length * _M_nfa.size() * match_results.size())
  // Space complexity: \Omega(_M_nfa.size() + match_results.size())
  //                   O(_M_nfa.size() * match_results.size())</doc>
