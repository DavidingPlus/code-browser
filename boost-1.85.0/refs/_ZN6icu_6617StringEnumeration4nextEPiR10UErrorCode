<dec f='include/unicode/strenum.h' l='132' type='const char * icu_66::StringEnumeration::next(int32_t * resultLength, UErrorCode &amp; status)'/>
<use f='include/unicode/locid.h' l='1210' u='c' c='_ZNK6icu_666Locale11getKeywordsET0_R10UErrorCode'/>
<use f='include/unicode/locid.h' l='1227' u='c' c='_ZNK6icu_666Locale18getUnicodeKeywordsET0_R10UErrorCode'/>
<doc f='include/unicode/strenum.h' l='102'>/**
     * &lt;p&gt;Returns the next element as a NUL-terminated char*.  If there
     * are no more elements, returns NULL.  If the resultLength pointer
     * is not NULL, the length of the string (not counting the
     * terminating NUL) is returned at that address.  If an error
     * status is returned, the value at resultLength is undefined.&lt;/p&gt;
     *
     * &lt;p&gt;The returned pointer is owned by this iterator and must not be
     * deleted by the caller.  The pointer is valid until the next call
     * to next, unext, snext, reset, or the enumerator&apos;s destructor.&lt;/p&gt;
     *
     * &lt;p&gt;If the iterator is out of sync with its service, status is set
     * to U_ENUM_OUT_OF_SYNC_ERROR and NULL is returned.&lt;/p&gt;
     *
     * &lt;p&gt;If the native service string is a char16_t* string, it is
     * converted to char* with the invariant converter.  If the
     * conversion fails (because a character cannot be converted) then
     * status is set to U_INVARIANT_CONVERSION_ERROR and the return
     * value is undefined (though not NULL).&lt;/p&gt;
     *
     * Starting with ICU 2.8, the default implementation calls snext()
     * and handles the conversion.
     * Either next() or snext() must be implemented differently by a subclass.
     *
     * @param status the error code.
     * @param resultLength a pointer to receive the length, can be NULL.
     * @return a pointer to the string, or NULL.
     *
     * @stable ICU 2.4 
     */</doc>
