<dec f='include/unicode/rbnf.h' l='949' type='void icu_66::RuleBasedNumberFormat::setLenient(UBool enabled)'/>
<doc f='include/unicode/rbnf.h' l='916'>/**
   * Turns lenient parse mode on and off.
   *
   * When in lenient parse mode, the formatter uses a Collator for parsing the text.
   * Only primary differences are treated as significant.  This means that case
   * differences, accent differences, alternate spellings of the same letter
   * (e.g., ae and a-umlaut in German), ignorable characters, etc. are ignored in
   * matching the text.  In many cases, numerals will be accepted in place of words
   * or phrases as well.
   *
   * For example, all of the following will correctly parse as 255 in English in
   * lenient-parse mode:
   * &lt;br&gt;&quot;two hundred fifty-five&quot;
   * &lt;br&gt;&quot;two hundred fifty five&quot;
   * &lt;br&gt;&quot;TWO HUNDRED FIFTY-FIVE&quot;
   * &lt;br&gt;&quot;twohundredfiftyfive&quot;
   * &lt;br&gt;&quot;2 hundred fifty-5&quot;
   *
   * The Collator used is determined by the locale that was
   * passed to this object on construction.  The description passed to this object
   * on construction may supply additional collation rules that are appended to the
   * end of the default collator for the locale, enabling additional equivalences
   * (such as adding more ignorable characters or permitting spelled-out version of
   * symbols; see the demo program for examples).
   *
   * It&apos;s important to emphasize that even strict parsing is relatively lenient: it
   * will accept some text that it won&apos;t produce as output.  In English, for example,
   * it will correctly parse &quot;two hundred zero&quot; and &quot;fifteen hundred&quot;.
   *
   * @param enabled If true, turns lenient-parse mode on; if false, turns it off.
   * @see RuleBasedCollator
   * @stable ICU 2.0
   */</doc>
