<def f='boost-1.85.0/libs/log/include/boost/log/sinks/unbounded_fifo_queue.hpp' l='56' ll='131'/>
<use f='boost-1.85.0/libs/log/include/boost/log/sinks/async_frontend.hpp' l='126'/>
<size>16</size>
<doc f='boost-1.85.0/libs/log/include/boost/log/sinks/unbounded_fifo_queue.hpp' l='42'>/*!
 * \brief Unbounded FIFO log record queueing strategy
 *
 * The \c unbounded_fifo_queue class is intended to be used with
 * the \c asynchronous_sink frontend as a log record queueing strategy.
 *
 * This strategy implements the simplest logic of log record buffering between
 * threads: the queue has no limits and imposes no ordering over the queued
 * elements aside from the order in which they are enqueued.
 * Because of this the queue provides decent performance and scalability,
 * however if sink backends can&apos;t consume log records fast enough the queue
 * may grow uncontrollably. When this is an issue, it is recommended to
 * use one of the bounded strategies.
 */</doc>
<mbr r='boost::log::sinks::unbounded_fifo_queue::m_queue' o='0' t='boost::log::sinks::unbounded_fifo_queue::queue_type'/>
<mbr r='boost::log::sinks::unbounded_fifo_queue::m_event' o='64' t='boost::log::aux::event'/>
<mbr r='boost::log::sinks::unbounded_fifo_queue::m_interruption_requested' o='96' t='boost::atomic&lt;bool&gt;'/>
<fun r='_ZN5boost3log12v2s_mt_posix5sinks20unbounded_fifo_queueC1Ev'/>
<fun r='_ZN5boost3log12v2s_mt_posix5sinks20unbounded_fifo_queueC1ERKT_'/>
<fun r='_ZN5boost3log12v2s_mt_posix5sinks20unbounded_fifo_queue7enqueueERKNS1_11record_viewE'/>
<fun r='_ZN5boost3log12v2s_mt_posix5sinks20unbounded_fifo_queue11try_enqueueERKNS1_11record_viewE'/>
<fun r='_ZN5boost3log12v2s_mt_posix5sinks20unbounded_fifo_queue17try_dequeue_readyERNS1_11record_viewE'/>
<fun r='_ZN5boost3log12v2s_mt_posix5sinks20unbounded_fifo_queue11try_dequeueERNS1_11record_viewE'/>
<fun r='_ZN5boost3log12v2s_mt_posix5sinks20unbounded_fifo_queue13dequeue_readyERNS1_11record_viewE'/>
<fun r='_ZN5boost3log12v2s_mt_posix5sinks20unbounded_fifo_queue17interrupt_dequeueEv'/>
