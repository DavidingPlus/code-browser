<def f='boost-1.85.0/libs/xpressive/include/boost/xpressive/regex_iterator.hpp' l='207' ll='212' type='regex_iterator&lt;BidiIter&gt; &amp; boost::xpressive::regex_iterator::operator++()'/>
<doc f='boost-1.85.0/libs/xpressive/include/boost/xpressive/regex_iterator.hpp' l='185'>/// If what.prefix().first != what[0].second and if the element match_prev_avail is not set in
    /// flags then sets it. Then behaves as if by calling regex_search(what[0].second, end, what, *pre, flags),
    /// with the following variation: in the event that the previous match found was of zero length
    /// (what[0].length() == 0) then attempts to find a non-zero length match starting at what[0].second,
    /// only if that fails and provided what[0].second != suffix().second does it look for a (possibly
    /// zero length) match starting from what[0].second + 1.  If no further match is found then sets
    /// *this equal to the end of sequence iterator.
    /// \post (*this)-\&gt;size() == pre-\&gt;mark_count() + 1
    /// \post (*this)-\&gt;empty() == false
    /// \post (*this)-\&gt;prefix().first == An iterator denoting the end point of the previous match found
    /// \post (*this)-\&gt;prefix().last == (**this)[0].first
    /// \post (*this)-\&gt;prefix().matched == (*this)-\&gt;prefix().first != (*this)-\&gt;prefix().second
    /// \post (*this)-\&gt;suffix().first == (**this)[0].second
    /// \post (*this)-\&gt;suffix().last == end
    /// \post (*this)-\&gt;suffix().matched == (*this)-\&gt;suffix().first != (*this)-\&gt;suffix().second
    /// \post (**this)[0].first == The starting iterator for this match.
    /// \post (**this)[0].second == The ending iterator for this match.
    /// \post (**this)[0].matched == true if a full match was found, and false if it was a partial match (found as a result of the match_partial flag being set).
    /// \post (**this)[n].first == For all integers n \&lt; (*this)-\&gt;size(), the start of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end.
    /// \post (**this)[n].second == For all integers n \&lt; (*this)-\&gt;size(), the end of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end.
    /// \post (**this)[n].matched == For all integers n \&lt; (*this)-\&gt;size(), true if sub-expression n participated in the match, false otherwise.
    /// \post (*this)-\&gt;position() == The distance from the start of the original sequence being iterated, to the start of this match.</doc>
