<dec f='boost-1.85.0/libs/pool/include/boost/pool/simple_segregated_storage.hpp' l='71' type='static void * boost::simple_segregated_storage::try_malloc_n(void *&amp; start, boost::simple_segregated_storage::size_type n, boost::simple_segregated_storage::size_type partition_size)'/>
<def f='boost-1.85.0/libs/pool/include/boost/pool/simple_segregated_storage.hpp' l='326' ll='356' type='static void * boost::simple_segregated_storage::try_malloc_n(void *&amp; start, boost::simple_segregated_storage::size_type n, const boost::simple_segregated_storage::size_type partition_size)'/>
<use f='boost-1.85.0/libs/pool/include/boost/pool/simple_segregated_storage.hpp' l='376' u='c' c='_ZN5boost25simple_segregated_storage8malloc_nET_S1_'/>
<doc f='boost-1.85.0/libs/pool/include/boost/pool/simple_segregated_storage.hpp' l='312'>//! \pre (n &gt; 0), (start != 0), (nextof(start) != 0)
//! \post (start != 0)
//! The function attempts to find n contiguous chunks
//!  of size partition_size in the free list, starting at start.
//! If it succeds, it returns the last chunk in that contiguous
//!  sequence, so that the sequence is known by [start, {retval}]
//! If it fails, it does do either because it&apos;s at the end of the
//!  free list or hits a non-contiguous chunk.  In either case,
//!  it will return 0, and set start to the last considered
//!  chunk.  You are at the end of the free list if
//!  nextof(start) == 0.  Otherwise, start points to the last
//!  chunk in the contiguous sequence, and nextof(start) points
//!  to the first chunk in the next contiguous sequence (assuming
//!  an ordered free list).</doc>
