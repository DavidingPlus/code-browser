<def f='include/c++/9/bits/regex_constants.h' l='346' ll='347' type='const std::regex_constants::match_flag_type'/>
<use f='include/c++/9/bits/regex.h' l='1856' u='r' c='_ZNKSt7__cxx1113match_results6formatETL0__PKNSt15iterator_traitsIT_E10value_typeES7_NSt15regex_constants15match_flag_typeE'/>
<use f='include/c++/9/bits/regex.h' l='1864' u='r' c='_ZNKSt7__cxx1113match_results6formatETL0__RKNS_12basic_stringINSt15iterator_traitsIT_E10value_typeETL0_0_TL0_1_EENSt15regex_constants15match_flag_typeE'/>
<use f='include/c++/9/bits/regex.h' l='1876' u='r' c='_ZNKSt7__cxx1113match_results6formatERKNS_12basic_stringINSt15iterator_traitsIT_E10value_typeETL0__TL0_0_EENSt15regex_constants15match_flag_typeE'/>
<use f='include/c++/9/bits/regex.h' l='1888' u='r' c='_ZNKSt7__cxx1113match_results6formatEPKNSt15iterator_traitsIT_E10value_typeENSt15regex_constants15match_flag_typeE'/>
<use f='include/c++/9/bits/regex.h' l='1856' u='r' c='_ZNKSt7__cxx1113match_results6formatETL0__PKNSt15iterator_traitsIT_E10value_typeES7_NSt15regex_constants15match_flag_typeE'/>
<doc f='include/c++/9/bits/regex_constants.h' l='320'>/**
   * When a regular expression match is to be replaced by a new string, the
   * new string is constructed using the rules used by the ECMAScript replace
   * function in ECMA- 262 [Ecma International, ECMAScript Language
   * Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11
   * String.prototype.replace. In addition, during search and replace
   * operations all non-overlapping occurrences of the regular expression
   * are located and replaced, and sections of the input that did not match
   * the expression are copied unchanged to the output string.
   *
   * Format strings (from ECMA-262 [15.5.4.11]):
   * @li $$  The dollar-sign itself ($)
   * @li $&amp;  The matched substring.
   * @li $`  The portion of @a string that precedes the matched substring.
   *         This would be match_results::prefix().
   * @li $&apos;  The portion of @a string that follows the matched substring.
   *         This would be match_results::suffix().
   * @li $n  The nth capture, where n is in [1,9] and $n is not followed by a
   *         decimal digit.  If n &lt;= match_results::size() and the nth capture
   *         is undefined, use the empty string instead.  If n &gt;
   *         match_results::size(), the result is implementation-defined.
   * @li $nn The nnth capture, where nn is a two-digit decimal number on
   *         [01, 99].  If nn &lt;= match_results::size() and the nth capture is
   *         undefined, use the empty string instead. If
   *         nn &gt; match_results::size(), the result is implementation-defined.
   */</doc>
