<def f='boost-1.85.0/libs/move/include/boost/move/unique_ptr.hpp' l='528' ll='530' type='void boost::movelib::unique_ptr::unique_ptr&lt;T, D&gt;(unique_ptr&lt;T, D&gt; &amp;&amp; u)'/>
<doc f='boost-1.85.0/libs/move/include/boost/move/unique_ptr.hpp' l='518'>//! &lt;b&gt;Requires&lt;/b&gt;: If D is not a reference type, D shall satisfy the requirements of MoveConstructible.
   //! Construction of the deleter from an rvalue of type D shall not throw an exception.
   //! 
   //! &lt;b&gt;Effects&lt;/b&gt;: Constructs a unique_ptr by transferring ownership from u to *this. If D is a reference type,
   //! this deleter is copy constructed from u&apos;s deleter; otherwise, this deleter is move constructed from u&apos;s
   //! deleter.
   //! 
   //! &lt;b&gt;Postconditions&lt;/b&gt;: &lt;tt&gt;get()&lt;/tt&gt; yields the value u.get() yielded before the construction. &lt;tt&gt;get_deleter()&lt;/tt&gt;
   //! returns a reference to the stored deleter that was constructed from u.get_deleter(). If D is a
   //! reference type then &lt;tt&gt;get_deleter()&lt;/tt&gt; and &lt;tt&gt;u.get_deleter()&lt;/tt&gt; both reference the same lvalue deleter.</doc>
