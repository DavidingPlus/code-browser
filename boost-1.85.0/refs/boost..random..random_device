<inh f='boost-1.85.0/libs/core/include/boost/core/noncopyable.hpp' l='38' c='boost::noncopyable_::noncopyable'/>
<def f='boost-1.85.0/libs/random/include/boost/random/random_device.hpp' l='89' ll='135'/>
<size>8</size>
<doc f='boost-1.85.0/libs/random/include/boost/random/random_device.hpp' l='30'>/**
 * Class \random_device models a \nondeterministic_random_number_generator.
 * It uses one or more implementation-defined stochastic processes to
 * generate a sequence of uniformly distributed non-deterministic random
 * numbers. For those environments where a non-deterministic random number
 * generator is not available, class random_device must not be implemented. See
 *
 *  @blockquote
 *  &quot;Randomness Recommendations for Security&quot;, D. Eastlake, S. Crocker,
 *  J. Schiller, Network Working Group, RFC 1750, December 1994
 *  @endblockquote
 *
 * for further discussions. 
 *
 * @xmlnote
 * Some operating systems abstract the computer hardware enough
 * to make it difficult to non-intrusively monitor stochastic processes.
 * However, several do provide a special device for exactly this purpose.
 * It seems to be impossible to emulate the functionality using Standard
 * C++ only, so users should be aware that this class may not be available
 * on all platforms.
 * @endxmlnote
 *
 * &lt;b&gt;Implementation Note for Linux&lt;/b&gt;
 *
 * On the Linux operating system, token is interpreted as a filesystem
 * path. It is assumed that this path denotes an operating system
 * pseudo-device which generates a stream of non-deterministic random
 * numbers. The pseudo-device should never signal an error or end-of-file.
 * Otherwise, @c std::ios_base::failure is thrown. By default,
 * \random_device uses the /dev/urandom pseudo-device to retrieve
 * the random numbers. Another option would be to specify the /dev/random
 * pseudo-device, which blocks on reads if the entropy pool has no more
 * random bits available.
 *
 * &lt;b&gt;Implementation Note for Windows&lt;/b&gt;
 *
 * On the Windows operating system, token is interpreted as the name
 * of a cryptographic service provider.  By default \random_device uses
 * MS_DEF_PROV.
 *
 * &lt;b&gt;Performance&lt;/b&gt;
 *
 * The test program &lt;a href=&quot;\boost/libs/random/performance/nondet_random_speed.cpp&quot;&gt;
 * nondet_random_speed.cpp&lt;/a&gt; measures the execution times of the
 * random_device.hpp implementation of the above algorithms in a tight
 * loop. The performance has been evaluated on an
 * Intel(R) Core(TM) i7 CPU Q 840 \@ 1.87GHz, 1867 Mhz with
 * Visual C++ 2010, Microsoft Windows 7 Professional and with gcc 4.4.5,
 * Ubuntu Linux 2.6.35-25-generic.
 *
 * &lt;table cols=&quot;2&quot;&gt;
 *   &lt;tr&gt;&lt;th&gt;Platform&lt;/th&gt;&lt;th&gt;time per invocation [microseconds]&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt; Windows &lt;/td&gt;&lt;td&gt;2.9&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt; Linux &lt;/td&gt;&lt;td&gt;1.7&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * The measurement error is estimated at +/- 1 usec.
 */</doc>
<smbr r='boost::random::random_device::has_fixed_range' t='const bool'/>
<fun r='_ZN5boost6random13random_device3minEv'/>
<fun r='_ZN5boost6random13random_device3maxEv'/>
<fun r='_ZN5boost6random13random_deviceC1Ev'/>
<fun r='_ZN5boost6random13random_deviceC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<fun r='_ZN5boost6random13random_deviceD1Ev'/>
<fun r='_ZNK5boost6random13random_device7entropyEv'/>
<fun r='_ZN5boost6random13random_deviceclEv'/>
<fun r='_ZN5boost6random13random_device8generateET_S2_'/>
<mbr r='boost::random::random_device::pimpl' o='0' t='boost::random::random_device::impl *'/>
<smbr r='boost::random::random_device::has_fixed_range' t='const bool'/>
<fun r='_ZN5boost6random13random_deviceC1Ev'/>
<fun r='_ZN5boost6random13random_deviceC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<fun r='_ZN5boost6random13random_deviceD1Ev'/>
<fun r='_ZNK5boost6random13random_device7entropyEv'/>
<fun r='_ZN5boost6random13random_deviceclEv'/>
