<dec f='boost-1.85.0/libs/proto/include/boost/proto/repeat.hpp' l='308'/>
<doc f='boost-1.85.0/libs/proto/include/boost/proto/repeat.hpp' l='214'>/** \code

// Generate BOOST_PROTO_MAX_ARITY-1 overloads of the
// following construct() function template.
#define BOOST_PROTO_LOCAL_MACRO(N, typename_A, A_const_ref,       \
  A_const_ref_a, ref_a)                                           \
template&lt;typename T, typename_A(N)&gt;                               \
typename proto::result_of::make_expr&lt;                             \
    proto::tag::function                                          \
  , construct_helper&lt;T&gt;                                           \
  , A_const_ref(N)                                                \
&gt;::type const                                                     \
construct(A_const_ref_a(N))                                       \
{                                                                 \
    return proto::make_expr&lt;                                      \
        proto::tag::function                                      \
    &gt;(                                                            \
        construct_helper&lt;T&gt;()                                     \
      , ref_a(N)                                                  \
    );                                                            \
}
#define BOOST_PROTO_LOCAL_LIMITS (1, BOOST_PP_DEC(BOOST_PROTO_MAX_ARITY))
#include BOOST_PROTO_LOCAL_ITERATE()

\endcode
**/
/// The above inclusion of BOOST_PROTO_LOCAL_ITERATE() will generate
/// the following code:
///
/// \code
/// template&lt;typename T, typename A0&gt;
/// typename proto::result_of::make_expr&lt;
///     proto::tag::function
///   , construct_helper&lt;T&gt;
///  , A0 const &amp;
/// &gt;::type const
/// construct(A0 const &amp; a0)
/// {
///     return proto::make_expr&lt;
///         proto::tag::function
///     &gt;(
///         construct_helper&lt;T&gt;()
///       , boost::ref(a0)
///     );
/// }
///
/// template&lt;typename T, typename A0, typename A1&gt;
/// typename proto::result_of::make_expr&lt;
///     proto::tag::function
///   , construct_helper&lt;T&gt;
///   , A0 const &amp;
///   , A1 const &amp;
/// &gt;::type const
/// construct(A0 const &amp; a0, A1 const &amp; a1)
/// {
///     return proto::make_expr&lt;
///         proto::tag::function
///     &gt;(
///         construct_helper&lt;T&gt;()
///       , boost::ref(a0)
///       , boost::ref(a1)
///     );
/// }
///
/// // ... and so on, up to BOOST_PROTO_MAX_ARITY-1 arguments ...
/// \endcode
///
/// If BOOST_PROTO_LOCAL_LIMITS is not defined by the user, it defaults
/// to (1, BOOST_PROTO_MAX_ARITY)
///
/// At each iteration, BOOST_PROTO_LOCAL_MACRO is invoked with the current
/// iteration number and the following 4 macro parameters:
///
/// \li BOOST_PROTO_LOCAL_typename_A
/// \li BOOST_PROTO_LOCAL_A
/// \li BOOST_PROTO_LOCAL_A_a
/// \li BOOST_PROTO_LOCAL_a
///
/// If these macros are not defined by the user, they default respectively to:
///
/// \li BOOST_PROTO_typename_A
/// \li BOOST_PROTO_A_const_ref
/// \li BOOST_PROTO_A_const_ref_a
/// \li BOOST_PROTO_ref_a
///
/// After including BOOST_PROTO_LOCAL_ITERATE(), the following macros are
/// automatically undefined:
///
/// \li BOOST_PROTO_LOCAL_MACRO
/// \li BOOST_PROTO_LOCAL_LIMITS
/// \li BOOST_PROTO_LOCAL_typename_A
/// \li BOOST_PROTO_LOCAL_A
/// \li BOOST_PROTO_LOCAL_A_a
/// \li BOOST_PROTO_LOCAL_a</doc>
