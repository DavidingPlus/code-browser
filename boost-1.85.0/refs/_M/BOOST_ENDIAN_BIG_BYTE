<dec f='boost-1.85.0/libs/predef/include/boost/predef/other/endian.h' l='47'/>
<use f='boost-1.85.0/libs/predef/include/boost/predef/other/endian.h' l='55' u='c'/>
<use f='boost-1.85.0/libs/predef/include/boost/predef/other/endian.h' l='100' u='c'/>
<use f='boost-1.85.0/libs/predef/include/boost/predef/other/endian.h' l='117' u='c'/>
<use f='boost-1.85.0/libs/predef/include/boost/predef/other/endian.h' l='138' u='c'/>
<use f='boost-1.85.0/libs/predef/include/boost/predef/other/endian.h' l='161' u='c'/>
<use f='boost-1.85.0/libs/predef/include/boost/predef/other/endian.h' l='172' u='c'/>
<doc f='boost-1.85.0/libs/predef/include/boost/predef/other/endian.h' l='18'>/* tag::reference[]
= `BOOST_ENDIAN_*`

Detection of endian memory ordering. There are four defined macros
in this header that define the various generally possible endian
memory orderings:

* `BOOST_ENDIAN_BIG_BYTE`, byte-swapped big-endian.
* `BOOST_ENDIAN_BIG_WORD`, word-swapped big-endian.
* `BOOST_ENDIAN_LITTLE_BYTE`, byte-swapped little-endian.
* `BOOST_ENDIAN_LITTLE_WORD`, word-swapped little-endian.

The detection is conservative in that it only identifies endianness
that it knows for certain. In particular bi-endianness is not
indicated as is it not practically possible to determine the
endianness from anything but an operating system provided
header. And the currently known headers do not define that
programatic bi-endianness is available.

This implementation is a compilation of various publicly available
information and acquired knowledge:

. The indispensable documentation of &quot;Pre-defined Compiler Macros&quot;
  http://sourceforge.net/p/predef/wiki/Endianness[Endianness].
. The various endian specifications available in the
  http://wikipedia.org/[Wikipedia] computer architecture pages.
. Generally available searches for headers that define endianness.
*/ // end::reference[]</doc>
<use f='boost-1.85.0/libs/log/src/thread_id.cpp' l='98' u='c'/>
