<dec f='boost-1.85.0/libs/proto/include/boost/proto/repeat.hpp' l='169'/>
<doc f='boost-1.85.0/libs/proto/include/boost/proto/repeat.hpp' l='104'>/** \code

// Generate BOOST_PROTO_MAX_ARITY-1 overloads of the
// following construct() function template.
#define M0(N, typename_A, A_const_ref, A_const_ref_a, ref_a)      \
template&lt;typename T, typename_A(N)&gt;                               \
typename proto::result_of::make_expr&lt;                             \
    proto::tag::function                                          \
  , construct_helper&lt;T&gt;                                           \
  , A_const_ref(N)                                                \
&gt;::type const                                                     \
construct(A_const_ref_a(N))                                       \
{                                                                 \
    return proto::make_expr&lt;                                      \
        proto::tag::function                                      \
    &gt;(                                                            \
        construct_helper&lt;T&gt;()                                     \
      , ref_a(N)                                                  \
    );                                                            \
}
BOOST_PROTO_REPEAT_FROM_TO(1, BOOST_PROTO_MAX_ARITY, M0)
#undef M0

\endcode
**/
/// The above invocation of BOOST_PROTO_REPEAT_FROM_TO()  will generate
/// the following code:
///
/// \code
/// template&lt;typename T, typename A0&gt;
/// typename proto::result_of::make_expr&lt;
///     proto::tag::function
///   , construct_helper&lt;T&gt;
///  , A0 const &amp;
/// &gt;::type const
/// construct(A0 const &amp; a0)
/// {
///     return proto::make_expr&lt;
///         proto::tag::function
///     &gt;(
///         construct_helper&lt;T&gt;()
///       , boost::ref(a0)
///     );
/// }
///
/// template&lt;typename T, typename A0, typename A1&gt;
/// typename proto::result_of::make_expr&lt;
///     proto::tag::function
///   , construct_helper&lt;T&gt;
///   , A0 const &amp;
///   , A1 const &amp;
/// &gt;::type const
/// construct(A0 const &amp; a0, A1 const &amp; a1)
/// {
///     return proto::make_expr&lt;
///         proto::tag::function
///     &gt;(
///         construct_helper&lt;T&gt;()
///       , boost::ref(a0)
///       , boost::ref(a1)
///     );
/// }
///
/// // ... and so on, up to BOOST_PROTO_MAX_ARITY-1 arguments ...
/// \endcode</doc>
