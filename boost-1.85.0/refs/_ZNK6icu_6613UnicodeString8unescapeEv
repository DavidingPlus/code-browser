<dec f='include/unicode/unistr.h' l='3412' type='icu_66::UnicodeString icu_66::UnicodeString::unescape() const'/>
<doc f='include/unicode/unistr.h' l='3378'>/**
   * Unescape a string of characters and return a string containing
   * the result.  The following escape sequences are recognized:
   *
   * \\uhhhh       4 hex digits; h in [0-9A-Fa-f]
   * \\Uhhhhhhhh   8 hex digits
   * \\xhh         1-2 hex digits
   * \\ooo         1-3 octal digits; o in [0-7]
   * \\cX          control-X; X is masked with 0x1F
   *
   * as well as the standard ANSI C escapes:
   *
   * \\a =&gt; U+0007, \\b =&gt; U+0008, \\t =&gt; U+0009, \\n =&gt; U+000A,
   * \\v =&gt; U+000B, \\f =&gt; U+000C, \\r =&gt; U+000D, \\e =&gt; U+001B,
   * \\&quot; =&gt; U+0022, \\&apos; =&gt; U+0027, \\? =&gt; U+003F, \\\\ =&gt; U+005C
   *
   * Anything else following a backslash is generically escaped.  For
   * example, &quot;[a\\-z]&quot; returns &quot;[a-z]&quot;.
   *
   * If an escape sequence is ill-formed, this method returns an empty
   * string.  An example of an ill-formed sequence is &quot;\\u&quot; followed by
   * fewer than 4 hex digits.
   *
   * This function is similar to u_unescape() but not identical to it.
   * The latter takes a source char*, so it does escape recognition
   * and also invariant conversion.
   *
   * @return a string with backslash escapes interpreted, or an
   * empty string on error.
   * @see UnicodeString#unescapeAt()
   * @see u_unescape()
   * @see u_unescapeAt()
   * @stable ICU 2.0
   */</doc>
