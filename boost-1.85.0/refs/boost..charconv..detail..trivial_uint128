<def f='boost-1.85.0/libs/charconv/include/boost/charconv/detail/emulated128.hpp' l='28' ll='37'/>
<use f='boost-1.85.0/libs/charconv/include/boost/charconv/detail/emulated128.hpp' l='54' c='_ZN5boost8charconv6detail7uint128C1ERKNS1_15trivial_uint128E'/>
<use f='boost-1.85.0/libs/charconv/include/boost/charconv/detail/emulated128.hpp' l='56' c='_ZN5boost8charconv6detail7uint128C1EONS1_15trivial_uint128E'/>
<use f='boost-1.85.0/libs/charconv/include/boost/charconv/detail/emulated128.hpp' l='109' c='_ZN5boost8charconv6detail7uint128aSERKNS1_15trivial_uint128E'/>
<size>16</size>
<doc f='boost-1.85.0/libs/charconv/include/boost/charconv/detail/emulated128.hpp' l='22'>// Compilers might support built-in 128-bit integer types. However, it seems that
// emulating them with a pair of 64-bit integers actually produces a better code,
// so we avoid using those built-ins. That said, they are still useful for
// implementing 64-bit x 64-bit -&gt; 128-bit multiplication.

// Memcpy-able temp class for uint128</doc>
<mbr r='boost::charconv::detail::trivial_uint128::low' o='0' t='std::uint64_t'/>
<mbr r='boost::charconv::detail::trivial_uint128::high' o='64' t='std::uint64_t'/>
<use f='boost-1.85.0/libs/charconv/src/to_chars_float_impl.hpp' l='215' c='_ZN5boost8charconv6detail13convert_valueET0_'/>
<size>16</size>
