<use f='boost-1.85.0/libs/property_tree/include/boost/property_tree/detail/rapidxml.hpp' l='887' u='w' c='_ZN5boost13property_tree6detail8rapidxml8xml_nodeC1ENS2_9node_typeE'/>
<use f='boost-1.85.0/libs/property_tree/include/boost/property_tree/detail/rapidxml.hpp' l='900' u='r' c='_ZNK5boost13property_tree6detail8rapidxml8xml_node4typeEv'/>
<use f='boost-1.85.0/libs/property_tree/include/boost/property_tree/detail/rapidxml.hpp' l='1052' u='w' c='_ZN5boost13property_tree6detail8rapidxml8xml_node4typeENS2_9node_typeE'/>
<dec f='boost-1.85.0/libs/property_tree/include/boost/property_tree/detail/rapidxml.hpp' l='1322' type='boost::property_tree::detail::rapidxml::node_type'/>
<doc f='boost-1.85.0/libs/property_tree/include/boost/property_tree/detail/rapidxml.hpp' l='1310'>///////////////////////////////////////////////////////////////////////////
        // Data members
    
        // Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.
        // This is required for maximum performance, as it allows the parser to omit initialization of 
        // unneeded/redundant values.
        //
        // The rules are as follows:
        // 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively
        // 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage
        // 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage</doc>
<doc f='boost-1.85.0/libs/property_tree/include/boost/property_tree/detail/rapidxml.hpp' l='1322'>// Type of node; always valid</doc>
