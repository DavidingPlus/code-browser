<def f='boost-1.85.0/libs/unordered/include/boost/unordered/detail/prime_fmod.hpp' l='147' ll='166' type='static boost::uint64_t boost::unordered::detail::prime_fmod_size::get_remainder(boost::uint64_t fractional, boost::uint32_t d)'/>
<use f='boost-1.85.0/libs/unordered/include/boost/unordered/detail/prime_fmod.hpp' l='172' u='c' c='_ZN5boost9unordered6detail15prime_fmod_size11fast_moduloEjmj'/>
<doc f='boost-1.85.0/libs/unordered/include/boost/unordered/detail/prime_fmod.hpp' l='138'>// We emulate the techniques taken from:
        // Faster Remainder by Direct Computation: Applications to Compilers and
        // Software Libraries
        // https://arxiv.org/abs/1902.01961
        //
        // In essence, use fancy math to directly calculate the remainder (aka
        // modulo) exploiting how compilers transform division
        //</doc>
