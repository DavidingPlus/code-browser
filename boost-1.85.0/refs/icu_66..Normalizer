<inh f='include/unicode/uobject.h' l='223' c='icu_66::UObject'/>
<def f='include/unicode/normlzr.h' l='136' ll='773'/>
<use f='include/unicode/normlzr.h' l='194' c='_ZN6icu_6610NormalizerC1ERKS0_'/>
<use f='include/unicode/normlzr.h' l='587' c='_ZNK6icu_6610NormalizereqERKS0_'/>
<use f='include/unicode/normlzr.h' l='597' c='_ZNK6icu_6610NormalizerneERKS0_'/>
<use f='include/unicode/normlzr.h' l='605' c='_ZNK6icu_6610Normalizer5cloneEv'/>
<use f='include/unicode/normlzr.h' l='744' c='_ZN6icu_6610NormalizeraSERKS0_'/>
<use f='include/unicode/normlzr.h' l='744' c='_ZN6icu_6610NormalizeraSERKS0_'/>
<use f='include/unicode/normlzr.h' l='781' c='_ZNK6icu_6610NormalizerneERKS0_'/>
<size>120</size>
<doc f='include/unicode/normlzr.h' l='32'>/**
 * Old Unicode normalization API.
 *
 * This API has been replaced by the Normalizer2 class and is only available
 * for backward compatibility. This class simply delegates to the Normalizer2 class.
 * There is one exception: The new API does not provide a replacement for Normalizer::compare().
 *
 * The Normalizer class supports the standard normalization forms described in
 * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/&quot; target=&quot;unicode&quot;&gt;
 * Unicode Standard Annex #15: Unicode Normalization Forms&lt;/a&gt;.
 *
 * The Normalizer class consists of two parts:
 * - static functions that normalize strings or test if strings are normalized
 * - a Normalizer object is an iterator that takes any kind of text and
 *   provides iteration over its normalized form
 *
 * The Normalizer class is not suitable for subclassing.
 *
 * For basic information about normalization forms and details about the C API
 * please see the documentation in unorm.h.
 *
 * The iterator API with the Normalizer constructors and the non-static functions
 * use a CharacterIterator as input. It is possible to pass a string which
 * is then internally wrapped in a CharacterIterator.
 * The input text is not normalized all at once, but incrementally where needed
 * (providing efficient random access).
 * This allows to pass in a large text but spend only a small amount of time
 * normalizing a small part of that text.
 * However, if the entire text is normalized, then the iterator will be
 * slower than normalizing the entire text at once and iterating over the result.
 * A possible use of the Normalizer iterator is also to report an index into the
 * original text that is close to where the normalized characters come from.
 *
 * &lt;em&gt;Important:&lt;/em&gt; The iterator API was cleaned up significantly for ICU 2.0.
 * The earlier implementation reported the getIndex() inconsistently,
 * and previous() could not be used after setIndex(), next(), first(), and current().
 *
 * Normalizer allows to start normalizing from anywhere in the input text by
 * calling setIndexOnly(), first(), or last().
 * Without calling any of these, the iterator will start at the beginning of the text.
 *
 * At any time, next() returns the next normalized code point (UChar32),
 * with post-increment semantics (like CharacterIterator::next32PostInc()).
 * previous() returns the previous normalized code point (UChar32),
 * with pre-decrement semantics (like CharacterIterator::previous32()).
 *
 * current() returns the current code point
 * (respectively the one at the newly set index) without moving
 * the getIndex(). Note that if the text at the current position
 * needs to be normalized, then these functions will do that.
 * (This is why current() is not const.)
 * It is more efficient to call setIndexOnly() instead, which does not
 * normalize.
 *
 * getIndex() always refers to the position in the input text where the normalized
 * code points are returned from. It does not always change with each returned
 * code point.
 * The code point that is returned from any of the functions
 * corresponds to text at or after getIndex(), according to the
 * function&apos;s iteration semantics (post-increment or pre-decrement).
 *
 * next() returns a code point from at or after the getIndex()
 * from before the next() call. After the next() call, the getIndex()
 * might have moved to where the next code point will be returned from
 * (from a next() or current() call).
 * This is semantically equivalent to array access with array[index++]
 * (post-increment semantics).
 *
 * previous() returns a code point from at or after the getIndex()
 * from after the previous() call.
 * This is semantically equivalent to array access with array[--index]
 * (pre-decrement semantics).
 *
 * Internally, the Normalizer iterator normalizes a small piece of text
 * starting at the getIndex() and ending at a following &quot;safe&quot; index.
 * The normalized results is stored in an internal string buffer, and
 * the code points are iterated from there.
 * With multiple iteration calls, this is repeated until the next piece
 * of text needs to be normalized, and the getIndex() needs to be moved.
 *
 * The following &quot;safe&quot; index, the internal buffer, and the secondary
 * iteration index into that buffer are not exposed on the API.
 * This also means that it is currently not practical to return to
 * a particular, arbitrary position in the text because one would need to
 * know, and be able to set, in addition to the getIndex(), at least also the
 * current index into the internal buffer.
 * It is currently only possible to observe when getIndex() changes
 * (with careful consideration of the iteration semantics),
 * at which time the internal index will be 0.
 * For example, if getIndex() is different after next() than before it,
 * then the internal index is 0 and one can return to this getIndex()
 * later with setIndexOnly().
 *
 * Note: While the setIndex() and getIndex() refer to indices in the
 * underlying Unicode input text, the next() and previous() methods
 * iterate through characters in the normalized output.
 * This means that there is not necessarily a one-to-one correspondence
 * between characters returned by next() and previous() and the indices
 * passed to and returned from setIndex() and getIndex().
 * It is for this reason that Normalizer does not implement the CharacterIterator interface.
 *
 * @author Laura Werner, Mark Davis, Markus Scherer
 * @stable ICU 2.0
 */</doc>
<fun r='_ZN6icu_6610NormalizerC1ERKNS_13UnicodeStringE18UNormalizationMode'/>
<fun r='_ZN6icu_6610NormalizerC1ENS_14ConstChar16PtrEi18UNormalizationMode'/>
<fun r='_ZN6icu_6610NormalizerC1ERKNS_17CharacterIteratorE18UNormalizationMode'/>
<fun r='_ZN6icu_6610NormalizerC1ERKS0_'/>
<fun r='_ZN6icu_6610NormalizerD1Ev'/>
<fun r='_ZN6icu_6610Normalizer9normalizeERKNS_13UnicodeStringE18UNormalizationModeiRS1_R10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer7composeERKNS_13UnicodeStringEaiRS1_R10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer9decomposeERKNS_13UnicodeStringEaiRS1_R10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer10quickCheckERKNS_13UnicodeStringE18UNormalizationModeR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer10quickCheckERKNS_13UnicodeStringE18UNormalizationModeiR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer12isNormalizedERKNS_13UnicodeStringE18UNormalizationModeR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer12isNormalizedERKNS_13UnicodeStringE18UNormalizationModeiR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer11concatenateERKNS_13UnicodeStringES3_RS1_18UNormalizationModeiR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer7compareERKNS_13UnicodeStringES3_jR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer7currentEv'/>
<fun r='_ZN6icu_6610Normalizer5firstEv'/>
<fun r='_ZN6icu_6610Normalizer4lastEv'/>
<fun r='_ZN6icu_6610Normalizer4nextEv'/>
<fun r='_ZN6icu_6610Normalizer8previousEv'/>
<fun r='_ZN6icu_6610Normalizer12setIndexOnlyEi'/>
<fun r='_ZN6icu_6610Normalizer5resetEv'/>
<fun r='_ZNK6icu_6610Normalizer8getIndexEv'/>
<fun r='_ZNK6icu_6610Normalizer10startIndexEv'/>
<fun r='_ZNK6icu_6610Normalizer8endIndexEv'/>
<fun r='_ZNK6icu_6610NormalizereqERKS0_'/>
<fun r='_ZNK6icu_6610NormalizerneERKS0_'/>
<fun r='_ZNK6icu_6610Normalizer5cloneEv'/>
<fun r='_ZNK6icu_6610Normalizer8hashCodeEv'/>
<fun r='_ZN6icu_6610Normalizer7setModeE18UNormalizationMode'/>
<fun r='_ZNK6icu_6610Normalizer8getUModeEv'/>
<fun r='_ZN6icu_6610Normalizer9setOptionEia'/>
<fun r='_ZNK6icu_6610Normalizer9getOptionEi'/>
<fun r='_ZN6icu_6610Normalizer7setTextERKNS_13UnicodeStringER10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer7setTextERKNS_17CharacterIteratorER10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer7setTextENS_14ConstChar16PtrEiR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer7getTextERNS_13UnicodeStringE'/>
<fun r='_ZN6icu_6610Normalizer16getStaticClassIDEv'/>
<fun r='_ZNK6icu_6610Normalizer17getDynamicClassIDEv'/>
<fun r='_ZN6icu_6610NormalizerC1Ev'/>
<fun r='_ZN6icu_6610NormalizeraSERKS0_'/>
<fun r='_ZN6icu_6610Normalizer13nextNormalizeEv'/>
<fun r='_ZN6icu_6610Normalizer17previousNormalizeEv'/>
<fun r='_ZN6icu_6610Normalizer4initEv'/>
<fun r='_ZN6icu_6610Normalizer11clearBufferEv'/>
<mbr r='icu_66::Normalizer::fFilteredNorm2' o='64' t='icu_66::FilteredNormalizer2 *'/>
<mbr r='icu_66::Normalizer::fNorm2' o='128' t='const icu_66::Normalizer2 *'/>
<mbr r='icu_66::Normalizer::fUMode' o='192' t='UNormalizationMode'/>
<mbr r='icu_66::Normalizer::fOptions' o='224' t='int32_t'/>
<mbr r='icu_66::Normalizer::text' o='256' t='icu_66::CharacterIterator *'/>
<mbr r='icu_66::Normalizer::currentIndex' o='320' t='int32_t'/>
<mbr r='icu_66::Normalizer::nextIndex' o='352' t='int32_t'/>
<mbr r='icu_66::Normalizer::buffer' o='384' t='icu_66::UnicodeString'/>
<mbr r='icu_66::Normalizer::bufferPos' o='896' t='int32_t'/>
<fun r='_ZNK6icu_6610NormalizerneERKS0_'/>
<fun r='_ZN6icu_6610Normalizer10quickCheckERKNS_13UnicodeStringE18UNormalizationModeR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer12isNormalizedERKNS_13UnicodeStringE18UNormalizationModeR10UErrorCode'/>
<fun r='_ZN6icu_6610Normalizer7compareERKNS_13UnicodeStringES3_jR10UErrorCode'/>
