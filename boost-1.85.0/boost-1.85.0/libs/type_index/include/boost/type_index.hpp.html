<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>type_index.hpp source code [boost-1.85.0/libs/type_index/include/boost/type_index.hpp] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'boost-1.85.0/libs/type_index/include/boost/type_index.hpp'; var root_path = '../../../../..'; var data_path = '../../../../../../data'; var ecma_script_api_version = 2;</script>
<script src='../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>boost-1.85.0</a>/<a href='../../..'>libs</a>/<a href='../..'>type_index</a>/<a href='..'>include</a>/<a href='./'>boost</a>/<a href='type_index.hpp.html'>type_index.hpp</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>//</i></td></tr>
<tr><th id="2">2</th><td><i>// Copyright 2012-2024 Antony Polukhin.</i></td></tr>
<tr><th id="3">3</th><td><i>//</i></td></tr>
<tr><th id="4">4</th><td><i>// Distributed under the Boost Software License, Version 1.0. (See accompanying</i></td></tr>
<tr><th id="5">5</th><td><i>// file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></td></tr>
<tr><th id="6">6</th><td><i>//</i></td></tr>
<tr><th id="7">7</th><td></td></tr>
<tr><th id="8">8</th><td><u>#<span data-ppcond="8">ifndef</span> <span class="macro" data-ref="_M/BOOST_TYPE_INDEX_HPP">BOOST_TYPE_INDEX_HPP</span></u></td></tr>
<tr><th id="9">9</th><td><u>#define <dfn class="macro" id="_M/BOOST_TYPE_INDEX_HPP" data-ref="_M/BOOST_TYPE_INDEX_HPP">BOOST_TYPE_INDEX_HPP</dfn></u></td></tr>
<tr><th id="10">10</th><td></td></tr>
<tr><th id="11">11</th><td><i class="doc">/// <span class="command">\file</span> <span class="verb">boost/type_index.hpp</span></i></td></tr>
<tr><th id="12">12</th><td><i class="doc">/// <span class="command">\brief</span> Includes minimal set of headers required to use the Boost.TypeIndex library.</i></td></tr>
<tr><th id="13">13</th><td><i class="doc">///</i></td></tr>
<tr><th id="14">14</th><td><i class="doc">/// By inclusion of this file most optimal type index classes will be included and used </i></td></tr>
<tr><th id="15">15</th><td><i class="doc">/// as a boost::typeindex::type_index and boost::typeindex::type_info.</i></td></tr>
<tr><th id="16">16</th><td></td></tr>
<tr><th id="17">17</th><td><u>#include <a href="../../../config/include/boost/config.hpp.html">&lt;boost/config.hpp&gt;</a></u></td></tr>
<tr><th id="18">18</th><td></td></tr>
<tr><th id="19">19</th><td><u>#<span data-ppcond="19">ifdef</span> <a class="macro" href="../../../config/include/boost/config/compiler/clang.hpp.html#11" data-ref="_M/BOOST_HAS_PRAGMA_ONCE">BOOST_HAS_PRAGMA_ONCE</a></u></td></tr>
<tr><th id="20">20</th><td><u># pragma once</u></td></tr>
<tr><th id="21">21</th><td><u>#<span data-ppcond="19">endif</span></u></td></tr>
<tr><th id="22">22</th><td></td></tr>
<tr><th id="23">23</th><td><u>#<span data-ppcond="23">if</span> defined(<span class="macro" data-ref="_M/BOOST_TYPE_INDEX_USER_TYPEINDEX">BOOST_TYPE_INDEX_USER_TYPEINDEX</span>)</u></td></tr>
<tr><th id="24">24</th><td><u>#   include BOOST_TYPE_INDEX_USER_TYPEINDEX</u></td></tr>
<tr><th id="25">25</th><td><u>#   ifdef BOOST_HAS_PRAGMA_DETECT_MISMATCH</u></td></tr>
<tr><th id="26">26</th><td><u>#       pragma detect_mismatch( "boost__type_index__abi", "user defined type_index class is used: " BOOST_STRINGIZE(BOOST_TYPE_INDEX_USER_TYPEINDEX))</u></td></tr>
<tr><th id="27">27</th><td><u>#   endif</u></td></tr>
<tr><th id="28">28</th><td><u>#<span data-ppcond="23">elif</span> (!defined(<span class="macro" data-ref="_M/BOOST_NO_RTTI">BOOST_NO_RTTI</span>) &amp;&amp; !defined(<span class="macro" data-ref="_M/BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY">BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY</span>)) || defined(<span class="macro" data-ref="_M/BOOST_MSVC">BOOST_MSVC</span>)</u></td></tr>
<tr><th id="29">29</th><td><u>#   include <a href="type_index/stl_type_index.hpp.html">&lt;boost/type_index/stl_type_index.hpp&gt;</a></u></td></tr>
<tr><th id="30">30</th><td><u>#   <span data-ppcond="30">if</span> defined(<span class="macro" data-ref="_M/BOOST_NO_RTTI">BOOST_NO_RTTI</span>) || defined(<span class="macro" data-ref="_M/BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY">BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY</span>)</u></td></tr>
<tr><th id="31">31</th><td><u>#       include &lt;boost/type_index/detail/stl_register_class.hpp&gt;</u></td></tr>
<tr><th id="32">32</th><td><u>#       ifdef BOOST_HAS_PRAGMA_DETECT_MISMATCH</u></td></tr>
<tr><th id="33">33</th><td><u>#           pragma detect_mismatch( "boost__type_index__abi", "RTTI is off - typeid() is used only for templates")</u></td></tr>
<tr><th id="34">34</th><td><u>#       endif</u></td></tr>
<tr><th id="35">35</th><td><u>#   <span data-ppcond="30">else</span></u></td></tr>
<tr><th id="36">36</th><td><u>#       <span data-ppcond="36">ifdef</span> <span class="macro" data-ref="_M/BOOST_HAS_PRAGMA_DETECT_MISMATCH">BOOST_HAS_PRAGMA_DETECT_MISMATCH</span></u></td></tr>
<tr><th id="37">37</th><td><u>#           pragma detect_mismatch( "boost__type_index__abi", "RTTI is used")</u></td></tr>
<tr><th id="38">38</th><td><u>#       <span data-ppcond="36">endif</span></u></td></tr>
<tr><th id="39">39</th><td><u>#   <span data-ppcond="30">endif</span></u></td></tr>
<tr><th id="40">40</th><td><u>#<span data-ppcond="23">else</span></u></td></tr>
<tr><th id="41">41</th><td><u>#   include &lt;boost/type_index/ctti_type_index.hpp&gt;</u></td></tr>
<tr><th id="42">42</th><td><u>#   include &lt;boost/type_index/detail/ctti_register_class.hpp&gt;</u></td></tr>
<tr><th id="43">43</th><td><u>#   ifdef BOOST_HAS_PRAGMA_DETECT_MISMATCH</u></td></tr>
<tr><th id="44">44</th><td><u>#       pragma detect_mismatch( "boost__type_index__abi", "RTTI is off - using CTTI")</u></td></tr>
<tr><th id="45">45</th><td><u>#   endif</u></td></tr>
<tr><th id="46">46</th><td><u>#<span data-ppcond="23">endif</span></u></td></tr>
<tr><th id="47">47</th><td></td></tr>
<tr><th id="48">48</th><td><u>#<span data-ppcond="48">ifndef</span> <span class="macro" data-ref="_M/BOOST_TYPE_INDEX_REGISTER_CLASS">BOOST_TYPE_INDEX_REGISTER_CLASS</span></u></td></tr>
<tr><th id="49">49</th><td><u>#define <dfn class="macro" id="_M/BOOST_TYPE_INDEX_REGISTER_CLASS" data-ref="_M/BOOST_TYPE_INDEX_REGISTER_CLASS">BOOST_TYPE_INDEX_REGISTER_CLASS</dfn></u></td></tr>
<tr><th id="50">50</th><td><u>#<span data-ppcond="48">endif</span></u></td></tr>
<tr><th id="51">51</th><td></td></tr>
<tr><th id="52">52</th><td><b>namespace</b> <span class="namespace">boost</span> { <b>namespace</b> <span class="namespace">typeindex</span> {</td></tr>
<tr><th id="53">53</th><td></td></tr>
<tr><th id="54">54</th><td><u>#<span data-ppcond="54">if</span> defined(<span class="macro" data-ref="_M/BOOST_TYPE_INDEX_DOXYGEN_INVOKED">BOOST_TYPE_INDEX_DOXYGEN_INVOKED</span>)</u></td></tr>
<tr><th id="55">55</th><td></td></tr>
<tr><th id="56">56</th><td><i class="doc">/// <span class="command">\def</span> <span class="verb">BOOST_TYPE_INDEX_FUNCTION_SIGNATURE</span></i></td></tr>
<tr><th id="57">57</th><td><i class="doc">/// BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is used by boost::typeindex::ctti_type_index class to</i></td></tr>
<tr><th id="58">58</th><td><i class="doc">/// deduce the name of a type. If your compiler is not recognized</i></td></tr>
<tr><th id="59">59</th><td><i class="doc">/// by the TypeIndex library and you wish to work with boost::typeindex::ctti_type_index, you may</i></td></tr>
<tr><th id="60">60</th><td><i class="doc">/// define this macro by yourself.</i></td></tr>
<tr><th id="61">61</th><td><i class="doc">///</i></td></tr>
<tr><th id="62">62</th><td><i class="doc">/// BOOST_TYPE_INDEX_FUNCTION_SIGNATURE must be defined to a compiler specific macro</i></td></tr>
<tr><th id="63">63</th><td><i class="doc">/// that outputs the<span class="command"> \b</span> <span class="arg">whole</span> function signature<span class="command"> \b</span> <span class="arg">including</span><span class="command"> \b</span> <span class="arg">template</span><span class="command"> \b</span> <span class="arg">parameters.</span></i></td></tr>
<tr><th id="64">64</th><td><i class="doc">///</i></td></tr>
<tr><th id="65">65</th><td><i class="doc">/// If your compiler is not recognised and BOOST_TYPE_INDEX_FUNCTION_SIGNATURE is not defined,</i></td></tr>
<tr><th id="66">66</th><td><i class="doc">/// then a compile-time error will arise at any attempt to use boost::typeindex::ctti_type_index classes.</i></td></tr>
<tr><th id="67">67</th><td><i class="doc">///</i></td></tr>
<tr><th id="68">68</th><td><i class="doc">/// See BOOST_TYPE_INDEX_REGISTER_CTTI_PARSING_PARAMS and BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING</i></td></tr>
<tr><th id="69">69</th><td><i class="doc">/// for an information of how to tune the implementation to make a nice pretty_name() output.</i></td></tr>
<tr><th id="70">70</th><td><u>#define BOOST_TYPE_INDEX_FUNCTION_SIGNATURE BOOST_CURRENT_FUNCTION</u></td></tr>
<tr><th id="71">71</th><td></td></tr>
<tr><th id="72">72</th><td><i class="doc">/// <span class="command">\def</span> <span class="verb">BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING</span></i></td></tr>
<tr><th id="73">73</th><td><i class="doc">/// This is a helper macro for making correct pretty_names() with RTTI off.</i></td></tr>
<tr><th id="74">74</th><td><i class="doc">///</i></td></tr>
<tr><th id="75">75</th><td><i class="doc">/// BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to</i></td></tr>
<tr><th id="76">76</th><td><i class="doc">/// '(begin_skip, end_skip, runtime_skip, runtime_skip_until)' with parameters for adding a</i></td></tr>
<tr><th id="77">77</th><td><i class="doc">/// support for compilers, that by default are not recognized by TypeIndex library.</i></td></tr>
<tr><th id="78">78</th><td><i class="doc">///</i></td></tr>
<tr><th id="79">79</th><td><i class="doc">///<span class="command"> \b</span> <span class="arg">Example:</span></i></td></tr>
<tr><th id="80">80</th><td><i class="doc">///</i></td></tr>
<tr><th id="81">81</th><td><i class="doc">/// Imagine the situation when</i></td></tr>
<tr><th id="82">82</th><td><i class="doc">/// <span class="command">\code</span><span class="verb"> boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name() \</span>endcode</i></td></tr>
<tr><th id="83">83</th><td><i class="doc">/// returns the following string:</i></td></tr>
<tr><th id="84">84</th><td><i class="doc">/// <span class="command">\code</span><span class="verb"> "static const char *boost::detail::ctti&lt;int&gt;::n() [T = int]" \</span>endcode</i></td></tr>
<tr><th id="85">85</th><td><i class="doc">/// and <span class="command">\code</span><span class="verb"> boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name() \</span>endcode returns the following:</i></td></tr>
<tr><th id="86">86</th><td><i class="doc">/// <span class="command">\code</span><span class="verb"> "static const char *boost::detail::ctti&lt;short&gt;::n() [T = short]" \</span>endcode</i></td></tr>
<tr><th id="87">87</th><td><i class="doc">///</i></td></tr>
<tr><th id="88">88</th><td><i class="doc">/// As we may see first 39 characters are "static const char *boost::detail::ctti&lt;" and they do not depend on</i></td></tr>
<tr><th id="89">89</th><td><i class="doc">/// the type T. After first 39 characters we have a human readable type name which is duplicated at the end</i></td></tr>
<tr><th id="90">90</th><td><i class="doc">/// of a string. String always ends on ']', which consumes 1 character.</i></td></tr>
<tr><th id="91">91</th><td><i class="doc">///</i></td></tr>
<tr><th id="92">92</th><td><i class="doc">/// Now if we define `BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING` to</i></td></tr>
<tr><th id="93">93</th><td><i class="doc">/// `(39, 1, false, "")` we'll be getting <span class="command">\code</span><span class="verb"> "int&gt;::n() [T = int" \</span>endcode</i></td></tr>
<tr><th id="94">94</th><td><i class="doc">/// for `boost::typeindex::ctti_type_index::type_id&lt;int&gt;().pretty_name()` and <span class="command">\code</span><span class="verb"> "short&gt;::n() [T = short" \</span>endcode</i></td></tr>
<tr><th id="95">95</th><td><i class="doc">/// for `boost::typeindex::ctti_type_index::type_id&lt;short&gt;().pretty_name()`.</i></td></tr>
<tr><th id="96">96</th><td><i class="doc">///</i></td></tr>
<tr><th id="97">97</th><td><i class="doc">/// Now we need to take additional care of the characters that go before the last mention of our type. We'll</i></td></tr>
<tr><th id="98">98</th><td><i class="doc">/// do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = "</i></td></tr>
<tr><th id="99">99</th><td><i class="doc">/// itself:</i></td></tr>
<tr><th id="100">100</th><td><i class="doc">///</i></td></tr>
<tr><th id="101">101</th><td><i class="doc">/// <span class="command">\code</span><span class="verb"> (39, 1, true, "T = ") \</span>endcode</i></td></tr>
<tr><th id="102">102</th><td><i class="doc">///</i></td></tr>
<tr><th id="103">103</th><td><i class="doc">/// In case of GCC or Clang command line we need to add the following line while compiling all the sources:</i></td></tr>
<tr><th id="104">104</th><td><i class="doc">///</i></td></tr>
<tr><th id="105">105</th><td><i class="doc">/// <span class="command">\code</span></i></td></tr>
<tr><th id="106">106</th><td><i class="doc">///<span class="verb"> -DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING='(39, 1, true, "T = ")'</span></i></td></tr>
<tr><th id="107">107</th><td><i class="doc"><span class="verb"></span>/// \endcode</i></td></tr>
<tr><th id="108">108</th><td><i class="doc">/// <span class="command">\param</span> <span class="arg">begin_skip</span> How many characters must be skipped at the beginning of the type holding string.</i></td></tr>
<tr><th id="109">109</th><td><i class="doc">/// Must be a compile time constant.</i></td></tr>
<tr><th id="110">110</th><td><i class="doc">/// <span class="command">\param</span> <span class="arg">end_skip</span> How many characters must be skipped at the end of the type holding string.</i></td></tr>
<tr><th id="111">111</th><td><i class="doc">/// Must be a compile time constant.</i></td></tr>
<tr><th id="112">112</th><td><i class="doc">/// <span class="command">\param</span> <span class="arg">runtime_skip</span> Do we need additional checks at runtime to cut off the more characters.</i></td></tr>
<tr><th id="113">113</th><td><i class="doc">/// Must be `true` or `false`.</i></td></tr>
<tr><th id="114">114</th><td><i class="doc">/// <span class="command">\param</span> <span class="arg">runtime_skip_until</span> Skip all the characters before the following string (including the string itself).</i></td></tr>
<tr><th id="115">115</th><td><i class="doc">/// Must be a compile time array of characters.</i></td></tr>
<tr><th id="116">116</th><td><i class="doc">///</i></td></tr>
<tr><th id="117">117</th><td><i class="doc">/// See [RTTI emulation limitations](boost_typeindex/rtti_emulation_limitations.html) for more info.</i></td></tr>
<tr><th id="118">118</th><td><u>#define BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING (0, 0, false, "")</u></td></tr>
<tr><th id="119">119</th><td></td></tr>
<tr><th id="120">120</th><td></td></tr>
<tr><th id="121">121</th><td>    <i class="doc">/// Depending on a compiler flags, optimal implementation of type_index will be used </i></td></tr>
<tr><th id="122">122</th><td><i class="doc">    /// as a default boost::typeindex::type_index.</i></td></tr>
<tr><th id="123">123</th><td><i class="doc">    ///</i></td></tr>
<tr><th id="124">124</th><td><i class="doc">    /// Could be a boost::typeindex::stl_type_index, boost::typeindex::ctti_type_index or </i></td></tr>
<tr><th id="125">125</th><td><i class="doc">    /// user defined type_index class.</i></td></tr>
<tr><th id="126">126</th><td><i class="doc">    ///</i></td></tr>
<tr><th id="127">127</th><td><i class="doc">    ///<span class="command"> \b</span> <span class="arg">See</span> boost::typeindex::type_index_facade for a full description of type_index functions.</i></td></tr>
<tr><th id="128">128</th><td>    <b>typedef</b> platform_specific type_index;</td></tr>
<tr><th id="129">129</th><td><u>#<span data-ppcond="54">elif</span> defined(<span class="macro" data-ref="_M/BOOST_TYPE_INDEX_USER_TYPEINDEX">BOOST_TYPE_INDEX_USER_TYPEINDEX</span>)</u></td></tr>
<tr><th id="130">130</th><td>    <i>// Nothing to do</i></td></tr>
<tr><th id="131">131</th><td><u>#<span data-ppcond="54">elif</span> (!defined(<span class="macro" data-ref="_M/BOOST_NO_RTTI">BOOST_NO_RTTI</span>) &amp;&amp; !defined(<span class="macro" data-ref="_M/BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY">BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY</span>)) || defined(<span class="macro" data-ref="_M/BOOST_MSVC">BOOST_MSVC</span>)</u></td></tr>
<tr><th id="132">132</th><td>    <b>typedef</b> <span class="namespace">boost::typeindex::</span><a class="type" href="type_index/stl_type_index.hpp.html#boost::typeindex::stl_type_index" title='boost::typeindex::stl_type_index' data-ref="boost::typeindex::stl_type_index">stl_type_index</a> <dfn class="typedef" id="boost::typeindex::type_index" title='boost::typeindex::type_index' data-type='boost::typeindex::stl_type_index' data-ref="boost::typeindex::type_index">type_index</dfn>;</td></tr>
<tr><th id="133">133</th><td><u>#<span data-ppcond="54">else</span></u> </td></tr>
<tr><th id="134">134</th><td>    <b>typedef</b> boost::typeindex::ctti_type_index type_index;</td></tr>
<tr><th id="135">135</th><td><u>#<span data-ppcond="54">endif</span></u></td></tr>
<tr><th id="136">136</th><td></td></tr>
<tr><th id="137">137</th><td><i class="doc">/// Depending on a compiler flags, optimal implementation of type_info will be used </i></td></tr>
<tr><th id="138">138</th><td><i class="doc">/// as a default boost::typeindex::type_info.</i></td></tr>
<tr><th id="139">139</th><td><i class="doc">///</i></td></tr>
<tr><th id="140">140</th><td><i class="doc">/// Could be a std::type_info, boost::typeindex::detail::ctti_data or </i></td></tr>
<tr><th id="141">141</th><td><i class="doc">/// some user defined class.</i></td></tr>
<tr><th id="142">142</th><td><i class="doc">///</i></td></tr>
<tr><th id="143">143</th><td><i class="doc">/// type_info<span class="command"> \b</span> <span class="arg">is</span><span class="command"> \b</span> <span class="arg">not</span> copyable or default constructible. It is<span class="command"> \b</span> <span class="arg">not</span> assignable too!</i></td></tr>
<tr><th id="144">144</th><td><b>typedef</b> <a class="typedef" href="#boost::typeindex::type_index" title='boost::typeindex::type_index' data-type='boost::typeindex::stl_type_index' data-ref="boost::typeindex::type_index">type_index</a>::<a class="typedef" href="type_index/stl_type_index.hpp.html#boost::typeindex::stl_type_index::type_info_t" title='boost::typeindex::stl_type_index::type_info_t' data-type='std::type_info' data-ref="boost::typeindex::stl_type_index::type_info_t">type_info_t</a> <dfn class="typedef" id="boost::typeindex::type_info" title='boost::typeindex::type_info' data-type='type_index::type_info_t' data-ref="boost::typeindex::type_info">type_info</dfn>;</td></tr>
<tr><th id="145">145</th><td></td></tr>
<tr><th id="146">146</th><td><u>#<span data-ppcond="146">if</span> defined(<span class="macro" data-ref="_M/BOOST_TYPE_INDEX_DOXYGEN_INVOKED">BOOST_TYPE_INDEX_DOXYGEN_INVOKED</span>)</u></td></tr>
<tr><th id="147">147</th><td></td></tr>
<tr><th id="148">148</th><td><i class="doc">/// <span class="command">\def</span> <span class="verb">BOOST_TYPE_INDEX_USER_TYPEINDEX</span></i></td></tr>
<tr><th id="149">149</th><td><i class="doc">/// BOOST_TYPE_INDEX_USER_TYPEINDEX can be defined to the path to header file</i></td></tr>
<tr><th id="150">150</th><td><i class="doc">/// with user provided implementation of type_index.</i></td></tr>
<tr><th id="151">151</th><td><i class="doc">///</i></td></tr>
<tr><th id="152">152</th><td><i class="doc">/// See [Making a custom type_index](boost_typeindex/making_a_custom_type_index.html) section</i></td></tr>
<tr><th id="153">153</th><td><i class="doc">/// of documentation for usage example.</i></td></tr>
<tr><th id="154">154</th><td><u>#define BOOST_TYPE_INDEX_USER_TYPEINDEX &lt;full/absolute/path/to/header/with/type_index.hpp&gt;</u></td></tr>
<tr><th id="155">155</th><td></td></tr>
<tr><th id="156">156</th><td></td></tr>
<tr><th id="157">157</th><td><i class="doc">/// <span class="command">\def</span> <span class="verb">BOOST_TYPE_INDEX_REGISTER_CLASS</span></i></td></tr>
<tr><th id="158">158</th><td><i class="doc">/// BOOST_TYPE_INDEX_REGISTER_CLASS is used to help to emulate RTTI.</i></td></tr>
<tr><th id="159">159</th><td><i class="doc">/// Put this macro into the public section of polymorphic class to allow runtime type detection.</i></td></tr>
<tr><th id="160">160</th><td><i class="doc">///</i></td></tr>
<tr><th id="161">161</th><td><i class="doc">/// Depending on the typeid() availability this macro will expand to nothing or to virtual helper function</i></td></tr>
<tr><th id="162">162</th><td><i class="doc">/// `virtual const type_info&amp; boost_type_info_type_id_runtime_() const noexcept`.</i></td></tr>
<tr><th id="163">163</th><td><i class="doc">///</i></td></tr>
<tr><th id="164">164</th><td><i class="doc">///<span class="command"> \b</span> <span class="arg">Example:</span></i></td></tr>
<tr><th id="165">165</th><td><i class="doc">/// <span class="command">\code</span></i></td></tr>
<tr><th id="166">166</th><td><i class="doc">///<span class="verb"> class A {</span></i></td></tr>
<tr><th id="167">167</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> public:</span></i></td></tr>
<tr><th id="168">168</th><td><i class="doc"><span class="verb"></span>///<span class="verb">     BOOST_TYPE_INDEX_REGISTER_CLASS</span></i></td></tr>
<tr><th id="169">169</th><td><i class="doc"><span class="verb"></span>///<span class="verb">     virtual ~A(){}</span></i></td></tr>
<tr><th id="170">170</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> };</span></i></td></tr>
<tr><th id="171">171</th><td><i class="doc"><span class="verb"></span>///<span class="verb"></span></i></td></tr>
<tr><th id="172">172</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> struct B: public A {</span></i></td></tr>
<tr><th id="173">173</th><td><i class="doc"><span class="verb"></span>///<span class="verb">     BOOST_TYPE_INDEX_REGISTER_CLASS</span></i></td></tr>
<tr><th id="174">174</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> };</span></i></td></tr>
<tr><th id="175">175</th><td><i class="doc"><span class="verb"></span>///<span class="verb"></span></i></td></tr>
<tr><th id="176">176</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> struct C: public B {</span></i></td></tr>
<tr><th id="177">177</th><td><i class="doc"><span class="verb"></span>///<span class="verb">     BOOST_TYPE_INDEX_REGISTER_CLASS</span></i></td></tr>
<tr><th id="178">178</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> };</span></i></td></tr>
<tr><th id="179">179</th><td><i class="doc"><span class="verb"></span>///<span class="verb"></span></i></td></tr>
<tr><th id="180">180</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> ...</span></i></td></tr>
<tr><th id="181">181</th><td><i class="doc"><span class="verb"></span>///<span class="verb"></span></i></td></tr>
<tr><th id="182">182</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> C c1;</span></i></td></tr>
<tr><th id="183">183</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> A* pc1 = &amp;c1;</span></i></td></tr>
<tr><th id="184">184</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> assert(boost::typeindex::type_id&lt;C&gt;() == boost::typeindex::type_id_runtime(*pc1));</span></i></td></tr>
<tr><th id="185">185</th><td><i class="doc"><span class="verb"></span>/// \endcode</i></td></tr>
<tr><th id="186">186</th><td><u>#define BOOST_TYPE_INDEX_REGISTER_CLASS nothing-or-some-virtual-functions</u></td></tr>
<tr><th id="187">187</th><td></td></tr>
<tr><th id="188">188</th><td><i class="doc">/// <span class="command">\def</span> <span class="verb">BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY</span></i></td></tr>
<tr><th id="189">189</th><td><i class="doc">/// BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY is a helper macro that must be defined if mixing</i></td></tr>
<tr><th id="190">190</th><td><i class="doc">/// RTTI on/off modules. See</i></td></tr>
<tr><th id="191">191</th><td><i class="doc">/// [Mixing sources with RTTI on and RTTI off](boost_typeindex/mixing_sources_with_rtti_on_and_.html)</i></td></tr>
<tr><th id="192">192</th><td><i class="doc">/// section of documentation for more info.</i></td></tr>
<tr><th id="193">193</th><td><u>#define BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY</u></td></tr>
<tr><th id="194">194</th><td></td></tr>
<tr><th id="195">195</th><td><u>#<span data-ppcond="146">endif</span> // defined(BOOST_TYPE_INDEX_DOXYGEN_INVOKED)</u></td></tr>
<tr><th id="196">196</th><td></td></tr>
<tr><th id="197">197</th><td></td></tr>
<tr><th id="198">198</th><td><i class="doc">/// Function to get boost::typeindex::type_index for a type T.</i></td></tr>
<tr><th id="199">199</th><td><i class="doc">/// Removes const, volatile &amp;&amp; and &amp; modifiers from T.</i></td></tr>
<tr><th id="200">200</th><td><i class="doc">///</i></td></tr>
<tr><th id="201">201</th><td><i class="doc">///<span class="command"> \b</span> <span class="arg">Example:</span></i></td></tr>
<tr><th id="202">202</th><td><i class="doc">/// <span class="command">\code</span></i></td></tr>
<tr><th id="203">203</th><td><i class="doc">///<span class="verb"> type_index ti = type_id&lt;int&amp;&gt;();</span></i></td></tr>
<tr><th id="204">204</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> std::cout &lt;&lt; ti.pretty_name();  // Outputs 'int'</span></i></td></tr>
<tr><th id="205">205</th><td><i class="doc"><span class="verb"></span>/// \endcode</i></td></tr>
<tr><th id="206">206</th><td><i class="doc">///</i></td></tr>
<tr><th id="207">207</th><td><i class="doc">/// <span class="command">\tparam</span> <span class="arg">T</span> Type for which type_index must be created.</i></td></tr>
<tr><th id="208">208</th><td><i class="doc">/// <span class="command">\throw</span> Nothing.</i></td></tr>
<tr><th id="209">209</th><td><i class="doc">/// <span class="command">\return</span> boost::typeindex::type_index with information about the specified type T.</i></td></tr>
<tr><th id="210">210</th><td><b>template</b> &lt;<b>class</b> T&gt;</td></tr>
<tr><th id="211">211</th><td><b>inline</b> <a class="typedef" href="#boost::typeindex::type_index" title='boost::typeindex::type_index' data-type='boost::typeindex::stl_type_index' data-ref="boost::typeindex::type_index">type_index</a> <dfn class="decl def fn" id="_ZN5boost9typeindex7type_idEv" title='boost::typeindex::type_id' data-ref="_ZN5boost9typeindex7type_idEv">type_id</dfn>() <b>noexcept</b> {</td></tr>
<tr><th id="212">212</th><td>    <b>return</b> <a class="typedef" href="#boost::typeindex::type_index" title='boost::typeindex::type_index' data-type='boost::typeindex::stl_type_index' data-ref="boost::typeindex::type_index">type_index</a>::type_id&lt;T&gt;();</td></tr>
<tr><th id="213">213</th><td>}</td></tr>
<tr><th id="214">214</th><td></td></tr>
<tr><th id="215">215</th><td><i class="doc">/// Function for constructing boost::typeindex::type_index instance for type T. </i></td></tr>
<tr><th id="216">216</th><td><i class="doc">/// Does not remove const, volatile, &amp; and &amp;&amp; modifiers from T.</i></td></tr>
<tr><th id="217">217</th><td><i class="doc">///</i></td></tr>
<tr><th id="218">218</th><td><i class="doc">/// If T has no const, volatile, &amp; and &amp;&amp; modifiers, then returns exactly </i></td></tr>
<tr><th id="219">219</th><td><i class="doc">/// the same result as in case of calling `type_id&lt;T&gt;()`.</i></td></tr>
<tr><th id="220">220</th><td><i class="doc">///</i></td></tr>
<tr><th id="221">221</th><td><i class="doc">///<span class="command"> \b</span> <span class="arg">Example:</span></i></td></tr>
<tr><th id="222">222</th><td><i class="doc">/// <span class="command">\code</span></i></td></tr>
<tr><th id="223">223</th><td><i class="doc">///<span class="verb"> type_index ti = type_id_with_cvr&lt;int&amp;&gt;();</span></i></td></tr>
<tr><th id="224">224</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> std::cout &lt;&lt; ti.pretty_name();  // Outputs 'int&amp;'</span></i></td></tr>
<tr><th id="225">225</th><td><i class="doc"><span class="verb"></span>/// \endcode</i></td></tr>
<tr><th id="226">226</th><td><i class="doc">///</i></td></tr>
<tr><th id="227">227</th><td><i class="doc">/// <span class="command">\tparam</span> <span class="arg">T</span> Type for which type_index must be created.</i></td></tr>
<tr><th id="228">228</th><td><i class="doc">/// <span class="command">\throw</span> Nothing.</i></td></tr>
<tr><th id="229">229</th><td><i class="doc">/// <span class="command">\return</span> boost::typeindex::type_index with information about the specified type T.</i></td></tr>
<tr><th id="230">230</th><td><b>template</b> &lt;<b>class</b> T&gt;</td></tr>
<tr><th id="231">231</th><td><b>inline</b> <a class="typedef" href="#boost::typeindex::type_index" title='boost::typeindex::type_index' data-type='boost::typeindex::stl_type_index' data-ref="boost::typeindex::type_index">type_index</a> <dfn class="decl def fn" id="_ZN5boost9typeindex16type_id_with_cvrEv" title='boost::typeindex::type_id_with_cvr' data-ref="_ZN5boost9typeindex16type_id_with_cvrEv">type_id_with_cvr</dfn>() <b>noexcept</b> {</td></tr>
<tr><th id="232">232</th><td>    <b>return</b> <a class="typedef" href="#boost::typeindex::type_index" title='boost::typeindex::type_index' data-type='boost::typeindex::stl_type_index' data-ref="boost::typeindex::type_index">type_index</a>::type_id_with_cvr&lt;T&gt;();</td></tr>
<tr><th id="233">233</th><td>}</td></tr>
<tr><th id="234">234</th><td></td></tr>
<tr><th id="235">235</th><td><i class="doc">/// Function that works exactly like C++ typeid(rtti_val) call, but returns boost::type_index.</i></td></tr>
<tr><th id="236">236</th><td><i class="doc">///</i></td></tr>
<tr><th id="237">237</th><td><i class="doc">/// Returns runtime information about specified type.</i></td></tr>
<tr><th id="238">238</th><td><i class="doc">///</i></td></tr>
<tr><th id="239">239</th><td><i class="doc">///<span class="command"> \b</span> <span class="arg">Requirements:</span> RTTI available or Base and Derived classes must be marked with BOOST_TYPE_INDEX_REGISTER_CLASS.</i></td></tr>
<tr><th id="240">240</th><td><i class="doc">///</i></td></tr>
<tr><th id="241">241</th><td><i class="doc">///<span class="command"> \b</span> <span class="arg">Example:</span></i></td></tr>
<tr><th id="242">242</th><td><i class="doc">/// <span class="command">\code</span></i></td></tr>
<tr><th id="243">243</th><td><i class="doc">///<span class="verb"> struct Base { virtual ~Base(){} };</span></i></td></tr>
<tr><th id="244">244</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> struct Derived: public Base  {};</span></i></td></tr>
<tr><th id="245">245</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> ...</span></i></td></tr>
<tr><th id="246">246</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> Derived d;</span></i></td></tr>
<tr><th id="247">247</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> Base&amp; b = d;</span></i></td></tr>
<tr><th id="248">248</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> type_index ti = type_id_runtime(b);</span></i></td></tr>
<tr><th id="249">249</th><td><i class="doc"><span class="verb"></span>///<span class="verb"> std::cout &lt;&lt; ti.pretty_name();  // Outputs 'Derived'</span></i></td></tr>
<tr><th id="250">250</th><td><i class="doc"><span class="verb"></span>/// \endcode</i></td></tr>
<tr><th id="251">251</th><td><i class="doc">///</i></td></tr>
<tr><th id="252">252</th><td><i class="doc">/// <span class="command">\param</span> <span class="arg">runtime_val</span> Variable which runtime type must be returned.</i></td></tr>
<tr><th id="253">253</th><td><i class="doc">/// <span class="command">\throw</span> Nothing.</i></td></tr>
<tr><th id="254">254</th><td><i class="doc">/// <span class="command">\return</span> boost::typeindex::type_index with information about the specified variable.</i></td></tr>
<tr><th id="255">255</th><td><b>template</b> &lt;<b>class</b> T&gt;</td></tr>
<tr><th id="256">256</th><td><b>inline</b> <a class="typedef" href="#boost::typeindex::type_index" title='boost::typeindex::type_index' data-type='boost::typeindex::stl_type_index' data-ref="boost::typeindex::type_index">type_index</a> <dfn class="decl def fn" id="_ZN5boost9typeindex15type_id_runtimeERKT_" title='boost::typeindex::type_id_runtime' data-ref="_ZN5boost9typeindex15type_id_runtimeERKT_">type_id_runtime</dfn>(<em>const</em> T&amp; <dfn class="local col7 decl" id="77runtime_val" title='runtime_val' data-type='const T &amp;' data-ref="77runtime_val">runtime_val</dfn>) <b>noexcept</b> {</td></tr>
<tr><th id="257">257</th><td>    <b>return</b> <a class="typedef" href="#boost::typeindex::type_index" title='boost::typeindex::type_index' data-type='boost::typeindex::stl_type_index' data-ref="boost::typeindex::type_index">type_index</a>::type_id_runtime(<a class="local col7 ref" href="#77runtime_val" title='runtime_val' data-ref="77runtime_val">runtime_val</a>);</td></tr>
<tr><th id="258">258</th><td>}</td></tr>
<tr><th id="259">259</th><td></td></tr>
<tr><th id="260">260</th><td>}} <i>// namespace boost::typeindex</i></td></tr>
<tr><th id="261">261</th><td></td></tr>
<tr><th id="262">262</th><td></td></tr>
<tr><th id="263">263</th><td></td></tr>
<tr><th id="264">264</th><td><u>#<span data-ppcond="8">endif</span> // BOOST_TYPE_INDEX_HPP</u></td></tr>
<tr><th id="265">265</th><td></td></tr>
<tr><th id="266">266</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../contract/src/contract.cpp.html'>boost-1.85.0/libs/contract/src/contract.cpp</a><br/>Generated on <em>2024-Jun-14</em> from project boost-1.85.0 revision <em>1.85.0</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
