<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>wireless.h source code [include/linux/wireless.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="iw_discarded,iw_encode_ext,iw_event,iw_freq,iw_michaelmicfailure,iw_missed,iw_mlme,iw_param,iw_pmkid_cand,iw_pmksa,iw_point,iw_priv_args,iw_quality,iw_range,iw_scan_req,iw_statistics,iw_thrspy,iwreq,iwreq_data "/>
<link rel="stylesheet" href="../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'include/linux/wireless.h'; var root_path = '../..'; var data_path = '../../../data'; var ecma_script_api_version = 2;</script>
<script src='../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='..'>include</a>/<a href='./'>linux</a>/<a href='wireless.h.html'>wireless.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</i></td></tr>
<tr><th id="2">2</th><td><i>/*</i></td></tr>
<tr><th id="3">3</th><td><i> * This file define a set of standard wireless extensions</i></td></tr>
<tr><th id="4">4</th><td><i> *</i></td></tr>
<tr><th id="5">5</th><td><i> * Version :	22	16.3.07</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> * Authors :	Jean Tourrilhes - HPL - &lt;jt@hpl.hp.com&gt;</i></td></tr>
<tr><th id="8">8</th><td><i> * Copyright (c) 1997-2007 Jean Tourrilhes, All Rights Reserved.</i></td></tr>
<tr><th id="9">9</th><td><i> */</i></td></tr>
<tr><th id="10">10</th><td></td></tr>
<tr><th id="11">11</th><td><u>#<span data-ppcond="11">ifndef</span> <span class="macro" data-ref="_M/_LINUX_WIRELESS_H">_LINUX_WIRELESS_H</span></u></td></tr>
<tr><th id="12">12</th><td><u>#define <dfn class="macro" id="_M/_LINUX_WIRELESS_H" data-ref="_M/_LINUX_WIRELESS_H">_LINUX_WIRELESS_H</dfn></u></td></tr>
<tr><th id="13">13</th><td></td></tr>
<tr><th id="14">14</th><td><i>/************************** DOCUMENTATION **************************/</i></td></tr>
<tr><th id="15">15</th><td><i>/*</i></td></tr>
<tr><th id="16">16</th><td><i> * Initial APIs (1996 -&gt; onward) :</i></td></tr>
<tr><th id="17">17</th><td><i> * -----------------------------</i></td></tr>
<tr><th id="18">18</th><td><i> * Basically, the wireless extensions are for now a set of standard ioctl</i></td></tr>
<tr><th id="19">19</th><td><i> * call + /proc/net/wireless</i></td></tr>
<tr><th id="20">20</th><td><i> *</i></td></tr>
<tr><th id="21">21</th><td><i> * The entry /proc/net/wireless give statistics and information on the</i></td></tr>
<tr><th id="22">22</th><td><i> * driver.</i></td></tr>
<tr><th id="23">23</th><td><i> * This is better than having each driver having its entry because</i></td></tr>
<tr><th id="24">24</th><td><i> * its centralised and we may remove the driver module safely.</i></td></tr>
<tr><th id="25">25</th><td><i> *</i></td></tr>
<tr><th id="26">26</th><td><i> * Ioctl are used to configure the driver and issue commands.  This is</i></td></tr>
<tr><th id="27">27</th><td><i> * better than command line options of insmod because we may want to</i></td></tr>
<tr><th id="28">28</th><td><i> * change dynamically (while the driver is running) some parameters.</i></td></tr>
<tr><th id="29">29</th><td><i> *</i></td></tr>
<tr><th id="30">30</th><td><i> * The ioctl mechanimsm are copied from standard devices ioctl.</i></td></tr>
<tr><th id="31">31</th><td><i> * We have the list of command plus a structure descibing the</i></td></tr>
<tr><th id="32">32</th><td><i> * data exchanged...</i></td></tr>
<tr><th id="33">33</th><td><i> * Note that to add these ioctl, I was obliged to modify :</i></td></tr>
<tr><th id="34">34</th><td><i> *	# net/core/dev.c (two place + add include)</i></td></tr>
<tr><th id="35">35</th><td><i> *	# net/ipv4/af_inet.c (one place + add include)</i></td></tr>
<tr><th id="36">36</th><td><i> *</i></td></tr>
<tr><th id="37">37</th><td><i> * /proc/net/wireless is a copy of /proc/net/dev.</i></td></tr>
<tr><th id="38">38</th><td><i> * We have a structure for data passed from the driver to /proc/net/wireless</i></td></tr>
<tr><th id="39">39</th><td><i> * Too add this, I've modified :</i></td></tr>
<tr><th id="40">40</th><td><i> *	# net/core/dev.c (two other places)</i></td></tr>
<tr><th id="41">41</th><td><i> *	# include/linux/netdevice.h (one place)</i></td></tr>
<tr><th id="42">42</th><td><i> *	# include/linux/proc_fs.h (one place)</i></td></tr>
<tr><th id="43">43</th><td><i> *</i></td></tr>
<tr><th id="44">44</th><td><i> * New driver API (2002 -&gt; onward) :</i></td></tr>
<tr><th id="45">45</th><td><i> * -------------------------------</i></td></tr>
<tr><th id="46">46</th><td><i> * This file is only concerned with the user space API and common definitions.</i></td></tr>
<tr><th id="47">47</th><td><i> * The new driver API is defined and documented in :</i></td></tr>
<tr><th id="48">48</th><td><i> *	# include/net/iw_handler.h</i></td></tr>
<tr><th id="49">49</th><td><i> *</i></td></tr>
<tr><th id="50">50</th><td><i> * Note as well that /proc/net/wireless implementation has now moved in :</i></td></tr>
<tr><th id="51">51</th><td><i> *	# net/core/wireless.c</i></td></tr>
<tr><th id="52">52</th><td><i> *</i></td></tr>
<tr><th id="53">53</th><td><i> * Wireless Events (2002 -&gt; onward) :</i></td></tr>
<tr><th id="54">54</th><td><i> * --------------------------------</i></td></tr>
<tr><th id="55">55</th><td><i> * Events are defined at the end of this file, and implemented in :</i></td></tr>
<tr><th id="56">56</th><td><i> *	# net/core/wireless.c</i></td></tr>
<tr><th id="57">57</th><td><i> *</i></td></tr>
<tr><th id="58">58</th><td><i> * Other comments :</i></td></tr>
<tr><th id="59">59</th><td><i> * --------------</i></td></tr>
<tr><th id="60">60</th><td><i> * Do not add here things that are redundant with other mechanisms</i></td></tr>
<tr><th id="61">61</th><td><i> * (drivers init, ifconfig, /proc/net/dev, ...) and with are not</i></td></tr>
<tr><th id="62">62</th><td><i> * wireless specific.</i></td></tr>
<tr><th id="63">63</th><td><i> *</i></td></tr>
<tr><th id="64">64</th><td><i> * These wireless extensions are not magic : each driver has to provide</i></td></tr>
<tr><th id="65">65</th><td><i> * support for them...</i></td></tr>
<tr><th id="66">66</th><td><i> *</i></td></tr>
<tr><th id="67">67</th><td><i> * IMPORTANT NOTE : As everything in the kernel, this is very much a</i></td></tr>
<tr><th id="68">68</th><td><i> * work in progress. Contact me if you have ideas of improvements...</i></td></tr>
<tr><th id="69">69</th><td><i> */</i></td></tr>
<tr><th id="70">70</th><td></td></tr>
<tr><th id="71">71</th><td><i>/***************************** INCLUDES *****************************/</i></td></tr>
<tr><th id="72">72</th><td></td></tr>
<tr><th id="73">73</th><td><u>#include <a href="types.h.html">&lt;linux/types.h&gt;</a>		/* for __u* and __s* typedefs */</u></td></tr>
<tr><th id="74">74</th><td><u>#include <a href="socket.h.html">&lt;linux/socket.h&gt;</a>		/* for "struct sockaddr" et al	*/</u></td></tr>
<tr><th id="75">75</th><td><u>#include <a href="if.h.html">&lt;linux/if.h&gt;</a>			/* for IFNAMSIZ and co... */</u></td></tr>
<tr><th id="76">76</th><td></td></tr>
<tr><th id="77">77</th><td><u>#	include &lt;stddef.h&gt;		/* for offsetof */</u></td></tr>
<tr><th id="78">78</th><td></td></tr>
<tr><th id="79">79</th><td><i>/***************************** VERSION *****************************/</i></td></tr>
<tr><th id="80">80</th><td><i>/*</i></td></tr>
<tr><th id="81">81</th><td><i> * This constant is used to know the availability of the wireless</i></td></tr>
<tr><th id="82">82</th><td><i> * extensions and to know which version of wireless extensions it is</i></td></tr>
<tr><th id="83">83</th><td><i> * (there is some stuff that will be added in the future...)</i></td></tr>
<tr><th id="84">84</th><td><i> * I just plan to increment with each new version.</i></td></tr>
<tr><th id="85">85</th><td><i> */</i></td></tr>
<tr><th id="86">86</th><td><u>#define <dfn class="macro" id="_M/WIRELESS_EXT" data-ref="_M/WIRELESS_EXT">WIRELESS_EXT</dfn>	22</u></td></tr>
<tr><th id="87">87</th><td></td></tr>
<tr><th id="88">88</th><td><i>/*</i></td></tr>
<tr><th id="89">89</th><td><i> * Changes :</i></td></tr>
<tr><th id="90">90</th><td><i> *</i></td></tr>
<tr><th id="91">91</th><td><i> * V2 to V3</i></td></tr>
<tr><th id="92">92</th><td><i> * --------</i></td></tr>
<tr><th id="93">93</th><td><i> *	Alan Cox start some incompatibles changes. I've integrated a bit more.</i></td></tr>
<tr><th id="94">94</th><td><i> *	- Encryption renamed to Encode to avoid US regulation problems</i></td></tr>
<tr><th id="95">95</th><td><i> *	- Frequency changed from float to struct to avoid problems on old 386</i></td></tr>
<tr><th id="96">96</th><td><i> *</i></td></tr>
<tr><th id="97">97</th><td><i> * V3 to V4</i></td></tr>
<tr><th id="98">98</th><td><i> * --------</i></td></tr>
<tr><th id="99">99</th><td><i> *	- Add sensitivity</i></td></tr>
<tr><th id="100">100</th><td><i> *</i></td></tr>
<tr><th id="101">101</th><td><i> * V4 to V5</i></td></tr>
<tr><th id="102">102</th><td><i> * --------</i></td></tr>
<tr><th id="103">103</th><td><i> *	- Missing encoding definitions in range</i></td></tr>
<tr><th id="104">104</th><td><i> *	- Access points stuff</i></td></tr>
<tr><th id="105">105</th><td><i> *</i></td></tr>
<tr><th id="106">106</th><td><i> * V5 to V6</i></td></tr>
<tr><th id="107">107</th><td><i> * --------</i></td></tr>
<tr><th id="108">108</th><td><i> *	- 802.11 support (ESSID ioctls)</i></td></tr>
<tr><th id="109">109</th><td><i> *</i></td></tr>
<tr><th id="110">110</th><td><i> * V6 to V7</i></td></tr>
<tr><th id="111">111</th><td><i> * --------</i></td></tr>
<tr><th id="112">112</th><td><i> *	- define IW_ESSID_MAX_SIZE and IW_MAX_AP</i></td></tr>
<tr><th id="113">113</th><td><i> *</i></td></tr>
<tr><th id="114">114</th><td><i> * V7 to V8</i></td></tr>
<tr><th id="115">115</th><td><i> * --------</i></td></tr>
<tr><th id="116">116</th><td><i> *	- Changed my e-mail address</i></td></tr>
<tr><th id="117">117</th><td><i> *	- More 802.11 support (nickname, rate, rts, frag)</i></td></tr>
<tr><th id="118">118</th><td><i> *	- List index in frequencies</i></td></tr>
<tr><th id="119">119</th><td><i> *</i></td></tr>
<tr><th id="120">120</th><td><i> * V8 to V9</i></td></tr>
<tr><th id="121">121</th><td><i> * --------</i></td></tr>
<tr><th id="122">122</th><td><i> *	- Support for 'mode of operation' (ad-hoc, managed...)</i></td></tr>
<tr><th id="123">123</th><td><i> *	- Support for unicast and multicast power saving</i></td></tr>
<tr><th id="124">124</th><td><i> *	- Change encoding to support larger tokens (&gt;64 bits)</i></td></tr>
<tr><th id="125">125</th><td><i> *	- Updated iw_params (disable, flags) and use it for NWID</i></td></tr>
<tr><th id="126">126</th><td><i> *	- Extracted iw_point from iwreq for clarity</i></td></tr>
<tr><th id="127">127</th><td><i> *</i></td></tr>
<tr><th id="128">128</th><td><i> * V9 to V10</i></td></tr>
<tr><th id="129">129</th><td><i> * ---------</i></td></tr>
<tr><th id="130">130</th><td><i> *	- Add PM capability to range structure</i></td></tr>
<tr><th id="131">131</th><td><i> *	- Add PM modifier : MAX/MIN/RELATIVE</i></td></tr>
<tr><th id="132">132</th><td><i> *	- Add encoding option : IW_ENCODE_NOKEY</i></td></tr>
<tr><th id="133">133</th><td><i> *	- Add TxPower ioctls (work like TxRate)</i></td></tr>
<tr><th id="134">134</th><td><i> *</i></td></tr>
<tr><th id="135">135</th><td><i> * V10 to V11</i></td></tr>
<tr><th id="136">136</th><td><i> * ----------</i></td></tr>
<tr><th id="137">137</th><td><i> *	- Add WE version in range (help backward/forward compatibility)</i></td></tr>
<tr><th id="138">138</th><td><i> *	- Add retry ioctls (work like PM)</i></td></tr>
<tr><th id="139">139</th><td><i> *</i></td></tr>
<tr><th id="140">140</th><td><i> * V11 to V12</i></td></tr>
<tr><th id="141">141</th><td><i> * ----------</i></td></tr>
<tr><th id="142">142</th><td><i> *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically</i></td></tr>
<tr><th id="143">143</th><td><i> *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space</i></td></tr>
<tr><th id="144">144</th><td><i> *	- Add new statistics (frag, retry, beacon)</i></td></tr>
<tr><th id="145">145</th><td><i> *	- Add average quality (for user space calibration)</i></td></tr>
<tr><th id="146">146</th><td><i> *</i></td></tr>
<tr><th id="147">147</th><td><i> * V12 to V13</i></td></tr>
<tr><th id="148">148</th><td><i> * ----------</i></td></tr>
<tr><th id="149">149</th><td><i> *	- Document creation of new driver API.</i></td></tr>
<tr><th id="150">150</th><td><i> *	- Extract union iwreq_data from struct iwreq (for new driver API).</i></td></tr>
<tr><th id="151">151</th><td><i> *	- Rename SIOCSIWNAME as SIOCSIWCOMMIT</i></td></tr>
<tr><th id="152">152</th><td><i> *</i></td></tr>
<tr><th id="153">153</th><td><i> * V13 to V14</i></td></tr>
<tr><th id="154">154</th><td><i> * ----------</i></td></tr>
<tr><th id="155">155</th><td><i> *	- Wireless Events support : define struct iw_event</i></td></tr>
<tr><th id="156">156</th><td><i> *	- Define additional specific event numbers</i></td></tr>
<tr><th id="157">157</th><td><i> *	- Add "addr" and "param" fields in union iwreq_data</i></td></tr>
<tr><th id="158">158</th><td><i> *	- AP scanning stuff (SIOCSIWSCAN and friends)</i></td></tr>
<tr><th id="159">159</th><td><i> *</i></td></tr>
<tr><th id="160">160</th><td><i> * V14 to V15</i></td></tr>
<tr><th id="161">161</th><td><i> * ----------</i></td></tr>
<tr><th id="162">162</th><td><i> *	- Add IW_PRIV_TYPE_ADDR for struct sockaddr private arg</i></td></tr>
<tr><th id="163">163</th><td><i> *	- Make struct iw_freq signed (both m &amp; e), add explicit padding</i></td></tr>
<tr><th id="164">164</th><td><i> *	- Add IWEVCUSTOM for driver specific event/scanning token</i></td></tr>
<tr><th id="165">165</th><td><i> *	- Add IW_MAX_GET_SPY for driver returning a lot of addresses</i></td></tr>
<tr><th id="166">166</th><td><i> *	- Add IW_TXPOW_RANGE for range of Tx Powers</i></td></tr>
<tr><th id="167">167</th><td><i> *	- Add IWEVREGISTERED &amp; IWEVEXPIRED events for Access Points</i></td></tr>
<tr><th id="168">168</th><td><i> *	- Add IW_MODE_MONITOR for passive monitor</i></td></tr>
<tr><th id="169">169</th><td><i> *</i></td></tr>
<tr><th id="170">170</th><td><i> * V15 to V16</i></td></tr>
<tr><th id="171">171</th><td><i> * ----------</i></td></tr>
<tr><th id="172">172</th><td><i> *	- Increase the number of bitrates in iw_range to 32 (for 802.11g)</i></td></tr>
<tr><th id="173">173</th><td><i> *	- Increase the number of frequencies in iw_range to 32 (for 802.11b+a)</i></td></tr>
<tr><th id="174">174</th><td><i> *	- Reshuffle struct iw_range for increases, add filler</i></td></tr>
<tr><th id="175">175</th><td><i> *	- Increase IW_MAX_AP to 64 for driver returning a lot of addresses</i></td></tr>
<tr><th id="176">176</th><td><i> *	- Remove IW_MAX_GET_SPY because conflict with enhanced spy support</i></td></tr>
<tr><th id="177">177</th><td><i> *	- Add SIOCSIWTHRSPY/SIOCGIWTHRSPY and "struct iw_thrspy"</i></td></tr>
<tr><th id="178">178</th><td><i> *	- Add IW_ENCODE_TEMP and iw_range-&gt;encoding_login_index</i></td></tr>
<tr><th id="179">179</th><td><i> *</i></td></tr>
<tr><th id="180">180</th><td><i> * V16 to V17</i></td></tr>
<tr><th id="181">181</th><td><i> * ----------</i></td></tr>
<tr><th id="182">182</th><td><i> *	- Add flags to frequency -&gt; auto/fixed</i></td></tr>
<tr><th id="183">183</th><td><i> *	- Document (struct iw_quality *)-&gt;updated, add new flags (INVALID)</i></td></tr>
<tr><th id="184">184</th><td><i> *	- Wireless Event capability in struct iw_range</i></td></tr>
<tr><th id="185">185</th><td><i> *	- Add support for relative TxPower (yick !)</i></td></tr>
<tr><th id="186">186</th><td><i> *</i></td></tr>
<tr><th id="187">187</th><td><i> * V17 to V18 (From Jouni Malinen &lt;j@w1.fi&gt;)</i></td></tr>
<tr><th id="188">188</th><td><i> * ----------</i></td></tr>
<tr><th id="189">189</th><td><i> *	- Add support for WPA/WPA2</i></td></tr>
<tr><th id="190">190</th><td><i> *	- Add extended encoding configuration (SIOCSIWENCODEEXT and</i></td></tr>
<tr><th id="191">191</th><td><i> *	  SIOCGIWENCODEEXT)</i></td></tr>
<tr><th id="192">192</th><td><i> *	- Add SIOCSIWGENIE/SIOCGIWGENIE</i></td></tr>
<tr><th id="193">193</th><td><i> *	- Add SIOCSIWMLME</i></td></tr>
<tr><th id="194">194</th><td><i> *	- Add SIOCSIWPMKSA</i></td></tr>
<tr><th id="195">195</th><td><i> *	- Add struct iw_range bit field for supported encoding capabilities</i></td></tr>
<tr><th id="196">196</th><td><i> *	- Add optional scan request parameters for SIOCSIWSCAN</i></td></tr>
<tr><th id="197">197</th><td><i> *	- Add SIOCSIWAUTH/SIOCGIWAUTH for setting authentication and WPA</i></td></tr>
<tr><th id="198">198</th><td><i> *	  related parameters (extensible up to 4096 parameter values)</i></td></tr>
<tr><th id="199">199</th><td><i> *	- Add wireless events: IWEVGENIE, IWEVMICHAELMICFAILURE,</i></td></tr>
<tr><th id="200">200</th><td><i> *	  IWEVASSOCREQIE, IWEVASSOCRESPIE, IWEVPMKIDCAND</i></td></tr>
<tr><th id="201">201</th><td><i> *</i></td></tr>
<tr><th id="202">202</th><td><i> * V18 to V19</i></td></tr>
<tr><th id="203">203</th><td><i> * ----------</i></td></tr>
<tr><th id="204">204</th><td><i> *	- Remove (struct iw_point *)-&gt;pointer from events and streams</i></td></tr>
<tr><th id="205">205</th><td><i> *	- Remove header includes to help user space</i></td></tr>
<tr><th id="206">206</th><td><i> *	- Increase IW_ENCODING_TOKEN_MAX from 32 to 64</i></td></tr>
<tr><th id="207">207</th><td><i> *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros</i></td></tr>
<tr><th id="208">208</th><td><i> *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM</i></td></tr>
<tr><th id="209">209</th><td><i> *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros</i></td></tr>
<tr><th id="210">210</th><td><i> *</i></td></tr>
<tr><th id="211">211</th><td><i> * V19 to V20</i></td></tr>
<tr><th id="212">212</th><td><i> * ----------</i></td></tr>
<tr><th id="213">213</th><td><i> *	- RtNetlink requests support (SET/GET)</i></td></tr>
<tr><th id="214">214</th><td><i> *</i></td></tr>
<tr><th id="215">215</th><td><i> * V20 to V21</i></td></tr>
<tr><th id="216">216</th><td><i> * ----------</i></td></tr>
<tr><th id="217">217</th><td><i> *	- Remove (struct net_device *)-&gt;get_wireless_stats()</i></td></tr>
<tr><th id="218">218</th><td><i> *	- Change length in ESSID and NICK to strlen() instead of strlen()+1</i></td></tr>
<tr><th id="219">219</th><td><i> *	- Add IW_RETRY_SHORT/IW_RETRY_LONG retry modifiers</i></td></tr>
<tr><th id="220">220</th><td><i> *	- Power/Retry relative values no longer * 100000</i></td></tr>
<tr><th id="221">221</th><td><i> *	- Add explicit flag to tell stats are in 802.11k RCPI : IW_QUAL_RCPI</i></td></tr>
<tr><th id="222">222</th><td><i> *</i></td></tr>
<tr><th id="223">223</th><td><i> * V21 to V22</i></td></tr>
<tr><th id="224">224</th><td><i> * ----------</i></td></tr>
<tr><th id="225">225</th><td><i> *	- Prevent leaking of kernel space in stream on 64 bits.</i></td></tr>
<tr><th id="226">226</th><td><i> */</i></td></tr>
<tr><th id="227">227</th><td></td></tr>
<tr><th id="228">228</th><td><i>/**************************** CONSTANTS ****************************/</i></td></tr>
<tr><th id="229">229</th><td></td></tr>
<tr><th id="230">230</th><td><i>/* -------------------------- IOCTL LIST -------------------------- */</i></td></tr>
<tr><th id="231">231</th><td></td></tr>
<tr><th id="232">232</th><td><i>/* Wireless Identification */</i></td></tr>
<tr><th id="233">233</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWCOMMIT" data-ref="_M/SIOCSIWCOMMIT">SIOCSIWCOMMIT</dfn>	0x8B00		/* Commit pending changes to driver */</u></td></tr>
<tr><th id="234">234</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWNAME" data-ref="_M/SIOCGIWNAME">SIOCGIWNAME</dfn>	0x8B01		/* get name == wireless protocol */</u></td></tr>
<tr><th id="235">235</th><td><i>/* SIOCGIWNAME is used to verify the presence of Wireless Extensions.</i></td></tr>
<tr><th id="236">236</th><td><i> * Common values : "IEEE 802.11-DS", "IEEE 802.11-FH", "IEEE 802.11b"...</i></td></tr>
<tr><th id="237">237</th><td><i> * Don't put the name of your driver there, it's useless. */</i></td></tr>
<tr><th id="238">238</th><td></td></tr>
<tr><th id="239">239</th><td><i>/* Basic operations */</i></td></tr>
<tr><th id="240">240</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWNWID" data-ref="_M/SIOCSIWNWID">SIOCSIWNWID</dfn>	0x8B02		/* set network id (pre-802.11) */</u></td></tr>
<tr><th id="241">241</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWNWID" data-ref="_M/SIOCGIWNWID">SIOCGIWNWID</dfn>	0x8B03		/* get network id (the cell) */</u></td></tr>
<tr><th id="242">242</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWFREQ" data-ref="_M/SIOCSIWFREQ">SIOCSIWFREQ</dfn>	0x8B04		/* set channel/frequency (Hz) */</u></td></tr>
<tr><th id="243">243</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWFREQ" data-ref="_M/SIOCGIWFREQ">SIOCGIWFREQ</dfn>	0x8B05		/* get channel/frequency (Hz) */</u></td></tr>
<tr><th id="244">244</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWMODE" data-ref="_M/SIOCSIWMODE">SIOCSIWMODE</dfn>	0x8B06		/* set operation mode */</u></td></tr>
<tr><th id="245">245</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWMODE" data-ref="_M/SIOCGIWMODE">SIOCGIWMODE</dfn>	0x8B07		/* get operation mode */</u></td></tr>
<tr><th id="246">246</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWSENS" data-ref="_M/SIOCSIWSENS">SIOCSIWSENS</dfn>	0x8B08		/* set sensitivity (dBm) */</u></td></tr>
<tr><th id="247">247</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWSENS" data-ref="_M/SIOCGIWSENS">SIOCGIWSENS</dfn>	0x8B09		/* get sensitivity (dBm) */</u></td></tr>
<tr><th id="248">248</th><td></td></tr>
<tr><th id="249">249</th><td><i>/* Informative stuff */</i></td></tr>
<tr><th id="250">250</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWRANGE" data-ref="_M/SIOCSIWRANGE">SIOCSIWRANGE</dfn>	0x8B0A		/* Unused */</u></td></tr>
<tr><th id="251">251</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWRANGE" data-ref="_M/SIOCGIWRANGE">SIOCGIWRANGE</dfn>	0x8B0B		/* Get range of parameters */</u></td></tr>
<tr><th id="252">252</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWPRIV" data-ref="_M/SIOCSIWPRIV">SIOCSIWPRIV</dfn>	0x8B0C		/* Unused */</u></td></tr>
<tr><th id="253">253</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWPRIV" data-ref="_M/SIOCGIWPRIV">SIOCGIWPRIV</dfn>	0x8B0D		/* get private ioctl interface info */</u></td></tr>
<tr><th id="254">254</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWSTATS" data-ref="_M/SIOCSIWSTATS">SIOCSIWSTATS</dfn>	0x8B0E		/* Unused */</u></td></tr>
<tr><th id="255">255</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWSTATS" data-ref="_M/SIOCGIWSTATS">SIOCGIWSTATS</dfn>	0x8B0F		/* Get /proc/net/wireless stats */</u></td></tr>
<tr><th id="256">256</th><td><i>/* SIOCGIWSTATS is strictly used between user space and the kernel, and</i></td></tr>
<tr><th id="257">257</th><td><i> * is never passed to the driver (i.e. the driver will never see it). */</i></td></tr>
<tr><th id="258">258</th><td></td></tr>
<tr><th id="259">259</th><td><i>/* Spy support (statistics per MAC address - used for Mobile IP support) */</i></td></tr>
<tr><th id="260">260</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWSPY" data-ref="_M/SIOCSIWSPY">SIOCSIWSPY</dfn>	0x8B10		/* set spy addresses */</u></td></tr>
<tr><th id="261">261</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWSPY" data-ref="_M/SIOCGIWSPY">SIOCGIWSPY</dfn>	0x8B11		/* get spy info (quality of link) */</u></td></tr>
<tr><th id="262">262</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWTHRSPY" data-ref="_M/SIOCSIWTHRSPY">SIOCSIWTHRSPY</dfn>	0x8B12		/* set spy threshold (spy event) */</u></td></tr>
<tr><th id="263">263</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWTHRSPY" data-ref="_M/SIOCGIWTHRSPY">SIOCGIWTHRSPY</dfn>	0x8B13		/* get spy threshold */</u></td></tr>
<tr><th id="264">264</th><td></td></tr>
<tr><th id="265">265</th><td><i>/* Access Point manipulation */</i></td></tr>
<tr><th id="266">266</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWAP" data-ref="_M/SIOCSIWAP">SIOCSIWAP</dfn>	0x8B14		/* set access point MAC addresses */</u></td></tr>
<tr><th id="267">267</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWAP" data-ref="_M/SIOCGIWAP">SIOCGIWAP</dfn>	0x8B15		/* get access point MAC addresses */</u></td></tr>
<tr><th id="268">268</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWAPLIST" data-ref="_M/SIOCGIWAPLIST">SIOCGIWAPLIST</dfn>	0x8B17		/* Deprecated in favor of scanning */</u></td></tr>
<tr><th id="269">269</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWSCAN" data-ref="_M/SIOCSIWSCAN">SIOCSIWSCAN</dfn>	0x8B18		/* trigger scanning (list cells) */</u></td></tr>
<tr><th id="270">270</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWSCAN" data-ref="_M/SIOCGIWSCAN">SIOCGIWSCAN</dfn>	0x8B19		/* get scanning results */</u></td></tr>
<tr><th id="271">271</th><td></td></tr>
<tr><th id="272">272</th><td><i>/* 802.11 specific support */</i></td></tr>
<tr><th id="273">273</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWESSID" data-ref="_M/SIOCSIWESSID">SIOCSIWESSID</dfn>	0x8B1A		/* set ESSID (network name) */</u></td></tr>
<tr><th id="274">274</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWESSID" data-ref="_M/SIOCGIWESSID">SIOCGIWESSID</dfn>	0x8B1B		/* get ESSID */</u></td></tr>
<tr><th id="275">275</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWNICKN" data-ref="_M/SIOCSIWNICKN">SIOCSIWNICKN</dfn>	0x8B1C		/* set node name/nickname */</u></td></tr>
<tr><th id="276">276</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWNICKN" data-ref="_M/SIOCGIWNICKN">SIOCGIWNICKN</dfn>	0x8B1D		/* get node name/nickname */</u></td></tr>
<tr><th id="277">277</th><td><i>/* As the ESSID and NICKN are strings up to 32 bytes long, it doesn't fit</i></td></tr>
<tr><th id="278">278</th><td><i> * within the 'iwreq' structure, so we need to use the 'data' member to</i></td></tr>
<tr><th id="279">279</th><td><i> * point to a string in user space, like it is done for RANGE... */</i></td></tr>
<tr><th id="280">280</th><td></td></tr>
<tr><th id="281">281</th><td><i>/* Other parameters useful in 802.11 and some other devices */</i></td></tr>
<tr><th id="282">282</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWRATE" data-ref="_M/SIOCSIWRATE">SIOCSIWRATE</dfn>	0x8B20		/* set default bit rate (bps) */</u></td></tr>
<tr><th id="283">283</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWRATE" data-ref="_M/SIOCGIWRATE">SIOCGIWRATE</dfn>	0x8B21		/* get default bit rate (bps) */</u></td></tr>
<tr><th id="284">284</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWRTS" data-ref="_M/SIOCSIWRTS">SIOCSIWRTS</dfn>	0x8B22		/* set RTS/CTS threshold (bytes) */</u></td></tr>
<tr><th id="285">285</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWRTS" data-ref="_M/SIOCGIWRTS">SIOCGIWRTS</dfn>	0x8B23		/* get RTS/CTS threshold (bytes) */</u></td></tr>
<tr><th id="286">286</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWFRAG" data-ref="_M/SIOCSIWFRAG">SIOCSIWFRAG</dfn>	0x8B24		/* set fragmentation thr (bytes) */</u></td></tr>
<tr><th id="287">287</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWFRAG" data-ref="_M/SIOCGIWFRAG">SIOCGIWFRAG</dfn>	0x8B25		/* get fragmentation thr (bytes) */</u></td></tr>
<tr><th id="288">288</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWTXPOW" data-ref="_M/SIOCSIWTXPOW">SIOCSIWTXPOW</dfn>	0x8B26		/* set transmit power (dBm) */</u></td></tr>
<tr><th id="289">289</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWTXPOW" data-ref="_M/SIOCGIWTXPOW">SIOCGIWTXPOW</dfn>	0x8B27		/* get transmit power (dBm) */</u></td></tr>
<tr><th id="290">290</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWRETRY" data-ref="_M/SIOCSIWRETRY">SIOCSIWRETRY</dfn>	0x8B28		/* set retry limits and lifetime */</u></td></tr>
<tr><th id="291">291</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWRETRY" data-ref="_M/SIOCGIWRETRY">SIOCGIWRETRY</dfn>	0x8B29		/* get retry limits and lifetime */</u></td></tr>
<tr><th id="292">292</th><td></td></tr>
<tr><th id="293">293</th><td><i>/* Encoding stuff (scrambling, hardware security, WEP...) */</i></td></tr>
<tr><th id="294">294</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWENCODE" data-ref="_M/SIOCSIWENCODE">SIOCSIWENCODE</dfn>	0x8B2A		/* set encoding token &amp; mode */</u></td></tr>
<tr><th id="295">295</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWENCODE" data-ref="_M/SIOCGIWENCODE">SIOCGIWENCODE</dfn>	0x8B2B		/* get encoding token &amp; mode */</u></td></tr>
<tr><th id="296">296</th><td><i>/* Power saving stuff (power management, unicast and multicast) */</i></td></tr>
<tr><th id="297">297</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWPOWER" data-ref="_M/SIOCSIWPOWER">SIOCSIWPOWER</dfn>	0x8B2C		/* set Power Management settings */</u></td></tr>
<tr><th id="298">298</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWPOWER" data-ref="_M/SIOCGIWPOWER">SIOCGIWPOWER</dfn>	0x8B2D		/* get Power Management settings */</u></td></tr>
<tr><th id="299">299</th><td></td></tr>
<tr><th id="300">300</th><td><i>/* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).</i></td></tr>
<tr><th id="301">301</th><td><i> * This ioctl uses struct iw_point and data buffer that includes IE id and len</i></td></tr>
<tr><th id="302">302</th><td><i> * fields. More than one IE may be included in the request. Setting the generic</i></td></tr>
<tr><th id="303">303</th><td><i> * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers</i></td></tr>
<tr><th id="304">304</th><td><i> * are allowed to generate their own WPA/RSN IEs, but in these cases, drivers</i></td></tr>
<tr><th id="305">305</th><td><i> * are required to report the used IE as a wireless event, e.g., when</i></td></tr>
<tr><th id="306">306</th><td><i> * associating with an AP. */</i></td></tr>
<tr><th id="307">307</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWGENIE" data-ref="_M/SIOCSIWGENIE">SIOCSIWGENIE</dfn>	0x8B30		/* set generic IE */</u></td></tr>
<tr><th id="308">308</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWGENIE" data-ref="_M/SIOCGIWGENIE">SIOCGIWGENIE</dfn>	0x8B31		/* get generic IE */</u></td></tr>
<tr><th id="309">309</th><td></td></tr>
<tr><th id="310">310</th><td><i>/* WPA : IEEE 802.11 MLME requests */</i></td></tr>
<tr><th id="311">311</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWMLME" data-ref="_M/SIOCSIWMLME">SIOCSIWMLME</dfn>	0x8B16		/* request MLME operation; uses</u></td></tr>
<tr><th id="312">312</th><td><u>					 * struct iw_mlme */</u></td></tr>
<tr><th id="313">313</th><td><i>/* WPA : Authentication mode parameters */</i></td></tr>
<tr><th id="314">314</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWAUTH" data-ref="_M/SIOCSIWAUTH">SIOCSIWAUTH</dfn>	0x8B32		/* set authentication mode params */</u></td></tr>
<tr><th id="315">315</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWAUTH" data-ref="_M/SIOCGIWAUTH">SIOCGIWAUTH</dfn>	0x8B33		/* get authentication mode params */</u></td></tr>
<tr><th id="316">316</th><td></td></tr>
<tr><th id="317">317</th><td><i>/* WPA : Extended version of encoding configuration */</i></td></tr>
<tr><th id="318">318</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWENCODEEXT" data-ref="_M/SIOCSIWENCODEEXT">SIOCSIWENCODEEXT</dfn> 0x8B34		/* set encoding token &amp; mode */</u></td></tr>
<tr><th id="319">319</th><td><u>#define <dfn class="macro" id="_M/SIOCGIWENCODEEXT" data-ref="_M/SIOCGIWENCODEEXT">SIOCGIWENCODEEXT</dfn> 0x8B35		/* get encoding token &amp; mode */</u></td></tr>
<tr><th id="320">320</th><td></td></tr>
<tr><th id="321">321</th><td><i>/* WPA2 : PMKSA cache management */</i></td></tr>
<tr><th id="322">322</th><td><u>#define <dfn class="macro" id="_M/SIOCSIWPMKSA" data-ref="_M/SIOCSIWPMKSA">SIOCSIWPMKSA</dfn>	0x8B36		/* PMKSA cache operation */</u></td></tr>
<tr><th id="323">323</th><td></td></tr>
<tr><th id="324">324</th><td><i>/* -------------------- DEV PRIVATE IOCTL LIST -------------------- */</i></td></tr>
<tr><th id="325">325</th><td></td></tr>
<tr><th id="326">326</th><td><i>/* These 32 ioctl are wireless device private, for 16 commands.</i></td></tr>
<tr><th id="327">327</th><td><i> * Each driver is free to use them for whatever purpose it chooses,</i></td></tr>
<tr><th id="328">328</th><td><i> * however the driver *must* export the description of those ioctls</i></td></tr>
<tr><th id="329">329</th><td><i> * with SIOCGIWPRIV and *must* use arguments as defined below.</i></td></tr>
<tr><th id="330">330</th><td><i> * If you don't follow those rules, DaveM is going to hate you (reason :</i></td></tr>
<tr><th id="331">331</th><td><i> * it make mixed 32/64bit operation impossible).</i></td></tr>
<tr><th id="332">332</th><td><i> */</i></td></tr>
<tr><th id="333">333</th><td><u>#define <dfn class="macro" id="_M/SIOCIWFIRSTPRIV" data-ref="_M/SIOCIWFIRSTPRIV">SIOCIWFIRSTPRIV</dfn>	0x8BE0</u></td></tr>
<tr><th id="334">334</th><td><u>#define <dfn class="macro" id="_M/SIOCIWLASTPRIV" data-ref="_M/SIOCIWLASTPRIV">SIOCIWLASTPRIV</dfn>	0x8BFF</u></td></tr>
<tr><th id="335">335</th><td><i>/* Previously, we were using SIOCDEVPRIVATE, but we now have our</i></td></tr>
<tr><th id="336">336</th><td><i> * separate range because of collisions with other tools such as</i></td></tr>
<tr><th id="337">337</th><td><i> * 'mii-tool'.</i></td></tr>
<tr><th id="338">338</th><td><i> * We now have 32 commands, so a bit more space ;-).</i></td></tr>
<tr><th id="339">339</th><td><i> * Also, all 'even' commands are only usable by root and don't return the</i></td></tr>
<tr><th id="340">340</th><td><i> * content of ifr/iwr to user (but you are not obliged to use the set/get</i></td></tr>
<tr><th id="341">341</th><td><i> * convention, just use every other two command). More details in iwpriv.c.</i></td></tr>
<tr><th id="342">342</th><td><i> * And I repeat : you are not forced to use them with iwpriv, but you</i></td></tr>
<tr><th id="343">343</th><td><i> * must be compliant with it.</i></td></tr>
<tr><th id="344">344</th><td><i> */</i></td></tr>
<tr><th id="345">345</th><td></td></tr>
<tr><th id="346">346</th><td><i>/* ------------------------- IOCTL STUFF ------------------------- */</i></td></tr>
<tr><th id="347">347</th><td></td></tr>
<tr><th id="348">348</th><td><i>/* The first and the last (range) */</i></td></tr>
<tr><th id="349">349</th><td><u>#define <dfn class="macro" id="_M/SIOCIWFIRST" data-ref="_M/SIOCIWFIRST">SIOCIWFIRST</dfn>	0x8B00</u></td></tr>
<tr><th id="350">350</th><td><u>#define <dfn class="macro" id="_M/SIOCIWLAST" data-ref="_M/SIOCIWLAST">SIOCIWLAST</dfn>	SIOCIWLASTPRIV		/* 0x8BFF */</u></td></tr>
<tr><th id="351">351</th><td><u>#define <dfn class="macro" id="_M/IW_IOCTL_IDX" data-ref="_M/IW_IOCTL_IDX">IW_IOCTL_IDX</dfn>(cmd)	((cmd) - SIOCIWFIRST)</u></td></tr>
<tr><th id="352">352</th><td><u>#define <dfn class="macro" id="_M/IW_HANDLER" data-ref="_M/IW_HANDLER">IW_HANDLER</dfn>(id, func)			\</u></td></tr>
<tr><th id="353">353</th><td><u>	[IW_IOCTL_IDX(id)] = func</u></td></tr>
<tr><th id="354">354</th><td></td></tr>
<tr><th id="355">355</th><td><i>/* Odd : get (world access), even : set (root access) */</i></td></tr>
<tr><th id="356">356</th><td><u>#define <dfn class="macro" id="_M/IW_IS_SET" data-ref="_M/IW_IS_SET">IW_IS_SET</dfn>(cmd)	(!((cmd) &amp; 0x1))</u></td></tr>
<tr><th id="357">357</th><td><u>#define <dfn class="macro" id="_M/IW_IS_GET" data-ref="_M/IW_IS_GET">IW_IS_GET</dfn>(cmd)	((cmd) &amp; 0x1)</u></td></tr>
<tr><th id="358">358</th><td></td></tr>
<tr><th id="359">359</th><td><i>/* ----------------------- WIRELESS EVENTS ----------------------- */</i></td></tr>
<tr><th id="360">360</th><td><i>/* Those are *NOT* ioctls, do not issue request on them !!! */</i></td></tr>
<tr><th id="361">361</th><td><i>/* Most events use the same identifier as ioctl requests */</i></td></tr>
<tr><th id="362">362</th><td></td></tr>
<tr><th id="363">363</th><td><u>#define <dfn class="macro" id="_M/IWEVTXDROP" data-ref="_M/IWEVTXDROP">IWEVTXDROP</dfn>	0x8C00		/* Packet dropped to excessive retry */</u></td></tr>
<tr><th id="364">364</th><td><u>#define <dfn class="macro" id="_M/IWEVQUAL" data-ref="_M/IWEVQUAL">IWEVQUAL</dfn>	0x8C01		/* Quality part of statistics (scan) */</u></td></tr>
<tr><th id="365">365</th><td><u>#define <dfn class="macro" id="_M/IWEVCUSTOM" data-ref="_M/IWEVCUSTOM">IWEVCUSTOM</dfn>	0x8C02		/* Driver specific ascii string */</u></td></tr>
<tr><th id="366">366</th><td><u>#define <dfn class="macro" id="_M/IWEVREGISTERED" data-ref="_M/IWEVREGISTERED">IWEVREGISTERED</dfn>	0x8C03		/* Discovered a new node (AP mode) */</u></td></tr>
<tr><th id="367">367</th><td><u>#define <dfn class="macro" id="_M/IWEVEXPIRED" data-ref="_M/IWEVEXPIRED">IWEVEXPIRED</dfn>	0x8C04		/* Expired a node (AP mode) */</u></td></tr>
<tr><th id="368">368</th><td><u>#define <dfn class="macro" id="_M/IWEVGENIE" data-ref="_M/IWEVGENIE">IWEVGENIE</dfn>	0x8C05		/* Generic IE (WPA, RSN, WMM, ..)</u></td></tr>
<tr><th id="369">369</th><td><u>					 * (scan results); This includes id and</u></td></tr>
<tr><th id="370">370</th><td><u>					 * length fields. One IWEVGENIE may</u></td></tr>
<tr><th id="371">371</th><td><u>					 * contain more than one IE. Scan</u></td></tr>
<tr><th id="372">372</th><td><u>					 * results may contain one or more</u></td></tr>
<tr><th id="373">373</th><td><u>					 * IWEVGENIE events. */</u></td></tr>
<tr><th id="374">374</th><td><u>#define <dfn class="macro" id="_M/IWEVMICHAELMICFAILURE" data-ref="_M/IWEVMICHAELMICFAILURE">IWEVMICHAELMICFAILURE</dfn> 0x8C06	/* Michael MIC failure</u></td></tr>
<tr><th id="375">375</th><td><u>					 * (struct iw_michaelmicfailure)</u></td></tr>
<tr><th id="376">376</th><td><u>					 */</u></td></tr>
<tr><th id="377">377</th><td><u>#define <dfn class="macro" id="_M/IWEVASSOCREQIE" data-ref="_M/IWEVASSOCREQIE">IWEVASSOCREQIE</dfn>	0x8C07		/* IEs used in (Re)Association Request.</u></td></tr>
<tr><th id="378">378</th><td><u>					 * The data includes id and length</u></td></tr>
<tr><th id="379">379</th><td><u>					 * fields and may contain more than one</u></td></tr>
<tr><th id="380">380</th><td><u>					 * IE. This event is required in</u></td></tr>
<tr><th id="381">381</th><td><u>					 * Managed mode if the driver</u></td></tr>
<tr><th id="382">382</th><td><u>					 * generates its own WPA/RSN IE. This</u></td></tr>
<tr><th id="383">383</th><td><u>					 * should be sent just before</u></td></tr>
<tr><th id="384">384</th><td><u>					 * IWEVREGISTERED event for the</u></td></tr>
<tr><th id="385">385</th><td><u>					 * association. */</u></td></tr>
<tr><th id="386">386</th><td><u>#define <dfn class="macro" id="_M/IWEVASSOCRESPIE" data-ref="_M/IWEVASSOCRESPIE">IWEVASSOCRESPIE</dfn>	0x8C08		/* IEs used in (Re)Association</u></td></tr>
<tr><th id="387">387</th><td><u>					 * Response. The data includes id and</u></td></tr>
<tr><th id="388">388</th><td><u>					 * length fields and may contain more</u></td></tr>
<tr><th id="389">389</th><td><u>					 * than one IE. This may be sent</u></td></tr>
<tr><th id="390">390</th><td><u>					 * between IWEVASSOCREQIE and</u></td></tr>
<tr><th id="391">391</th><td><u>					 * IWEVREGISTERED events for the</u></td></tr>
<tr><th id="392">392</th><td><u>					 * association. */</u></td></tr>
<tr><th id="393">393</th><td><u>#define <dfn class="macro" id="_M/IWEVPMKIDCAND" data-ref="_M/IWEVPMKIDCAND">IWEVPMKIDCAND</dfn>	0x8C09		/* PMKID candidate for RSN</u></td></tr>
<tr><th id="394">394</th><td><u>					 * pre-authentication</u></td></tr>
<tr><th id="395">395</th><td><u>					 * (struct iw_pmkid_cand) */</u></td></tr>
<tr><th id="396">396</th><td></td></tr>
<tr><th id="397">397</th><td><u>#define <dfn class="macro" id="_M/IWEVFIRST" data-ref="_M/IWEVFIRST">IWEVFIRST</dfn>	0x8C00</u></td></tr>
<tr><th id="398">398</th><td><u>#define <dfn class="macro" id="_M/IW_EVENT_IDX" data-ref="_M/IW_EVENT_IDX">IW_EVENT_IDX</dfn>(cmd)	((cmd) - IWEVFIRST)</u></td></tr>
<tr><th id="399">399</th><td></td></tr>
<tr><th id="400">400</th><td><i>/* ------------------------- PRIVATE INFO ------------------------- */</i></td></tr>
<tr><th id="401">401</th><td><i>/*</i></td></tr>
<tr><th id="402">402</th><td><i> * The following is used with SIOCGIWPRIV. It allow a driver to define</i></td></tr>
<tr><th id="403">403</th><td><i> * the interface (name, type of data) for its private ioctl.</i></td></tr>
<tr><th id="404">404</th><td><i> * Privates ioctl are SIOCIWFIRSTPRIV -&gt; SIOCIWLASTPRIV</i></td></tr>
<tr><th id="405">405</th><td><i> */</i></td></tr>
<tr><th id="406">406</th><td></td></tr>
<tr><th id="407">407</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_TYPE_MASK" data-ref="_M/IW_PRIV_TYPE_MASK">IW_PRIV_TYPE_MASK</dfn>	0x7000	/* Type of arguments */</u></td></tr>
<tr><th id="408">408</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_TYPE_NONE" data-ref="_M/IW_PRIV_TYPE_NONE">IW_PRIV_TYPE_NONE</dfn>	0x0000</u></td></tr>
<tr><th id="409">409</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_TYPE_BYTE" data-ref="_M/IW_PRIV_TYPE_BYTE">IW_PRIV_TYPE_BYTE</dfn>	0x1000	/* Char as number */</u></td></tr>
<tr><th id="410">410</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_TYPE_CHAR" data-ref="_M/IW_PRIV_TYPE_CHAR">IW_PRIV_TYPE_CHAR</dfn>	0x2000	/* Char as character */</u></td></tr>
<tr><th id="411">411</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_TYPE_INT" data-ref="_M/IW_PRIV_TYPE_INT">IW_PRIV_TYPE_INT</dfn>	0x4000	/* 32 bits int */</u></td></tr>
<tr><th id="412">412</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_TYPE_FLOAT" data-ref="_M/IW_PRIV_TYPE_FLOAT">IW_PRIV_TYPE_FLOAT</dfn>	0x5000	/* struct iw_freq */</u></td></tr>
<tr><th id="413">413</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_TYPE_ADDR" data-ref="_M/IW_PRIV_TYPE_ADDR">IW_PRIV_TYPE_ADDR</dfn>	0x6000	/* struct sockaddr */</u></td></tr>
<tr><th id="414">414</th><td></td></tr>
<tr><th id="415">415</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_SIZE_FIXED" data-ref="_M/IW_PRIV_SIZE_FIXED">IW_PRIV_SIZE_FIXED</dfn>	0x0800	/* Variable or fixed number of args */</u></td></tr>
<tr><th id="416">416</th><td></td></tr>
<tr><th id="417">417</th><td><u>#define <dfn class="macro" id="_M/IW_PRIV_SIZE_MASK" data-ref="_M/IW_PRIV_SIZE_MASK">IW_PRIV_SIZE_MASK</dfn>	0x07FF	/* Max number of those args */</u></td></tr>
<tr><th id="418">418</th><td></td></tr>
<tr><th id="419">419</th><td><i>/*</i></td></tr>
<tr><th id="420">420</th><td><i> * Note : if the number of args is fixed and the size &lt; 16 octets,</i></td></tr>
<tr><th id="421">421</th><td><i> * instead of passing a pointer we will put args in the iwreq struct...</i></td></tr>
<tr><th id="422">422</th><td><i> */</i></td></tr>
<tr><th id="423">423</th><td></td></tr>
<tr><th id="424">424</th><td><i>/* ----------------------- OTHER CONSTANTS ----------------------- */</i></td></tr>
<tr><th id="425">425</th><td></td></tr>
<tr><th id="426">426</th><td><i>/* Maximum frequencies in the range struct */</i></td></tr>
<tr><th id="427">427</th><td><u>#define <dfn class="macro" id="_M/IW_MAX_FREQUENCIES" data-ref="_M/IW_MAX_FREQUENCIES">IW_MAX_FREQUENCIES</dfn>	32</u></td></tr>
<tr><th id="428">428</th><td><i>/* Note : if you have something like 80 frequencies,</i></td></tr>
<tr><th id="429">429</th><td><i> * don't increase this constant and don't fill the frequency list.</i></td></tr>
<tr><th id="430">430</th><td><i> * The user will be able to set by channel anyway... */</i></td></tr>
<tr><th id="431">431</th><td></td></tr>
<tr><th id="432">432</th><td><i>/* Maximum bit rates in the range struct */</i></td></tr>
<tr><th id="433">433</th><td><u>#define <dfn class="macro" id="_M/IW_MAX_BITRATES" data-ref="_M/IW_MAX_BITRATES">IW_MAX_BITRATES</dfn>		32</u></td></tr>
<tr><th id="434">434</th><td></td></tr>
<tr><th id="435">435</th><td><i>/* Maximum tx powers in the range struct */</i></td></tr>
<tr><th id="436">436</th><td><u>#define <dfn class="macro" id="_M/IW_MAX_TXPOWER" data-ref="_M/IW_MAX_TXPOWER">IW_MAX_TXPOWER</dfn>		8</u></td></tr>
<tr><th id="437">437</th><td><i>/* Note : if you more than 8 TXPowers, just set the max and min or</i></td></tr>
<tr><th id="438">438</th><td><i> * a few of them in the struct iw_range. */</i></td></tr>
<tr><th id="439">439</th><td></td></tr>
<tr><th id="440">440</th><td><i>/* Maximum of address that you may set with SPY */</i></td></tr>
<tr><th id="441">441</th><td><u>#define <dfn class="macro" id="_M/IW_MAX_SPY" data-ref="_M/IW_MAX_SPY">IW_MAX_SPY</dfn>		8</u></td></tr>
<tr><th id="442">442</th><td></td></tr>
<tr><th id="443">443</th><td><i>/* Maximum of address that you may get in the</i></td></tr>
<tr><th id="444">444</th><td><i>   list of access points in range */</i></td></tr>
<tr><th id="445">445</th><td><u>#define <dfn class="macro" id="_M/IW_MAX_AP" data-ref="_M/IW_MAX_AP">IW_MAX_AP</dfn>		64</u></td></tr>
<tr><th id="446">446</th><td></td></tr>
<tr><th id="447">447</th><td><i>/* Maximum size of the ESSID and NICKN strings */</i></td></tr>
<tr><th id="448">448</th><td><u>#define <dfn class="macro" id="_M/IW_ESSID_MAX_SIZE" data-ref="_M/IW_ESSID_MAX_SIZE">IW_ESSID_MAX_SIZE</dfn>	32</u></td></tr>
<tr><th id="449">449</th><td></td></tr>
<tr><th id="450">450</th><td><i>/* Modes of operation */</i></td></tr>
<tr><th id="451">451</th><td><u>#define <dfn class="macro" id="_M/IW_MODE_AUTO" data-ref="_M/IW_MODE_AUTO">IW_MODE_AUTO</dfn>	0	/* Let the driver decides */</u></td></tr>
<tr><th id="452">452</th><td><u>#define <dfn class="macro" id="_M/IW_MODE_ADHOC" data-ref="_M/IW_MODE_ADHOC">IW_MODE_ADHOC</dfn>	1	/* Single cell network */</u></td></tr>
<tr><th id="453">453</th><td><u>#define <dfn class="macro" id="_M/IW_MODE_INFRA" data-ref="_M/IW_MODE_INFRA">IW_MODE_INFRA</dfn>	2	/* Multi cell network, roaming, ... */</u></td></tr>
<tr><th id="454">454</th><td><u>#define <dfn class="macro" id="_M/IW_MODE_MASTER" data-ref="_M/IW_MODE_MASTER">IW_MODE_MASTER</dfn>	3	/* Synchronisation master or Access Point */</u></td></tr>
<tr><th id="455">455</th><td><u>#define <dfn class="macro" id="_M/IW_MODE_REPEAT" data-ref="_M/IW_MODE_REPEAT">IW_MODE_REPEAT</dfn>	4	/* Wireless Repeater (forwarder) */</u></td></tr>
<tr><th id="456">456</th><td><u>#define <dfn class="macro" id="_M/IW_MODE_SECOND" data-ref="_M/IW_MODE_SECOND">IW_MODE_SECOND</dfn>	5	/* Secondary master/repeater (backup) */</u></td></tr>
<tr><th id="457">457</th><td><u>#define <dfn class="macro" id="_M/IW_MODE_MONITOR" data-ref="_M/IW_MODE_MONITOR">IW_MODE_MONITOR</dfn>	6	/* Passive monitor (listen only) */</u></td></tr>
<tr><th id="458">458</th><td><u>#define <dfn class="macro" id="_M/IW_MODE_MESH" data-ref="_M/IW_MODE_MESH">IW_MODE_MESH</dfn>	7	/* Mesh (IEEE 802.11s) network */</u></td></tr>
<tr><th id="459">459</th><td></td></tr>
<tr><th id="460">460</th><td><i>/* Statistics flags (bitmask in updated) */</i></td></tr>
<tr><th id="461">461</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_QUAL_UPDATED" data-ref="_M/IW_QUAL_QUAL_UPDATED">IW_QUAL_QUAL_UPDATED</dfn>	0x01	/* Value was updated since last read */</u></td></tr>
<tr><th id="462">462</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_LEVEL_UPDATED" data-ref="_M/IW_QUAL_LEVEL_UPDATED">IW_QUAL_LEVEL_UPDATED</dfn>	0x02</u></td></tr>
<tr><th id="463">463</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_NOISE_UPDATED" data-ref="_M/IW_QUAL_NOISE_UPDATED">IW_QUAL_NOISE_UPDATED</dfn>	0x04</u></td></tr>
<tr><th id="464">464</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_ALL_UPDATED" data-ref="_M/IW_QUAL_ALL_UPDATED">IW_QUAL_ALL_UPDATED</dfn>	0x07</u></td></tr>
<tr><th id="465">465</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_DBM" data-ref="_M/IW_QUAL_DBM">IW_QUAL_DBM</dfn>		0x08	/* Level + Noise are dBm */</u></td></tr>
<tr><th id="466">466</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_QUAL_INVALID" data-ref="_M/IW_QUAL_QUAL_INVALID">IW_QUAL_QUAL_INVALID</dfn>	0x10	/* Driver doesn't provide value */</u></td></tr>
<tr><th id="467">467</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_LEVEL_INVALID" data-ref="_M/IW_QUAL_LEVEL_INVALID">IW_QUAL_LEVEL_INVALID</dfn>	0x20</u></td></tr>
<tr><th id="468">468</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_NOISE_INVALID" data-ref="_M/IW_QUAL_NOISE_INVALID">IW_QUAL_NOISE_INVALID</dfn>	0x40</u></td></tr>
<tr><th id="469">469</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_RCPI" data-ref="_M/IW_QUAL_RCPI">IW_QUAL_RCPI</dfn>		0x80	/* Level + Noise are 802.11k RCPI */</u></td></tr>
<tr><th id="470">470</th><td><u>#define <dfn class="macro" id="_M/IW_QUAL_ALL_INVALID" data-ref="_M/IW_QUAL_ALL_INVALID">IW_QUAL_ALL_INVALID</dfn>	0x70</u></td></tr>
<tr><th id="471">471</th><td></td></tr>
<tr><th id="472">472</th><td><i>/* Frequency flags */</i></td></tr>
<tr><th id="473">473</th><td><u>#define <dfn class="macro" id="_M/IW_FREQ_AUTO" data-ref="_M/IW_FREQ_AUTO">IW_FREQ_AUTO</dfn>		0x00	/* Let the driver decides */</u></td></tr>
<tr><th id="474">474</th><td><u>#define <dfn class="macro" id="_M/IW_FREQ_FIXED" data-ref="_M/IW_FREQ_FIXED">IW_FREQ_FIXED</dfn>		0x01	/* Force a specific value */</u></td></tr>
<tr><th id="475">475</th><td></td></tr>
<tr><th id="476">476</th><td><i>/* Maximum number of size of encoding token available</i></td></tr>
<tr><th id="477">477</th><td><i> * they are listed in the range structure */</i></td></tr>
<tr><th id="478">478</th><td><u>#define <dfn class="macro" id="_M/IW_MAX_ENCODING_SIZES" data-ref="_M/IW_MAX_ENCODING_SIZES">IW_MAX_ENCODING_SIZES</dfn>	8</u></td></tr>
<tr><th id="479">479</th><td></td></tr>
<tr><th id="480">480</th><td><i>/* Maximum size of the encoding token in bytes */</i></td></tr>
<tr><th id="481">481</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODING_TOKEN_MAX" data-ref="_M/IW_ENCODING_TOKEN_MAX">IW_ENCODING_TOKEN_MAX</dfn>	64	/* 512 bits (for now) */</u></td></tr>
<tr><th id="482">482</th><td></td></tr>
<tr><th id="483">483</th><td><i>/* Flags for encoding (along with the token) */</i></td></tr>
<tr><th id="484">484</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_INDEX" data-ref="_M/IW_ENCODE_INDEX">IW_ENCODE_INDEX</dfn>		0x00FF	/* Token index (if needed) */</u></td></tr>
<tr><th id="485">485</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_FLAGS" data-ref="_M/IW_ENCODE_FLAGS">IW_ENCODE_FLAGS</dfn>		0xFF00	/* Flags defined below */</u></td></tr>
<tr><th id="486">486</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_MODE" data-ref="_M/IW_ENCODE_MODE">IW_ENCODE_MODE</dfn>		0xF000	/* Modes defined below */</u></td></tr>
<tr><th id="487">487</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_DISABLED" data-ref="_M/IW_ENCODE_DISABLED">IW_ENCODE_DISABLED</dfn>	0x8000	/* Encoding disabled */</u></td></tr>
<tr><th id="488">488</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_ENABLED" data-ref="_M/IW_ENCODE_ENABLED">IW_ENCODE_ENABLED</dfn>	0x0000	/* Encoding enabled */</u></td></tr>
<tr><th id="489">489</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_RESTRICTED" data-ref="_M/IW_ENCODE_RESTRICTED">IW_ENCODE_RESTRICTED</dfn>	0x4000	/* Refuse non-encoded packets */</u></td></tr>
<tr><th id="490">490</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_OPEN" data-ref="_M/IW_ENCODE_OPEN">IW_ENCODE_OPEN</dfn>		0x2000	/* Accept non-encoded packets */</u></td></tr>
<tr><th id="491">491</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_NOKEY" data-ref="_M/IW_ENCODE_NOKEY">IW_ENCODE_NOKEY</dfn>		0x0800  /* Key is write only, so not present */</u></td></tr>
<tr><th id="492">492</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_TEMP" data-ref="_M/IW_ENCODE_TEMP">IW_ENCODE_TEMP</dfn>		0x0400  /* Temporary key */</u></td></tr>
<tr><th id="493">493</th><td></td></tr>
<tr><th id="494">494</th><td><i>/* Power management flags available (along with the value, if any) */</i></td></tr>
<tr><th id="495">495</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_ON" data-ref="_M/IW_POWER_ON">IW_POWER_ON</dfn>		0x0000	/* No details... */</u></td></tr>
<tr><th id="496">496</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_TYPE" data-ref="_M/IW_POWER_TYPE">IW_POWER_TYPE</dfn>		0xF000	/* Type of parameter */</u></td></tr>
<tr><th id="497">497</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_PERIOD" data-ref="_M/IW_POWER_PERIOD">IW_POWER_PERIOD</dfn>		0x1000	/* Value is a period/duration of  */</u></td></tr>
<tr><th id="498">498</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_TIMEOUT" data-ref="_M/IW_POWER_TIMEOUT">IW_POWER_TIMEOUT</dfn>	0x2000	/* Value is a timeout (to go asleep) */</u></td></tr>
<tr><th id="499">499</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_MODE" data-ref="_M/IW_POWER_MODE">IW_POWER_MODE</dfn>		0x0F00	/* Power Management mode */</u></td></tr>
<tr><th id="500">500</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_UNICAST_R" data-ref="_M/IW_POWER_UNICAST_R">IW_POWER_UNICAST_R</dfn>	0x0100	/* Receive only unicast messages */</u></td></tr>
<tr><th id="501">501</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_MULTICAST_R" data-ref="_M/IW_POWER_MULTICAST_R">IW_POWER_MULTICAST_R</dfn>	0x0200	/* Receive only multicast messages */</u></td></tr>
<tr><th id="502">502</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_ALL_R" data-ref="_M/IW_POWER_ALL_R">IW_POWER_ALL_R</dfn>		0x0300	/* Receive all messages though PM */</u></td></tr>
<tr><th id="503">503</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_FORCE_S" data-ref="_M/IW_POWER_FORCE_S">IW_POWER_FORCE_S</dfn>	0x0400	/* Force PM procedure for sending unicast */</u></td></tr>
<tr><th id="504">504</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_REPEATER" data-ref="_M/IW_POWER_REPEATER">IW_POWER_REPEATER</dfn>	0x0800	/* Repeat broadcast messages in PM period */</u></td></tr>
<tr><th id="505">505</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_MODIFIER" data-ref="_M/IW_POWER_MODIFIER">IW_POWER_MODIFIER</dfn>	0x000F	/* Modify a parameter */</u></td></tr>
<tr><th id="506">506</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_MIN" data-ref="_M/IW_POWER_MIN">IW_POWER_MIN</dfn>		0x0001	/* Value is a minimum  */</u></td></tr>
<tr><th id="507">507</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_MAX" data-ref="_M/IW_POWER_MAX">IW_POWER_MAX</dfn>		0x0002	/* Value is a maximum */</u></td></tr>
<tr><th id="508">508</th><td><u>#define <dfn class="macro" id="_M/IW_POWER_RELATIVE" data-ref="_M/IW_POWER_RELATIVE">IW_POWER_RELATIVE</dfn>	0x0004	/* Value is not in seconds/ms/us */</u></td></tr>
<tr><th id="509">509</th><td></td></tr>
<tr><th id="510">510</th><td><i>/* Transmit Power flags available */</i></td></tr>
<tr><th id="511">511</th><td><u>#define <dfn class="macro" id="_M/IW_TXPOW_TYPE" data-ref="_M/IW_TXPOW_TYPE">IW_TXPOW_TYPE</dfn>		0x00FF	/* Type of value */</u></td></tr>
<tr><th id="512">512</th><td><u>#define <dfn class="macro" id="_M/IW_TXPOW_DBM" data-ref="_M/IW_TXPOW_DBM">IW_TXPOW_DBM</dfn>		0x0000	/* Value is in dBm */</u></td></tr>
<tr><th id="513">513</th><td><u>#define <dfn class="macro" id="_M/IW_TXPOW_MWATT" data-ref="_M/IW_TXPOW_MWATT">IW_TXPOW_MWATT</dfn>		0x0001	/* Value is in mW */</u></td></tr>
<tr><th id="514">514</th><td><u>#define <dfn class="macro" id="_M/IW_TXPOW_RELATIVE" data-ref="_M/IW_TXPOW_RELATIVE">IW_TXPOW_RELATIVE</dfn>	0x0002	/* Value is in arbitrary units */</u></td></tr>
<tr><th id="515">515</th><td><u>#define <dfn class="macro" id="_M/IW_TXPOW_RANGE" data-ref="_M/IW_TXPOW_RANGE">IW_TXPOW_RANGE</dfn>		0x1000	/* Range of value between min/max */</u></td></tr>
<tr><th id="516">516</th><td></td></tr>
<tr><th id="517">517</th><td><i>/* Retry limits and lifetime flags available */</i></td></tr>
<tr><th id="518">518</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_ON" data-ref="_M/IW_RETRY_ON">IW_RETRY_ON</dfn>		0x0000	/* No details... */</u></td></tr>
<tr><th id="519">519</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_TYPE" data-ref="_M/IW_RETRY_TYPE">IW_RETRY_TYPE</dfn>		0xF000	/* Type of parameter */</u></td></tr>
<tr><th id="520">520</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_LIMIT" data-ref="_M/IW_RETRY_LIMIT">IW_RETRY_LIMIT</dfn>		0x1000	/* Maximum number of retries*/</u></td></tr>
<tr><th id="521">521</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_LIFETIME" data-ref="_M/IW_RETRY_LIFETIME">IW_RETRY_LIFETIME</dfn>	0x2000	/* Maximum duration of retries in us */</u></td></tr>
<tr><th id="522">522</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_MODIFIER" data-ref="_M/IW_RETRY_MODIFIER">IW_RETRY_MODIFIER</dfn>	0x00FF	/* Modify a parameter */</u></td></tr>
<tr><th id="523">523</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_MIN" data-ref="_M/IW_RETRY_MIN">IW_RETRY_MIN</dfn>		0x0001	/* Value is a minimum  */</u></td></tr>
<tr><th id="524">524</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_MAX" data-ref="_M/IW_RETRY_MAX">IW_RETRY_MAX</dfn>		0x0002	/* Value is a maximum */</u></td></tr>
<tr><th id="525">525</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_RELATIVE" data-ref="_M/IW_RETRY_RELATIVE">IW_RETRY_RELATIVE</dfn>	0x0004	/* Value is not in seconds/ms/us */</u></td></tr>
<tr><th id="526">526</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_SHORT" data-ref="_M/IW_RETRY_SHORT">IW_RETRY_SHORT</dfn>		0x0010	/* Value is for short packets  */</u></td></tr>
<tr><th id="527">527</th><td><u>#define <dfn class="macro" id="_M/IW_RETRY_LONG" data-ref="_M/IW_RETRY_LONG">IW_RETRY_LONG</dfn>		0x0020	/* Value is for long packets */</u></td></tr>
<tr><th id="528">528</th><td></td></tr>
<tr><th id="529">529</th><td><i>/* Scanning request flags */</i></td></tr>
<tr><th id="530">530</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_DEFAULT" data-ref="_M/IW_SCAN_DEFAULT">IW_SCAN_DEFAULT</dfn>		0x0000	/* Default scan of the driver */</u></td></tr>
<tr><th id="531">531</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_ALL_ESSID" data-ref="_M/IW_SCAN_ALL_ESSID">IW_SCAN_ALL_ESSID</dfn>	0x0001	/* Scan all ESSIDs */</u></td></tr>
<tr><th id="532">532</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_THIS_ESSID" data-ref="_M/IW_SCAN_THIS_ESSID">IW_SCAN_THIS_ESSID</dfn>	0x0002	/* Scan only this ESSID */</u></td></tr>
<tr><th id="533">533</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_ALL_FREQ" data-ref="_M/IW_SCAN_ALL_FREQ">IW_SCAN_ALL_FREQ</dfn>	0x0004	/* Scan all Frequencies */</u></td></tr>
<tr><th id="534">534</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_THIS_FREQ" data-ref="_M/IW_SCAN_THIS_FREQ">IW_SCAN_THIS_FREQ</dfn>	0x0008	/* Scan only this Frequency */</u></td></tr>
<tr><th id="535">535</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_ALL_MODE" data-ref="_M/IW_SCAN_ALL_MODE">IW_SCAN_ALL_MODE</dfn>	0x0010	/* Scan all Modes */</u></td></tr>
<tr><th id="536">536</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_THIS_MODE" data-ref="_M/IW_SCAN_THIS_MODE">IW_SCAN_THIS_MODE</dfn>	0x0020	/* Scan only this Mode */</u></td></tr>
<tr><th id="537">537</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_ALL_RATE" data-ref="_M/IW_SCAN_ALL_RATE">IW_SCAN_ALL_RATE</dfn>	0x0040	/* Scan all Bit-Rates */</u></td></tr>
<tr><th id="538">538</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_THIS_RATE" data-ref="_M/IW_SCAN_THIS_RATE">IW_SCAN_THIS_RATE</dfn>	0x0080	/* Scan only this Bit-Rate */</u></td></tr>
<tr><th id="539">539</th><td><i>/* struct iw_scan_req scan_type */</i></td></tr>
<tr><th id="540">540</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_TYPE_ACTIVE" data-ref="_M/IW_SCAN_TYPE_ACTIVE">IW_SCAN_TYPE_ACTIVE</dfn> 0</u></td></tr>
<tr><th id="541">541</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_TYPE_PASSIVE" data-ref="_M/IW_SCAN_TYPE_PASSIVE">IW_SCAN_TYPE_PASSIVE</dfn> 1</u></td></tr>
<tr><th id="542">542</th><td><i>/* Maximum size of returned data */</i></td></tr>
<tr><th id="543">543</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_MAX_DATA" data-ref="_M/IW_SCAN_MAX_DATA">IW_SCAN_MAX_DATA</dfn>	4096	/* In bytes */</u></td></tr>
<tr><th id="544">544</th><td></td></tr>
<tr><th id="545">545</th><td><i>/* Scan capability flags - in (struct iw_range *)-&gt;scan_capa */</i></td></tr>
<tr><th id="546">546</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_CAPA_NONE" data-ref="_M/IW_SCAN_CAPA_NONE">IW_SCAN_CAPA_NONE</dfn>		0x00</u></td></tr>
<tr><th id="547">547</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_CAPA_ESSID" data-ref="_M/IW_SCAN_CAPA_ESSID">IW_SCAN_CAPA_ESSID</dfn>		0x01</u></td></tr>
<tr><th id="548">548</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_CAPA_BSSID" data-ref="_M/IW_SCAN_CAPA_BSSID">IW_SCAN_CAPA_BSSID</dfn>		0x02</u></td></tr>
<tr><th id="549">549</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_CAPA_CHANNEL" data-ref="_M/IW_SCAN_CAPA_CHANNEL">IW_SCAN_CAPA_CHANNEL</dfn>	0x04</u></td></tr>
<tr><th id="550">550</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_CAPA_MODE" data-ref="_M/IW_SCAN_CAPA_MODE">IW_SCAN_CAPA_MODE</dfn>		0x08</u></td></tr>
<tr><th id="551">551</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_CAPA_RATE" data-ref="_M/IW_SCAN_CAPA_RATE">IW_SCAN_CAPA_RATE</dfn>		0x10</u></td></tr>
<tr><th id="552">552</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_CAPA_TYPE" data-ref="_M/IW_SCAN_CAPA_TYPE">IW_SCAN_CAPA_TYPE</dfn>		0x20</u></td></tr>
<tr><th id="553">553</th><td><u>#define <dfn class="macro" id="_M/IW_SCAN_CAPA_TIME" data-ref="_M/IW_SCAN_CAPA_TIME">IW_SCAN_CAPA_TIME</dfn>		0x40</u></td></tr>
<tr><th id="554">554</th><td></td></tr>
<tr><th id="555">555</th><td><i>/* Max number of char in custom event - use multiple of them if needed */</i></td></tr>
<tr><th id="556">556</th><td><u>#define <dfn class="macro" id="_M/IW_CUSTOM_MAX" data-ref="_M/IW_CUSTOM_MAX">IW_CUSTOM_MAX</dfn>		256	/* In bytes */</u></td></tr>
<tr><th id="557">557</th><td></td></tr>
<tr><th id="558">558</th><td><i>/* Generic information element */</i></td></tr>
<tr><th id="559">559</th><td><u>#define <dfn class="macro" id="_M/IW_GENERIC_IE_MAX" data-ref="_M/IW_GENERIC_IE_MAX">IW_GENERIC_IE_MAX</dfn>	1024</u></td></tr>
<tr><th id="560">560</th><td></td></tr>
<tr><th id="561">561</th><td><i>/* MLME requests (SIOCSIWMLME / struct iw_mlme) */</i></td></tr>
<tr><th id="562">562</th><td><u>#define <dfn class="macro" id="_M/IW_MLME_DEAUTH" data-ref="_M/IW_MLME_DEAUTH">IW_MLME_DEAUTH</dfn>		0</u></td></tr>
<tr><th id="563">563</th><td><u>#define <dfn class="macro" id="_M/IW_MLME_DISASSOC" data-ref="_M/IW_MLME_DISASSOC">IW_MLME_DISASSOC</dfn>	1</u></td></tr>
<tr><th id="564">564</th><td><u>#define <dfn class="macro" id="_M/IW_MLME_AUTH" data-ref="_M/IW_MLME_AUTH">IW_MLME_AUTH</dfn>		2</u></td></tr>
<tr><th id="565">565</th><td><u>#define <dfn class="macro" id="_M/IW_MLME_ASSOC" data-ref="_M/IW_MLME_ASSOC">IW_MLME_ASSOC</dfn>		3</u></td></tr>
<tr><th id="566">566</th><td></td></tr>
<tr><th id="567">567</th><td><i>/* SIOCSIWAUTH/SIOCGIWAUTH struct iw_param flags */</i></td></tr>
<tr><th id="568">568</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_INDEX" data-ref="_M/IW_AUTH_INDEX">IW_AUTH_INDEX</dfn>		0x0FFF</u></td></tr>
<tr><th id="569">569</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_FLAGS" data-ref="_M/IW_AUTH_FLAGS">IW_AUTH_FLAGS</dfn>		0xF000</u></td></tr>
<tr><th id="570">570</th><td><i>/* SIOCSIWAUTH/SIOCGIWAUTH parameters (0 .. 4095)</i></td></tr>
<tr><th id="571">571</th><td><i> * (IW_AUTH_INDEX mask in struct iw_param flags; this is the index of the</i></td></tr>
<tr><th id="572">572</th><td><i> * parameter that is being set/get to; value will be read/written to</i></td></tr>
<tr><th id="573">573</th><td><i> * struct iw_param value field) */</i></td></tr>
<tr><th id="574">574</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_WPA_VERSION" data-ref="_M/IW_AUTH_WPA_VERSION">IW_AUTH_WPA_VERSION</dfn>		0</u></td></tr>
<tr><th id="575">575</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_PAIRWISE" data-ref="_M/IW_AUTH_CIPHER_PAIRWISE">IW_AUTH_CIPHER_PAIRWISE</dfn>		1</u></td></tr>
<tr><th id="576">576</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_GROUP" data-ref="_M/IW_AUTH_CIPHER_GROUP">IW_AUTH_CIPHER_GROUP</dfn>		2</u></td></tr>
<tr><th id="577">577</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_KEY_MGMT" data-ref="_M/IW_AUTH_KEY_MGMT">IW_AUTH_KEY_MGMT</dfn>		3</u></td></tr>
<tr><th id="578">578</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_TKIP_COUNTERMEASURES" data-ref="_M/IW_AUTH_TKIP_COUNTERMEASURES">IW_AUTH_TKIP_COUNTERMEASURES</dfn>	4</u></td></tr>
<tr><th id="579">579</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_DROP_UNENCRYPTED" data-ref="_M/IW_AUTH_DROP_UNENCRYPTED">IW_AUTH_DROP_UNENCRYPTED</dfn>	5</u></td></tr>
<tr><th id="580">580</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_80211_AUTH_ALG" data-ref="_M/IW_AUTH_80211_AUTH_ALG">IW_AUTH_80211_AUTH_ALG</dfn>		6</u></td></tr>
<tr><th id="581">581</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_WPA_ENABLED" data-ref="_M/IW_AUTH_WPA_ENABLED">IW_AUTH_WPA_ENABLED</dfn>		7</u></td></tr>
<tr><th id="582">582</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_RX_UNENCRYPTED_EAPOL" data-ref="_M/IW_AUTH_RX_UNENCRYPTED_EAPOL">IW_AUTH_RX_UNENCRYPTED_EAPOL</dfn>	8</u></td></tr>
<tr><th id="583">583</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_ROAMING_CONTROL" data-ref="_M/IW_AUTH_ROAMING_CONTROL">IW_AUTH_ROAMING_CONTROL</dfn>		9</u></td></tr>
<tr><th id="584">584</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_PRIVACY_INVOKED" data-ref="_M/IW_AUTH_PRIVACY_INVOKED">IW_AUTH_PRIVACY_INVOKED</dfn>		10</u></td></tr>
<tr><th id="585">585</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_GROUP_MGMT" data-ref="_M/IW_AUTH_CIPHER_GROUP_MGMT">IW_AUTH_CIPHER_GROUP_MGMT</dfn>	11</u></td></tr>
<tr><th id="586">586</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_MFP" data-ref="_M/IW_AUTH_MFP">IW_AUTH_MFP</dfn>			12</u></td></tr>
<tr><th id="587">587</th><td></td></tr>
<tr><th id="588">588</th><td><i>/* IW_AUTH_WPA_VERSION values (bit field) */</i></td></tr>
<tr><th id="589">589</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_WPA_VERSION_DISABLED" data-ref="_M/IW_AUTH_WPA_VERSION_DISABLED">IW_AUTH_WPA_VERSION_DISABLED</dfn>	0x00000001</u></td></tr>
<tr><th id="590">590</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_WPA_VERSION_WPA" data-ref="_M/IW_AUTH_WPA_VERSION_WPA">IW_AUTH_WPA_VERSION_WPA</dfn>		0x00000002</u></td></tr>
<tr><th id="591">591</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_WPA_VERSION_WPA2" data-ref="_M/IW_AUTH_WPA_VERSION_WPA2">IW_AUTH_WPA_VERSION_WPA2</dfn>	0x00000004</u></td></tr>
<tr><th id="592">592</th><td></td></tr>
<tr><th id="593">593</th><td><i>/* IW_AUTH_PAIRWISE_CIPHER, IW_AUTH_GROUP_CIPHER, and IW_AUTH_CIPHER_GROUP_MGMT</i></td></tr>
<tr><th id="594">594</th><td><i> * values (bit field) */</i></td></tr>
<tr><th id="595">595</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_NONE" data-ref="_M/IW_AUTH_CIPHER_NONE">IW_AUTH_CIPHER_NONE</dfn>	0x00000001</u></td></tr>
<tr><th id="596">596</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_WEP40" data-ref="_M/IW_AUTH_CIPHER_WEP40">IW_AUTH_CIPHER_WEP40</dfn>	0x00000002</u></td></tr>
<tr><th id="597">597</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_TKIP" data-ref="_M/IW_AUTH_CIPHER_TKIP">IW_AUTH_CIPHER_TKIP</dfn>	0x00000004</u></td></tr>
<tr><th id="598">598</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_CCMP" data-ref="_M/IW_AUTH_CIPHER_CCMP">IW_AUTH_CIPHER_CCMP</dfn>	0x00000008</u></td></tr>
<tr><th id="599">599</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_WEP104" data-ref="_M/IW_AUTH_CIPHER_WEP104">IW_AUTH_CIPHER_WEP104</dfn>	0x00000010</u></td></tr>
<tr><th id="600">600</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_CIPHER_AES_CMAC" data-ref="_M/IW_AUTH_CIPHER_AES_CMAC">IW_AUTH_CIPHER_AES_CMAC</dfn>	0x00000020</u></td></tr>
<tr><th id="601">601</th><td></td></tr>
<tr><th id="602">602</th><td><i>/* IW_AUTH_KEY_MGMT values (bit field) */</i></td></tr>
<tr><th id="603">603</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_KEY_MGMT_802_1X" data-ref="_M/IW_AUTH_KEY_MGMT_802_1X">IW_AUTH_KEY_MGMT_802_1X</dfn>	1</u></td></tr>
<tr><th id="604">604</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_KEY_MGMT_PSK" data-ref="_M/IW_AUTH_KEY_MGMT_PSK">IW_AUTH_KEY_MGMT_PSK</dfn>	2</u></td></tr>
<tr><th id="605">605</th><td></td></tr>
<tr><th id="606">606</th><td><i>/* IW_AUTH_80211_AUTH_ALG values (bit field) */</i></td></tr>
<tr><th id="607">607</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_ALG_OPEN_SYSTEM" data-ref="_M/IW_AUTH_ALG_OPEN_SYSTEM">IW_AUTH_ALG_OPEN_SYSTEM</dfn>	0x00000001</u></td></tr>
<tr><th id="608">608</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_ALG_SHARED_KEY" data-ref="_M/IW_AUTH_ALG_SHARED_KEY">IW_AUTH_ALG_SHARED_KEY</dfn>	0x00000002</u></td></tr>
<tr><th id="609">609</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_ALG_LEAP" data-ref="_M/IW_AUTH_ALG_LEAP">IW_AUTH_ALG_LEAP</dfn>	0x00000004</u></td></tr>
<tr><th id="610">610</th><td></td></tr>
<tr><th id="611">611</th><td><i>/* IW_AUTH_ROAMING_CONTROL values */</i></td></tr>
<tr><th id="612">612</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_ROAMING_ENABLE" data-ref="_M/IW_AUTH_ROAMING_ENABLE">IW_AUTH_ROAMING_ENABLE</dfn>	0	/* driver/firmware based roaming */</u></td></tr>
<tr><th id="613">613</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_ROAMING_DISABLE" data-ref="_M/IW_AUTH_ROAMING_DISABLE">IW_AUTH_ROAMING_DISABLE</dfn>	1	/* user space program used for roaming</u></td></tr>
<tr><th id="614">614</th><td><u>					 * control */</u></td></tr>
<tr><th id="615">615</th><td></td></tr>
<tr><th id="616">616</th><td><i>/* IW_AUTH_MFP (management frame protection) values */</i></td></tr>
<tr><th id="617">617</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_MFP_DISABLED" data-ref="_M/IW_AUTH_MFP_DISABLED">IW_AUTH_MFP_DISABLED</dfn>	0	/* MFP disabled */</u></td></tr>
<tr><th id="618">618</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_MFP_OPTIONAL" data-ref="_M/IW_AUTH_MFP_OPTIONAL">IW_AUTH_MFP_OPTIONAL</dfn>	1	/* MFP optional */</u></td></tr>
<tr><th id="619">619</th><td><u>#define <dfn class="macro" id="_M/IW_AUTH_MFP_REQUIRED" data-ref="_M/IW_AUTH_MFP_REQUIRED">IW_AUTH_MFP_REQUIRED</dfn>	2	/* MFP required */</u></td></tr>
<tr><th id="620">620</th><td></td></tr>
<tr><th id="621">621</th><td><i>/* SIOCSIWENCODEEXT definitions */</i></td></tr>
<tr><th id="622">622</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_SEQ_MAX_SIZE" data-ref="_M/IW_ENCODE_SEQ_MAX_SIZE">IW_ENCODE_SEQ_MAX_SIZE</dfn>	8</u></td></tr>
<tr><th id="623">623</th><td><i>/* struct iw_encode_ext -&gt;alg */</i></td></tr>
<tr><th id="624">624</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_ALG_NONE" data-ref="_M/IW_ENCODE_ALG_NONE">IW_ENCODE_ALG_NONE</dfn>	0</u></td></tr>
<tr><th id="625">625</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_ALG_WEP" data-ref="_M/IW_ENCODE_ALG_WEP">IW_ENCODE_ALG_WEP</dfn>	1</u></td></tr>
<tr><th id="626">626</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_ALG_TKIP" data-ref="_M/IW_ENCODE_ALG_TKIP">IW_ENCODE_ALG_TKIP</dfn>	2</u></td></tr>
<tr><th id="627">627</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_ALG_CCMP" data-ref="_M/IW_ENCODE_ALG_CCMP">IW_ENCODE_ALG_CCMP</dfn>	3</u></td></tr>
<tr><th id="628">628</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_ALG_PMK" data-ref="_M/IW_ENCODE_ALG_PMK">IW_ENCODE_ALG_PMK</dfn>	4</u></td></tr>
<tr><th id="629">629</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_ALG_AES_CMAC" data-ref="_M/IW_ENCODE_ALG_AES_CMAC">IW_ENCODE_ALG_AES_CMAC</dfn>	5</u></td></tr>
<tr><th id="630">630</th><td><i>/* struct iw_encode_ext -&gt;ext_flags */</i></td></tr>
<tr><th id="631">631</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_EXT_TX_SEQ_VALID" data-ref="_M/IW_ENCODE_EXT_TX_SEQ_VALID">IW_ENCODE_EXT_TX_SEQ_VALID</dfn>	0x00000001</u></td></tr>
<tr><th id="632">632</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_EXT_RX_SEQ_VALID" data-ref="_M/IW_ENCODE_EXT_RX_SEQ_VALID">IW_ENCODE_EXT_RX_SEQ_VALID</dfn>	0x00000002</u></td></tr>
<tr><th id="633">633</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_EXT_GROUP_KEY" data-ref="_M/IW_ENCODE_EXT_GROUP_KEY">IW_ENCODE_EXT_GROUP_KEY</dfn>		0x00000004</u></td></tr>
<tr><th id="634">634</th><td><u>#define <dfn class="macro" id="_M/IW_ENCODE_EXT_SET_TX_KEY" data-ref="_M/IW_ENCODE_EXT_SET_TX_KEY">IW_ENCODE_EXT_SET_TX_KEY</dfn>	0x00000008</u></td></tr>
<tr><th id="635">635</th><td></td></tr>
<tr><th id="636">636</th><td><i>/* IWEVMICHAELMICFAILURE : struct iw_michaelmicfailure -&gt;flags */</i></td></tr>
<tr><th id="637">637</th><td><u>#define <dfn class="macro" id="_M/IW_MICFAILURE_KEY_ID" data-ref="_M/IW_MICFAILURE_KEY_ID">IW_MICFAILURE_KEY_ID</dfn>	0x00000003 /* Key ID 0..3 */</u></td></tr>
<tr><th id="638">638</th><td><u>#define <dfn class="macro" id="_M/IW_MICFAILURE_GROUP" data-ref="_M/IW_MICFAILURE_GROUP">IW_MICFAILURE_GROUP</dfn>	0x00000004</u></td></tr>
<tr><th id="639">639</th><td><u>#define <dfn class="macro" id="_M/IW_MICFAILURE_PAIRWISE" data-ref="_M/IW_MICFAILURE_PAIRWISE">IW_MICFAILURE_PAIRWISE</dfn>	0x00000008</u></td></tr>
<tr><th id="640">640</th><td><u>#define <dfn class="macro" id="_M/IW_MICFAILURE_STAKEY" data-ref="_M/IW_MICFAILURE_STAKEY">IW_MICFAILURE_STAKEY</dfn>	0x00000010</u></td></tr>
<tr><th id="641">641</th><td><u>#define <dfn class="macro" id="_M/IW_MICFAILURE_COUNT" data-ref="_M/IW_MICFAILURE_COUNT">IW_MICFAILURE_COUNT</dfn>	0x00000060 /* 1 or 2 (0 = count not supported)</u></td></tr>
<tr><th id="642">642</th><td><u>					    */</u></td></tr>
<tr><th id="643">643</th><td></td></tr>
<tr><th id="644">644</th><td><i>/* Bit field values for enc_capa in struct iw_range */</i></td></tr>
<tr><th id="645">645</th><td><u>#define <dfn class="macro" id="_M/IW_ENC_CAPA_WPA" data-ref="_M/IW_ENC_CAPA_WPA">IW_ENC_CAPA_WPA</dfn>		0x00000001</u></td></tr>
<tr><th id="646">646</th><td><u>#define <dfn class="macro" id="_M/IW_ENC_CAPA_WPA2" data-ref="_M/IW_ENC_CAPA_WPA2">IW_ENC_CAPA_WPA2</dfn>	0x00000002</u></td></tr>
<tr><th id="647">647</th><td><u>#define <dfn class="macro" id="_M/IW_ENC_CAPA_CIPHER_TKIP" data-ref="_M/IW_ENC_CAPA_CIPHER_TKIP">IW_ENC_CAPA_CIPHER_TKIP</dfn>	0x00000004</u></td></tr>
<tr><th id="648">648</th><td><u>#define <dfn class="macro" id="_M/IW_ENC_CAPA_CIPHER_CCMP" data-ref="_M/IW_ENC_CAPA_CIPHER_CCMP">IW_ENC_CAPA_CIPHER_CCMP</dfn>	0x00000008</u></td></tr>
<tr><th id="649">649</th><td><u>#define <dfn class="macro" id="_M/IW_ENC_CAPA_4WAY_HANDSHAKE" data-ref="_M/IW_ENC_CAPA_4WAY_HANDSHAKE">IW_ENC_CAPA_4WAY_HANDSHAKE</dfn>	0x00000010</u></td></tr>
<tr><th id="650">650</th><td></td></tr>
<tr><th id="651">651</th><td><i>/* Event capability macros - in (struct iw_range *)-&gt;event_capa</i></td></tr>
<tr><th id="652">652</th><td><i> * Because we have more than 32 possible events, we use an array of</i></td></tr>
<tr><th id="653">653</th><td><i> * 32 bit bitmasks. Note : 32 bits = 0x20 = 2^5. */</i></td></tr>
<tr><th id="654">654</th><td><u>#define <dfn class="macro" id="_M/IW_EVENT_CAPA_BASE" data-ref="_M/IW_EVENT_CAPA_BASE">IW_EVENT_CAPA_BASE</dfn>(cmd)		((cmd &gt;= SIOCIWFIRSTPRIV) ? \</u></td></tr>
<tr><th id="655">655</th><td><u>					 (cmd - SIOCIWFIRSTPRIV + 0x60) : \</u></td></tr>
<tr><th id="656">656</th><td><u>					 (cmd - SIOCIWFIRST))</u></td></tr>
<tr><th id="657">657</th><td><u>#define <dfn class="macro" id="_M/IW_EVENT_CAPA_INDEX" data-ref="_M/IW_EVENT_CAPA_INDEX">IW_EVENT_CAPA_INDEX</dfn>(cmd)	(IW_EVENT_CAPA_BASE(cmd) &gt;&gt; 5)</u></td></tr>
<tr><th id="658">658</th><td><u>#define <dfn class="macro" id="_M/IW_EVENT_CAPA_MASK" data-ref="_M/IW_EVENT_CAPA_MASK">IW_EVENT_CAPA_MASK</dfn>(cmd)		(1 &lt;&lt; (IW_EVENT_CAPA_BASE(cmd) &amp; 0x1F))</u></td></tr>
<tr><th id="659">659</th><td><i>/* Event capability constants - event autogenerated by the kernel</i></td></tr>
<tr><th id="660">660</th><td><i> * This list is valid for most 802.11 devices, customise as needed... */</i></td></tr>
<tr><th id="661">661</th><td><u>#define <dfn class="macro" id="_M/IW_EVENT_CAPA_K_0" data-ref="_M/IW_EVENT_CAPA_K_0">IW_EVENT_CAPA_K_0</dfn>	(IW_EVENT_CAPA_MASK(0x8B04) | \</u></td></tr>
<tr><th id="662">662</th><td><u>				 IW_EVENT_CAPA_MASK(0x8B06) | \</u></td></tr>
<tr><th id="663">663</th><td><u>				 IW_EVENT_CAPA_MASK(0x8B1A))</u></td></tr>
<tr><th id="664">664</th><td><u>#define <dfn class="macro" id="_M/IW_EVENT_CAPA_K_1" data-ref="_M/IW_EVENT_CAPA_K_1">IW_EVENT_CAPA_K_1</dfn>	(IW_EVENT_CAPA_MASK(0x8B2A))</u></td></tr>
<tr><th id="665">665</th><td><i>/* "Easy" macro to set events in iw_range (less efficient) */</i></td></tr>
<tr><th id="666">666</th><td><u>#define <dfn class="macro" id="_M/IW_EVENT_CAPA_SET" data-ref="_M/IW_EVENT_CAPA_SET">IW_EVENT_CAPA_SET</dfn>(event_capa, cmd) (event_capa[IW_EVENT_CAPA_INDEX(cmd)] |= IW_EVENT_CAPA_MASK(cmd))</u></td></tr>
<tr><th id="667">667</th><td><u>#define <dfn class="macro" id="_M/IW_EVENT_CAPA_SET_KERNEL" data-ref="_M/IW_EVENT_CAPA_SET_KERNEL">IW_EVENT_CAPA_SET_KERNEL</dfn>(event_capa) {event_capa[0] |= IW_EVENT_CAPA_K_0; event_capa[1] |= IW_EVENT_CAPA_K_1; }</u></td></tr>
<tr><th id="668">668</th><td></td></tr>
<tr><th id="669">669</th><td></td></tr>
<tr><th id="670">670</th><td><i>/****************************** TYPES ******************************/</i></td></tr>
<tr><th id="671">671</th><td></td></tr>
<tr><th id="672">672</th><td><i>/* --------------------------- SUBTYPES --------------------------- */</i></td></tr>
<tr><th id="673">673</th><td><i>/*</i></td></tr>
<tr><th id="674">674</th><td><i> *	Generic format for most parameters that fit in an int</i></td></tr>
<tr><th id="675">675</th><td><i> */</i></td></tr>
<tr><th id="676">676</th><td><b>struct</b> <dfn class="type def" id="iw_param" title='iw_param' data-ref="iw_param">iw_param</dfn> {</td></tr>
<tr><th id="677">677</th><td>  <a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_param::value" title='iw_param::value' data-ref="iw_param::value">value</dfn>;		<i>/* The value of the parameter itself */</i></td></tr>
<tr><th id="678">678</th><td>  <a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_param::fixed" title='iw_param::fixed' data-ref="iw_param::fixed">fixed</dfn>;		<i>/* Hardware should not use auto select */</i></td></tr>
<tr><th id="679">679</th><td>  <a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_param::disabled" title='iw_param::disabled' data-ref="iw_param::disabled">disabled</dfn>;	<i>/* Disable the feature */</i></td></tr>
<tr><th id="680">680</th><td>  <a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_param::flags" title='iw_param::flags' data-ref="iw_param::flags">flags</dfn>;		<i>/* Various specifc flags (if any) */</i></td></tr>
<tr><th id="681">681</th><td>};</td></tr>
<tr><th id="682">682</th><td></td></tr>
<tr><th id="683">683</th><td><i>/*</i></td></tr>
<tr><th id="684">684</th><td><i> *	For all data larger than 16 octets, we need to use a</i></td></tr>
<tr><th id="685">685</th><td><i> *	pointer to memory allocated in user space.</i></td></tr>
<tr><th id="686">686</th><td><i> */</i></td></tr>
<tr><th id="687">687</th><td><b>struct</b> <dfn class="type def" id="iw_point" title='iw_point' data-ref="iw_point">iw_point</dfn> {</td></tr>
<tr><th id="688">688</th><td>  <em>void</em> *<dfn class="decl field" id="iw_point::pointer" title='iw_point::pointer' data-ref="iw_point::pointer">pointer</dfn>;	<i>/* Pointer to the data  (in user space) */</i></td></tr>
<tr><th id="689">689</th><td>  <a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_point::length" title='iw_point::length' data-ref="iw_point::length">length</dfn>;		<i>/* number of fields or size in bytes */</i></td></tr>
<tr><th id="690">690</th><td>  <a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_point::flags" title='iw_point::flags' data-ref="iw_point::flags">flags</dfn>;		<i>/* Optional params */</i></td></tr>
<tr><th id="691">691</th><td>};</td></tr>
<tr><th id="692">692</th><td></td></tr>
<tr><th id="693">693</th><td></td></tr>
<tr><th id="694">694</th><td><i>/*</i></td></tr>
<tr><th id="695">695</th><td><i> *	A frequency</i></td></tr>
<tr><th id="696">696</th><td><i> *	For numbers lower than 10^9, we encode the number in 'm' and</i></td></tr>
<tr><th id="697">697</th><td><i> *	set 'e' to 0</i></td></tr>
<tr><th id="698">698</th><td><i> *	For number greater than 10^9, we divide it by the lowest power</i></td></tr>
<tr><th id="699">699</th><td><i> *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...</i></td></tr>
<tr><th id="700">700</th><td><i> *	The power of 10 is in 'e', the result of the division is in 'm'.</i></td></tr>
<tr><th id="701">701</th><td><i> */</i></td></tr>
<tr><th id="702">702</th><td><b>struct</b> <dfn class="type def" id="iw_freq" title='iw_freq' data-ref="iw_freq">iw_freq</dfn> {</td></tr>
<tr><th id="703">703</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_freq::m" title='iw_freq::m' data-ref="iw_freq::m">m</dfn>;		<i>/* Mantissa */</i></td></tr>
<tr><th id="704">704</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s16" title='__s16' data-type='short' data-ref="__s16">__s16</a>		<dfn class="decl field" id="iw_freq::e" title='iw_freq::e' data-ref="iw_freq::e">e</dfn>;		<i>/* Exponent */</i></td></tr>
<tr><th id="705">705</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_freq::i" title='iw_freq::i' data-ref="iw_freq::i">i</dfn>;		<i>/* List index (when in range struct) */</i></td></tr>
<tr><th id="706">706</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_freq::flags" title='iw_freq::flags' data-ref="iw_freq::flags">flags</dfn>;		<i>/* Flags (fixed/auto) */</i></td></tr>
<tr><th id="707">707</th><td>};</td></tr>
<tr><th id="708">708</th><td></td></tr>
<tr><th id="709">709</th><td><i>/*</i></td></tr>
<tr><th id="710">710</th><td><i> *	Quality of the link</i></td></tr>
<tr><th id="711">711</th><td><i> */</i></td></tr>
<tr><th id="712">712</th><td><b>struct</b> <dfn class="type def" id="iw_quality" title='iw_quality' data-ref="iw_quality">iw_quality</dfn> {</td></tr>
<tr><th id="713">713</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_quality::qual" title='iw_quality::qual' data-ref="iw_quality::qual">qual</dfn>;		<i>/* link quality (%retries, SNR,</i></td></tr>
<tr><th id="714">714</th><td><i>					   %missed beacons or better...) */</i></td></tr>
<tr><th id="715">715</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_quality::level" title='iw_quality::level' data-ref="iw_quality::level">level</dfn>;		<i>/* signal level (dBm) */</i></td></tr>
<tr><th id="716">716</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_quality::noise" title='iw_quality::noise' data-ref="iw_quality::noise">noise</dfn>;		<i>/* noise level (dBm) */</i></td></tr>
<tr><th id="717">717</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_quality::updated" title='iw_quality::updated' data-ref="iw_quality::updated">updated</dfn>;	<i>/* Flags to know if updated */</i></td></tr>
<tr><th id="718">718</th><td>};</td></tr>
<tr><th id="719">719</th><td></td></tr>
<tr><th id="720">720</th><td><i>/*</i></td></tr>
<tr><th id="721">721</th><td><i> *	Packet discarded in the wireless adapter due to</i></td></tr>
<tr><th id="722">722</th><td><i> *	"wireless" specific problems...</i></td></tr>
<tr><th id="723">723</th><td><i> *	Note : the list of counter and statistics in net_device_stats</i></td></tr>
<tr><th id="724">724</th><td><i> *	is already pretty exhaustive, and you should use that first.</i></td></tr>
<tr><th id="725">725</th><td><i> *	This is only additional stats...</i></td></tr>
<tr><th id="726">726</th><td><i> */</i></td></tr>
<tr><th id="727">727</th><td><b>struct</b> <dfn class="type def" id="iw_discarded" title='iw_discarded' data-ref="iw_discarded">iw_discarded</dfn> {</td></tr>
<tr><th id="728">728</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_discarded::nwid" title='iw_discarded::nwid' data-ref="iw_discarded::nwid">nwid</dfn>;		<i>/* Rx : Wrong nwid/essid */</i></td></tr>
<tr><th id="729">729</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_discarded::code" title='iw_discarded::code' data-ref="iw_discarded::code">code</dfn>;		<i>/* Rx : Unable to code/decode (WEP) */</i></td></tr>
<tr><th id="730">730</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_discarded::fragment" title='iw_discarded::fragment' data-ref="iw_discarded::fragment">fragment</dfn>;	<i>/* Rx : Can't perform MAC reassembly */</i></td></tr>
<tr><th id="731">731</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_discarded::retries" title='iw_discarded::retries' data-ref="iw_discarded::retries">retries</dfn>;	<i>/* Tx : Max MAC retries num reached */</i></td></tr>
<tr><th id="732">732</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_discarded::misc" title='iw_discarded::misc' data-ref="iw_discarded::misc">misc</dfn>;		<i>/* Others cases */</i></td></tr>
<tr><th id="733">733</th><td>};</td></tr>
<tr><th id="734">734</th><td></td></tr>
<tr><th id="735">735</th><td><i>/*</i></td></tr>
<tr><th id="736">736</th><td><i> *	Packet/Time period missed in the wireless adapter due to</i></td></tr>
<tr><th id="737">737</th><td><i> *	"wireless" specific problems...</i></td></tr>
<tr><th id="738">738</th><td><i> */</i></td></tr>
<tr><th id="739">739</th><td><b>struct</b> <dfn class="type def" id="iw_missed" title='iw_missed' data-ref="iw_missed">iw_missed</dfn> {</td></tr>
<tr><th id="740">740</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_missed::beacon" title='iw_missed::beacon' data-ref="iw_missed::beacon">beacon</dfn>;		<i>/* Missed beacons/superframe */</i></td></tr>
<tr><th id="741">741</th><td>};</td></tr>
<tr><th id="742">742</th><td></td></tr>
<tr><th id="743">743</th><td><i>/*</i></td></tr>
<tr><th id="744">744</th><td><i> *	Quality range (for spy threshold)</i></td></tr>
<tr><th id="745">745</th><td><i> */</i></td></tr>
<tr><th id="746">746</th><td><b>struct</b> <dfn class="type def" id="iw_thrspy" title='iw_thrspy' data-ref="iw_thrspy">iw_thrspy</dfn> {</td></tr>
<tr><th id="747">747</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>		<dfn class="decl field" id="iw_thrspy::addr" title='iw_thrspy::addr' data-ref="iw_thrspy::addr">addr</dfn>;		<i>/* Source address (hw/mac) */</i></td></tr>
<tr><th id="748">748</th><td>	<b>struct</b> <a class="type" href="#iw_quality" title='iw_quality' data-ref="iw_quality">iw_quality</a>	<dfn class="decl field" id="iw_thrspy::qual" title='iw_thrspy::qual' data-ref="iw_thrspy::qual">qual</dfn>;		<i>/* Quality of the link */</i></td></tr>
<tr><th id="749">749</th><td>	<b>struct</b> <a class="type" href="#iw_quality" title='iw_quality' data-ref="iw_quality">iw_quality</a>	<dfn class="decl field" id="iw_thrspy::low" title='iw_thrspy::low' data-ref="iw_thrspy::low">low</dfn>;		<i>/* Low threshold */</i></td></tr>
<tr><th id="750">750</th><td>	<b>struct</b> <a class="type" href="#iw_quality" title='iw_quality' data-ref="iw_quality">iw_quality</a>	<dfn class="decl field" id="iw_thrspy::high" title='iw_thrspy::high' data-ref="iw_thrspy::high">high</dfn>;		<i>/* High threshold */</i></td></tr>
<tr><th id="751">751</th><td>};</td></tr>
<tr><th id="752">752</th><td></td></tr>
<tr><th id="753">753</th><td><i>/*</i></td></tr>
<tr><th id="754">754</th><td><i> *	Optional data for scan request</i></td></tr>
<tr><th id="755">755</th><td><i> *</i></td></tr>
<tr><th id="756">756</th><td><i> *	Note: these optional parameters are controlling parameters for the</i></td></tr>
<tr><th id="757">757</th><td><i> *	scanning behavior, these do not apply to getting scan results</i></td></tr>
<tr><th id="758">758</th><td><i> *	(SIOCGIWSCAN). Drivers are expected to keep a local BSS table and</i></td></tr>
<tr><th id="759">759</th><td><i> *	provide a merged results with all BSSes even if the previous scan</i></td></tr>
<tr><th id="760">760</th><td><i> *	request limited scanning to a subset, e.g., by specifying an SSID.</i></td></tr>
<tr><th id="761">761</th><td><i> *	Especially, scan results are required to include an entry for the</i></td></tr>
<tr><th id="762">762</th><td><i> *	current BSS if the driver is in Managed mode and associated with an AP.</i></td></tr>
<tr><th id="763">763</th><td><i> */</i></td></tr>
<tr><th id="764">764</th><td><b>struct</b> <dfn class="type def" id="iw_scan_req" title='iw_scan_req' data-ref="iw_scan_req">iw_scan_req</dfn> {</td></tr>
<tr><th id="765">765</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_scan_req::scan_type" title='iw_scan_req::scan_type' data-ref="iw_scan_req::scan_type">scan_type</dfn>; <i>/* IW_SCAN_TYPE_{ACTIVE,PASSIVE} */</i></td></tr>
<tr><th id="766">766</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_scan_req::essid_len" title='iw_scan_req::essid_len' data-ref="iw_scan_req::essid_len">essid_len</dfn>;</td></tr>
<tr><th id="767">767</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_scan_req::num_channels" title='iw_scan_req::num_channels' data-ref="iw_scan_req::num_channels">num_channels</dfn>; <i>/* num entries in channel_list;</i></td></tr>
<tr><th id="768">768</th><td><i>				       * 0 = scan all allowed channels */</i></td></tr>
<tr><th id="769">769</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_scan_req::flags" title='iw_scan_req::flags' data-ref="iw_scan_req::flags">flags</dfn>; <i>/* reserved as padding; use zero, this may</i></td></tr>
<tr><th id="770">770</th><td><i>				* be used in the future for adding flags</i></td></tr>
<tr><th id="771">771</th><td><i>				* to request different scan behavior */</i></td></tr>
<tr><th id="772">772</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>	<dfn class="decl field" id="iw_scan_req::bssid" title='iw_scan_req::bssid' data-ref="iw_scan_req::bssid">bssid</dfn>; <i>/* ff:ff:ff:ff:ff:ff for broadcast BSSID or</i></td></tr>
<tr><th id="773">773</th><td><i>				* individual address of a specific BSS */</i></td></tr>
<tr><th id="774">774</th><td></td></tr>
<tr><th id="775">775</th><td>	<i>/*</i></td></tr>
<tr><th id="776">776</th><td><i>	 * Use this ESSID if IW_SCAN_THIS_ESSID flag is used instead of using</i></td></tr>
<tr><th id="777">777</th><td><i>	 * the current ESSID. This allows scan requests for specific ESSID</i></td></tr>
<tr><th id="778">778</th><td><i>	 * without having to change the current ESSID and potentially breaking</i></td></tr>
<tr><th id="779">779</th><td><i>	 * the current association.</i></td></tr>
<tr><th id="780">780</th><td><i>	 */</i></td></tr>
<tr><th id="781">781</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_scan_req::essid" title='iw_scan_req::essid' data-ref="iw_scan_req::essid">essid</dfn>[<a class="macro" href="#448" title="32" data-ref="_M/IW_ESSID_MAX_SIZE">IW_ESSID_MAX_SIZE</a>];</td></tr>
<tr><th id="782">782</th><td></td></tr>
<tr><th id="783">783</th><td>	<i>/*</i></td></tr>
<tr><th id="784">784</th><td><i>	 * Optional parameters for changing the default scanning behavior.</i></td></tr>
<tr><th id="785">785</th><td><i>	 * These are based on the MLME-SCAN.request from IEEE Std 802.11.</i></td></tr>
<tr><th id="786">786</th><td><i>	 * TU is 1.024 ms. If these are set to 0, driver is expected to use</i></td></tr>
<tr><th id="787">787</th><td><i>	 * reasonable default values. min_channel_time defines the time that</i></td></tr>
<tr><th id="788">788</th><td><i>	 * will be used to wait for the first reply on each channel. If no</i></td></tr>
<tr><th id="789">789</th><td><i>	 * replies are received, next channel will be scanned after this. If</i></td></tr>
<tr><th id="790">790</th><td><i>	 * replies are received, total time waited on the channel is defined by</i></td></tr>
<tr><th id="791">791</th><td><i>	 * max_channel_time.</i></td></tr>
<tr><th id="792">792</th><td><i>	 */</i></td></tr>
<tr><th id="793">793</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_scan_req::min_channel_time" title='iw_scan_req::min_channel_time' data-ref="iw_scan_req::min_channel_time">min_channel_time</dfn>; <i>/* in TU */</i></td></tr>
<tr><th id="794">794</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_scan_req::max_channel_time" title='iw_scan_req::max_channel_time' data-ref="iw_scan_req::max_channel_time">max_channel_time</dfn>; <i>/* in TU */</i></td></tr>
<tr><th id="795">795</th><td></td></tr>
<tr><th id="796">796</th><td>	<b>struct</b> <a class="type" href="#iw_freq" title='iw_freq' data-ref="iw_freq">iw_freq</a>	<dfn class="decl field" id="iw_scan_req::channel_list" title='iw_scan_req::channel_list' data-ref="iw_scan_req::channel_list">channel_list</dfn>[<a class="macro" href="#427" title="32" data-ref="_M/IW_MAX_FREQUENCIES">IW_MAX_FREQUENCIES</a>];</td></tr>
<tr><th id="797">797</th><td>};</td></tr>
<tr><th id="798">798</th><td></td></tr>
<tr><th id="799">799</th><td><i>/* ------------------------- WPA SUPPORT ------------------------- */</i></td></tr>
<tr><th id="800">800</th><td></td></tr>
<tr><th id="801">801</th><td><i>/*</i></td></tr>
<tr><th id="802">802</th><td><i> *	Extended data structure for get/set encoding (this is used with</i></td></tr>
<tr><th id="803">803</th><td><i> *	SIOCSIWENCODEEXT/SIOCGIWENCODEEXT. struct iw_point and IW_ENCODE_*</i></td></tr>
<tr><th id="804">804</th><td><i> *	flags are used in the same way as with SIOCSIWENCODE/SIOCGIWENCODE and</i></td></tr>
<tr><th id="805">805</th><td><i> *	only the data contents changes (key data -&gt; this structure, including</i></td></tr>
<tr><th id="806">806</th><td><i> *	key data).</i></td></tr>
<tr><th id="807">807</th><td><i> *</i></td></tr>
<tr><th id="808">808</th><td><i> *	If the new key is the first group key, it will be set as the default</i></td></tr>
<tr><th id="809">809</th><td><i> *	TX key. Otherwise, default TX key index is only changed if</i></td></tr>
<tr><th id="810">810</th><td><i> *	IW_ENCODE_EXT_SET_TX_KEY flag is set.</i></td></tr>
<tr><th id="811">811</th><td><i> *</i></td></tr>
<tr><th id="812">812</th><td><i> *	Key will be changed with SIOCSIWENCODEEXT in all cases except for</i></td></tr>
<tr><th id="813">813</th><td><i> *	special "change TX key index" operation which is indicated by setting</i></td></tr>
<tr><th id="814">814</th><td><i> *	key_len = 0 and ext_flags |= IW_ENCODE_EXT_SET_TX_KEY.</i></td></tr>
<tr><th id="815">815</th><td><i> *</i></td></tr>
<tr><th id="816">816</th><td><i> *	tx_seq/rx_seq are only used when respective</i></td></tr>
<tr><th id="817">817</th><td><i> *	IW_ENCODE_EXT_{TX,RX}_SEQ_VALID flag is set in ext_flags. Normal</i></td></tr>
<tr><th id="818">818</th><td><i> *	TKIP/CCMP operation is to set RX seq with SIOCSIWENCODEEXT and start</i></td></tr>
<tr><th id="819">819</th><td><i> *	TX seq from zero whenever key is changed. SIOCGIWENCODEEXT is normally</i></td></tr>
<tr><th id="820">820</th><td><i> *	used only by an Authenticator (AP or an IBSS station) to get the</i></td></tr>
<tr><th id="821">821</th><td><i> *	current TX sequence number. Using TX_SEQ_VALID for SIOCSIWENCODEEXT and</i></td></tr>
<tr><th id="822">822</th><td><i> *	RX_SEQ_VALID for SIOCGIWENCODEEXT are optional, but can be useful for</i></td></tr>
<tr><th id="823">823</th><td><i> *	debugging/testing.</i></td></tr>
<tr><th id="824">824</th><td><i> */</i></td></tr>
<tr><th id="825">825</th><td><b>struct</b> <dfn class="type def" id="iw_encode_ext" title='iw_encode_ext' data-ref="iw_encode_ext">iw_encode_ext</dfn> {</td></tr>
<tr><th id="826">826</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_encode_ext::ext_flags" title='iw_encode_ext::ext_flags' data-ref="iw_encode_ext::ext_flags">ext_flags</dfn>; <i>/* IW_ENCODE_EXT_* */</i></td></tr>
<tr><th id="827">827</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_encode_ext::tx_seq" title='iw_encode_ext::tx_seq' data-ref="iw_encode_ext::tx_seq">tx_seq</dfn>[<a class="macro" href="#622" title="8" data-ref="_M/IW_ENCODE_SEQ_MAX_SIZE">IW_ENCODE_SEQ_MAX_SIZE</a>]; <i>/* LSB first */</i></td></tr>
<tr><th id="828">828</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_encode_ext::rx_seq" title='iw_encode_ext::rx_seq' data-ref="iw_encode_ext::rx_seq">rx_seq</dfn>[<a class="macro" href="#622" title="8" data-ref="_M/IW_ENCODE_SEQ_MAX_SIZE">IW_ENCODE_SEQ_MAX_SIZE</a>]; <i>/* LSB first */</i></td></tr>
<tr><th id="829">829</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>	<dfn class="decl field" id="iw_encode_ext::addr" title='iw_encode_ext::addr' data-ref="iw_encode_ext::addr">addr</dfn>; <i>/* ff:ff:ff:ff:ff:ff for broadcast/multicast</i></td></tr>
<tr><th id="830">830</th><td><i>			       * (group) keys or unicast address for</i></td></tr>
<tr><th id="831">831</th><td><i>			       * individual keys */</i></td></tr>
<tr><th id="832">832</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_encode_ext::alg" title='iw_encode_ext::alg' data-ref="iw_encode_ext::alg">alg</dfn>; <i>/* IW_ENCODE_ALG_* */</i></td></tr>
<tr><th id="833">833</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_encode_ext::key_len" title='iw_encode_ext::key_len' data-ref="iw_encode_ext::key_len">key_len</dfn>;</td></tr>
<tr><th id="834">834</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_encode_ext::key" title='iw_encode_ext::key' data-ref="iw_encode_ext::key">key</dfn>[<var>0</var>];</td></tr>
<tr><th id="835">835</th><td>};</td></tr>
<tr><th id="836">836</th><td></td></tr>
<tr><th id="837">837</th><td><i>/* SIOCSIWMLME data */</i></td></tr>
<tr><th id="838">838</th><td><b>struct</b> <dfn class="type def" id="iw_mlme" title='iw_mlme' data-ref="iw_mlme">iw_mlme</dfn> {</td></tr>
<tr><th id="839">839</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_mlme::cmd" title='iw_mlme::cmd' data-ref="iw_mlme::cmd">cmd</dfn>; <i>/* IW_MLME_* */</i></td></tr>
<tr><th id="840">840</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_mlme::reason_code" title='iw_mlme::reason_code' data-ref="iw_mlme::reason_code">reason_code</dfn>;</td></tr>
<tr><th id="841">841</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>	<dfn class="decl field" id="iw_mlme::addr" title='iw_mlme::addr' data-ref="iw_mlme::addr">addr</dfn>;</td></tr>
<tr><th id="842">842</th><td>};</td></tr>
<tr><th id="843">843</th><td></td></tr>
<tr><th id="844">844</th><td><i>/* SIOCSIWPMKSA data */</i></td></tr>
<tr><th id="845">845</th><td><u>#define <dfn class="macro" id="_M/IW_PMKSA_ADD" data-ref="_M/IW_PMKSA_ADD">IW_PMKSA_ADD</dfn>		1</u></td></tr>
<tr><th id="846">846</th><td><u>#define <dfn class="macro" id="_M/IW_PMKSA_REMOVE" data-ref="_M/IW_PMKSA_REMOVE">IW_PMKSA_REMOVE</dfn>		2</u></td></tr>
<tr><th id="847">847</th><td><u>#define <dfn class="macro" id="_M/IW_PMKSA_FLUSH" data-ref="_M/IW_PMKSA_FLUSH">IW_PMKSA_FLUSH</dfn>		3</u></td></tr>
<tr><th id="848">848</th><td></td></tr>
<tr><th id="849">849</th><td><u>#define <dfn class="macro" id="_M/IW_PMKID_LEN" data-ref="_M/IW_PMKID_LEN">IW_PMKID_LEN</dfn>	16</u></td></tr>
<tr><th id="850">850</th><td></td></tr>
<tr><th id="851">851</th><td><b>struct</b> <dfn class="type def" id="iw_pmksa" title='iw_pmksa' data-ref="iw_pmksa">iw_pmksa</dfn> {</td></tr>
<tr><th id="852">852</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_pmksa::cmd" title='iw_pmksa::cmd' data-ref="iw_pmksa::cmd">cmd</dfn>; <i>/* IW_PMKSA_* */</i></td></tr>
<tr><th id="853">853</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>	<dfn class="decl field" id="iw_pmksa::bssid" title='iw_pmksa::bssid' data-ref="iw_pmksa::bssid">bssid</dfn>;</td></tr>
<tr><th id="854">854</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_pmksa::pmkid" title='iw_pmksa::pmkid' data-ref="iw_pmksa::pmkid">pmkid</dfn>[<a class="macro" href="#849" title="16" data-ref="_M/IW_PMKID_LEN">IW_PMKID_LEN</a>];</td></tr>
<tr><th id="855">855</th><td>};</td></tr>
<tr><th id="856">856</th><td></td></tr>
<tr><th id="857">857</th><td><i>/* IWEVMICHAELMICFAILURE data */</i></td></tr>
<tr><th id="858">858</th><td><b>struct</b> <dfn class="type def" id="iw_michaelmicfailure" title='iw_michaelmicfailure' data-ref="iw_michaelmicfailure">iw_michaelmicfailure</dfn> {</td></tr>
<tr><th id="859">859</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_michaelmicfailure::flags" title='iw_michaelmicfailure::flags' data-ref="iw_michaelmicfailure::flags">flags</dfn>;</td></tr>
<tr><th id="860">860</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>	<dfn class="decl field" id="iw_michaelmicfailure::src_addr" title='iw_michaelmicfailure::src_addr' data-ref="iw_michaelmicfailure::src_addr">src_addr</dfn>;</td></tr>
<tr><th id="861">861</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_michaelmicfailure::tsc" title='iw_michaelmicfailure::tsc' data-ref="iw_michaelmicfailure::tsc">tsc</dfn>[<a class="macro" href="#622" title="8" data-ref="_M/IW_ENCODE_SEQ_MAX_SIZE">IW_ENCODE_SEQ_MAX_SIZE</a>]; <i>/* LSB first */</i></td></tr>
<tr><th id="862">862</th><td>};</td></tr>
<tr><th id="863">863</th><td></td></tr>
<tr><th id="864">864</th><td><i>/* IWEVPMKIDCAND data */</i></td></tr>
<tr><th id="865">865</th><td><u>#define <dfn class="macro" id="_M/IW_PMKID_CAND_PREAUTH" data-ref="_M/IW_PMKID_CAND_PREAUTH">IW_PMKID_CAND_PREAUTH</dfn>	0x00000001 /* RNS pre-authentication enabled */</u></td></tr>
<tr><th id="866">866</th><td><b>struct</b> <dfn class="type def" id="iw_pmkid_cand" title='iw_pmkid_cand' data-ref="iw_pmkid_cand">iw_pmkid_cand</dfn> {</td></tr>
<tr><th id="867">867</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_pmkid_cand::flags" title='iw_pmkid_cand::flags' data-ref="iw_pmkid_cand::flags">flags</dfn>; <i>/* IW_PMKID_CAND_* */</i></td></tr>
<tr><th id="868">868</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_pmkid_cand::index" title='iw_pmkid_cand::index' data-ref="iw_pmkid_cand::index">index</dfn>; <i>/* the smaller the index, the higher the</i></td></tr>
<tr><th id="869">869</th><td><i>				* priority */</i></td></tr>
<tr><th id="870">870</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>	<dfn class="decl field" id="iw_pmkid_cand::bssid" title='iw_pmkid_cand::bssid' data-ref="iw_pmkid_cand::bssid">bssid</dfn>;</td></tr>
<tr><th id="871">871</th><td>};</td></tr>
<tr><th id="872">872</th><td></td></tr>
<tr><th id="873">873</th><td><i>/* ------------------------ WIRELESS STATS ------------------------ */</i></td></tr>
<tr><th id="874">874</th><td><i>/*</i></td></tr>
<tr><th id="875">875</th><td><i> * Wireless statistics (used for /proc/net/wireless)</i></td></tr>
<tr><th id="876">876</th><td><i> */</i></td></tr>
<tr><th id="877">877</th><td><b>struct</b> <dfn class="type def" id="iw_statistics" title='iw_statistics' data-ref="iw_statistics">iw_statistics</dfn> {</td></tr>
<tr><th id="878">878</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_statistics::status" title='iw_statistics::status' data-ref="iw_statistics::status">status</dfn>;		<i>/* Status</i></td></tr>
<tr><th id="879">879</th><td><i>					 * - device dependent for now */</i></td></tr>
<tr><th id="880">880</th><td></td></tr>
<tr><th id="881">881</th><td>	<b>struct</b> <a class="type" href="#iw_quality" title='iw_quality' data-ref="iw_quality">iw_quality</a>	<dfn class="decl field" id="iw_statistics::qual" title='iw_statistics::qual' data-ref="iw_statistics::qual">qual</dfn>;		<i>/* Quality of the link</i></td></tr>
<tr><th id="882">882</th><td><i>						 * (instant/mean/max) */</i></td></tr>
<tr><th id="883">883</th><td>	<b>struct</b> <a class="type" href="#iw_discarded" title='iw_discarded' data-ref="iw_discarded">iw_discarded</a>	<dfn class="decl field" id="iw_statistics::discard" title='iw_statistics::discard' data-ref="iw_statistics::discard">discard</dfn>;	<i>/* Packet discarded counts */</i></td></tr>
<tr><th id="884">884</th><td>	<b>struct</b> <a class="type" href="#iw_missed" title='iw_missed' data-ref="iw_missed">iw_missed</a>	<dfn class="decl field" id="iw_statistics::miss" title='iw_statistics::miss' data-ref="iw_statistics::miss">miss</dfn>;		<i>/* Packet missed counts */</i></td></tr>
<tr><th id="885">885</th><td>};</td></tr>
<tr><th id="886">886</th><td></td></tr>
<tr><th id="887">887</th><td><i>/* ------------------------ IOCTL REQUEST ------------------------ */</i></td></tr>
<tr><th id="888">888</th><td><i>/*</i></td></tr>
<tr><th id="889">889</th><td><i> * This structure defines the payload of an ioctl, and is used</i></td></tr>
<tr><th id="890">890</th><td><i> * below.</i></td></tr>
<tr><th id="891">891</th><td><i> *</i></td></tr>
<tr><th id="892">892</th><td><i> * Note that this structure should fit on the memory footprint</i></td></tr>
<tr><th id="893">893</th><td><i> * of iwreq (which is the same as ifreq), which mean a max size of</i></td></tr>
<tr><th id="894">894</th><td><i> * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...</i></td></tr>
<tr><th id="895">895</th><td><i> * You should check this when increasing the structures defined</i></td></tr>
<tr><th id="896">896</th><td><i> * above in this file...</i></td></tr>
<tr><th id="897">897</th><td><i> */</i></td></tr>
<tr><th id="898">898</th><td><b>union</b> <dfn class="type def" id="iwreq_data" title='iwreq_data' data-ref="iwreq_data">iwreq_data</dfn> {</td></tr>
<tr><th id="899">899</th><td>	<i>/* Config - generic */</i></td></tr>
<tr><th id="900">900</th><td>	<em>char</em>		<dfn class="decl field" id="iwreq_data::name" title='iwreq_data::name' data-ref="iwreq_data::name">name</dfn>[<a class="macro" href="if.h.html#31" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];</td></tr>
<tr><th id="901">901</th><td>	<i>/* Name : used to verify the presence of  wireless extensions.</i></td></tr>
<tr><th id="902">902</th><td><i>	 * Name of the protocol/provider... */</i></td></tr>
<tr><th id="903">903</th><td></td></tr>
<tr><th id="904">904</th><td>	<b>struct</b> <a class="type" href="#iw_point" title='iw_point' data-ref="iw_point">iw_point</a>	<dfn class="decl field" id="iwreq_data::essid" title='iwreq_data::essid' data-ref="iwreq_data::essid">essid</dfn>;		<i>/* Extended network name */</i></td></tr>
<tr><th id="905">905</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::nwid" title='iwreq_data::nwid' data-ref="iwreq_data::nwid">nwid</dfn>;		<i>/* network id (or domain - the cell) */</i></td></tr>
<tr><th id="906">906</th><td>	<b>struct</b> <a class="type" href="#iw_freq" title='iw_freq' data-ref="iw_freq">iw_freq</a>	<dfn class="decl field" id="iwreq_data::freq" title='iwreq_data::freq' data-ref="iwreq_data::freq">freq</dfn>;		<i>/* frequency or channel :</i></td></tr>
<tr><th id="907">907</th><td><i>					 * 0-1000 = channel</i></td></tr>
<tr><th id="908">908</th><td><i>					 * &gt; 1000 = frequency in Hz */</i></td></tr>
<tr><th id="909">909</th><td></td></tr>
<tr><th id="910">910</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::sens" title='iwreq_data::sens' data-ref="iwreq_data::sens">sens</dfn>;		<i>/* signal level threshold */</i></td></tr>
<tr><th id="911">911</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::bitrate" title='iwreq_data::bitrate' data-ref="iwreq_data::bitrate">bitrate</dfn>;	<i>/* default bit rate */</i></td></tr>
<tr><th id="912">912</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::txpower" title='iwreq_data::txpower' data-ref="iwreq_data::txpower">txpower</dfn>;	<i>/* default transmit power */</i></td></tr>
<tr><th id="913">913</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::rts" title='iwreq_data::rts' data-ref="iwreq_data::rts">rts</dfn>;		<i>/* RTS threshold threshold */</i></td></tr>
<tr><th id="914">914</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::frag" title='iwreq_data::frag' data-ref="iwreq_data::frag">frag</dfn>;		<i>/* Fragmentation threshold */</i></td></tr>
<tr><th id="915">915</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iwreq_data::mode" title='iwreq_data::mode' data-ref="iwreq_data::mode">mode</dfn>;		<i>/* Operation mode */</i></td></tr>
<tr><th id="916">916</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::retry" title='iwreq_data::retry' data-ref="iwreq_data::retry">retry</dfn>;		<i>/* Retry limits &amp; lifetime */</i></td></tr>
<tr><th id="917">917</th><td></td></tr>
<tr><th id="918">918</th><td>	<b>struct</b> <a class="type" href="#iw_point" title='iw_point' data-ref="iw_point">iw_point</a>	<dfn class="decl field" id="iwreq_data::encoding" title='iwreq_data::encoding' data-ref="iwreq_data::encoding">encoding</dfn>;	<i>/* Encoding stuff : tokens */</i></td></tr>
<tr><th id="919">919</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::power" title='iwreq_data::power' data-ref="iwreq_data::power">power</dfn>;		<i>/* PM duration/timeout */</i></td></tr>
<tr><th id="920">920</th><td>	<b>struct</b> <a class="type" href="#iw_quality" title='iw_quality' data-ref="iw_quality">iw_quality</a> <dfn class="decl field" id="iwreq_data::qual" title='iwreq_data::qual' data-ref="iwreq_data::qual">qual</dfn>;		<i>/* Quality part of statistics */</i></td></tr>
<tr><th id="921">921</th><td></td></tr>
<tr><th id="922">922</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>	<dfn class="decl field" id="iwreq_data::ap_addr" title='iwreq_data::ap_addr' data-ref="iwreq_data::ap_addr">ap_addr</dfn>;	<i>/* Access point address */</i></td></tr>
<tr><th id="923">923</th><td>	<b>struct</b> <a class="type" href="../x86_64-linux-gnu/bits/socket.h.html#sockaddr" title='sockaddr' data-ref="sockaddr">sockaddr</a>	<dfn class="decl field" id="iwreq_data::addr" title='iwreq_data::addr' data-ref="iwreq_data::addr">addr</dfn>;		<i>/* Destination address (hw/mac) */</i></td></tr>
<tr><th id="924">924</th><td></td></tr>
<tr><th id="925">925</th><td>	<b>struct</b> <a class="type" href="#iw_param" title='iw_param' data-ref="iw_param">iw_param</a>	<dfn class="decl field" id="iwreq_data::param" title='iwreq_data::param' data-ref="iwreq_data::param">param</dfn>;		<i>/* Other small parameters */</i></td></tr>
<tr><th id="926">926</th><td>	<b>struct</b> <a class="type" href="#iw_point" title='iw_point' data-ref="iw_point">iw_point</a>	<dfn class="decl field" id="iwreq_data::data" title='iwreq_data::data' data-ref="iwreq_data::data">data</dfn>;		<i>/* Other large parameters */</i></td></tr>
<tr><th id="927">927</th><td>};</td></tr>
<tr><th id="928">928</th><td></td></tr>
<tr><th id="929">929</th><td><i>/*</i></td></tr>
<tr><th id="930">930</th><td><i> * The structure to exchange data for ioctl.</i></td></tr>
<tr><th id="931">931</th><td><i> * This structure is the same as 'struct ifreq', but (re)defined for</i></td></tr>
<tr><th id="932">932</th><td><i> * convenience...</i></td></tr>
<tr><th id="933">933</th><td><i> * Do I need to remind you about structure size (32 octets) ?</i></td></tr>
<tr><th id="934">934</th><td><i> */</i></td></tr>
<tr><th id="935">935</th><td><b>struct</b> <dfn class="type def" id="iwreq" title='iwreq' data-ref="iwreq">iwreq</dfn> {</td></tr>
<tr><th id="936">936</th><td>	<b>union</b></td></tr>
<tr><th id="937">937</th><td>	{</td></tr>
<tr><th id="938">938</th><td>		<em>char</em>	<dfn class="decl field" id="iwreq::(anonymous)::ifrn_name" title='iwreq::(anonymous union)::ifrn_name' data-ref="iwreq::(anonymous)::ifrn_name">ifrn_name</dfn>[<a class="macro" href="if.h.html#31" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];	<i>/* if name, e.g. "eth0" */</i></td></tr>
<tr><th id="939">939</th><td>	} <dfn class="decl field" id="iwreq::ifr_ifrn" title='iwreq::ifr_ifrn' data-ref="iwreq::ifr_ifrn">ifr_ifrn</dfn>;</td></tr>
<tr><th id="940">940</th><td></td></tr>
<tr><th id="941">941</th><td>	<i>/* Data part (defined just above) */</i></td></tr>
<tr><th id="942">942</th><td>	<b>union</b> <a class="type" href="#iwreq_data" title='iwreq_data' data-ref="iwreq_data">iwreq_data</a>	<dfn class="decl field" id="iwreq::u" title='iwreq::u' data-ref="iwreq::u">u</dfn>;</td></tr>
<tr><th id="943">943</th><td>};</td></tr>
<tr><th id="944">944</th><td></td></tr>
<tr><th id="945">945</th><td><i>/* -------------------------- IOCTL DATA -------------------------- */</i></td></tr>
<tr><th id="946">946</th><td><i>/*</i></td></tr>
<tr><th id="947">947</th><td><i> *	For those ioctl which want to exchange mode data that what could</i></td></tr>
<tr><th id="948">948</th><td><i> *	fit in the above structure...</i></td></tr>
<tr><th id="949">949</th><td><i> */</i></td></tr>
<tr><th id="950">950</th><td></td></tr>
<tr><th id="951">951</th><td><i>/*</i></td></tr>
<tr><th id="952">952</th><td><i> *	Range of parameters</i></td></tr>
<tr><th id="953">953</th><td><i> */</i></td></tr>
<tr><th id="954">954</th><td></td></tr>
<tr><th id="955">955</th><td><b>struct</b> <dfn class="type def" id="iw_range" title='iw_range' data-ref="iw_range">iw_range</dfn> {</td></tr>
<tr><th id="956">956</th><td>	<i>/* Informative stuff (to choose between different interface) */</i></td></tr>
<tr><th id="957">957</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_range::throughput" title='iw_range::throughput' data-ref="iw_range::throughput">throughput</dfn>;	<i>/* To give an idea... */</i></td></tr>
<tr><th id="958">958</th><td>	<i>/* In theory this value should be the maximum benchmarked</i></td></tr>
<tr><th id="959">959</th><td><i>	 * TCP/IP throughput, because with most of these devices the</i></td></tr>
<tr><th id="960">960</th><td><i>	 * bit rate is meaningless (overhead an co) to estimate how</i></td></tr>
<tr><th id="961">961</th><td><i>	 * fast the connection will go and pick the fastest one.</i></td></tr>
<tr><th id="962">962</th><td><i>	 * I suggest people to play with Netperf or any benchmark...</i></td></tr>
<tr><th id="963">963</th><td><i>	 */</i></td></tr>
<tr><th id="964">964</th><td></td></tr>
<tr><th id="965">965</th><td>	<i>/* NWID (or domain id) */</i></td></tr>
<tr><th id="966">966</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_range::min_nwid" title='iw_range::min_nwid' data-ref="iw_range::min_nwid">min_nwid</dfn>;	<i>/* Minimal NWID we are able to set */</i></td></tr>
<tr><th id="967">967</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_range::max_nwid" title='iw_range::max_nwid' data-ref="iw_range::max_nwid">max_nwid</dfn>;	<i>/* Maximal NWID we are able to set */</i></td></tr>
<tr><th id="968">968</th><td></td></tr>
<tr><th id="969">969</th><td>	<i>/* Old Frequency (backward compat - moved lower ) */</i></td></tr>
<tr><th id="970">970</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::old_num_channels" title='iw_range::old_num_channels' data-ref="iw_range::old_num_channels">old_num_channels</dfn>;</td></tr>
<tr><th id="971">971</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_range::old_num_frequency" title='iw_range::old_num_frequency' data-ref="iw_range::old_num_frequency">old_num_frequency</dfn>;</td></tr>
<tr><th id="972">972</th><td></td></tr>
<tr><th id="973">973</th><td>	<i>/* Scan capabilities */</i></td></tr>
<tr><th id="974">974</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_range::scan_capa" title='iw_range::scan_capa' data-ref="iw_range::scan_capa">scan_capa</dfn>; 	<i>/* IW_SCAN_CAPA_* bit field */</i></td></tr>
<tr><th id="975">975</th><td></td></tr>
<tr><th id="976">976</th><td>	<i>/* Wireless event capability bitmasks */</i></td></tr>
<tr><th id="977">977</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_range::event_capa" title='iw_range::event_capa' data-ref="iw_range::event_capa">event_capa</dfn>[<var>6</var>];</td></tr>
<tr><th id="978">978</th><td></td></tr>
<tr><th id="979">979</th><td>	<i>/* signal level threshold range */</i></td></tr>
<tr><th id="980">980</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::sensitivity" title='iw_range::sensitivity' data-ref="iw_range::sensitivity">sensitivity</dfn>;</td></tr>
<tr><th id="981">981</th><td></td></tr>
<tr><th id="982">982</th><td>	<i>/* Quality of link &amp; SNR stuff */</i></td></tr>
<tr><th id="983">983</th><td>	<i>/* Quality range (link, level, noise)</i></td></tr>
<tr><th id="984">984</th><td><i>	 * If the quality is absolute, it will be in the range [0 ; max_qual],</i></td></tr>
<tr><th id="985">985</th><td><i>	 * if the quality is dBm, it will be in the range [max_qual ; 0].</i></td></tr>
<tr><th id="986">986</th><td><i>	 * Don't forget that we use 8 bit arithmetics... */</i></td></tr>
<tr><th id="987">987</th><td>	<b>struct</b> <a class="type" href="#iw_quality" title='iw_quality' data-ref="iw_quality">iw_quality</a>	<dfn class="decl field" id="iw_range::max_qual" title='iw_range::max_qual' data-ref="iw_range::max_qual">max_qual</dfn>;	<i>/* Quality of the link */</i></td></tr>
<tr><th id="988">988</th><td>	<i>/* This should contain the average/typical values of the quality</i></td></tr>
<tr><th id="989">989</th><td><i>	 * indicator. This should be the threshold between a "good" and</i></td></tr>
<tr><th id="990">990</th><td><i>	 * a "bad" link (example : monitor going from green to orange).</i></td></tr>
<tr><th id="991">991</th><td><i>	 * Currently, user space apps like quality monitors don't have any</i></td></tr>
<tr><th id="992">992</th><td><i>	 * way to calibrate the measurement. With this, they can split</i></td></tr>
<tr><th id="993">993</th><td><i>	 * the range between 0 and max_qual in different quality level</i></td></tr>
<tr><th id="994">994</th><td><i>	 * (using a geometric subdivision centered on the average).</i></td></tr>
<tr><th id="995">995</th><td><i>	 * I expect that people doing the user space apps will feedback</i></td></tr>
<tr><th id="996">996</th><td><i>	 * us on which value we need to put in each driver... */</i></td></tr>
<tr><th id="997">997</th><td>	<b>struct</b> <a class="type" href="#iw_quality" title='iw_quality' data-ref="iw_quality">iw_quality</a>	<dfn class="decl field" id="iw_range::avg_qual" title='iw_range::avg_qual' data-ref="iw_range::avg_qual">avg_qual</dfn>;	<i>/* Quality of the link */</i></td></tr>
<tr><th id="998">998</th><td></td></tr>
<tr><th id="999">999</th><td>	<i>/* Rates */</i></td></tr>
<tr><th id="1000">1000</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_range::num_bitrates" title='iw_range::num_bitrates' data-ref="iw_range::num_bitrates">num_bitrates</dfn>;	<i>/* Number of entries in the list */</i></td></tr>
<tr><th id="1001">1001</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::bitrate" title='iw_range::bitrate' data-ref="iw_range::bitrate">bitrate</dfn>[<a class="macro" href="#433" title="32" data-ref="_M/IW_MAX_BITRATES">IW_MAX_BITRATES</a>];	<i>/* list, in bps */</i></td></tr>
<tr><th id="1002">1002</th><td></td></tr>
<tr><th id="1003">1003</th><td>	<i>/* RTS threshold */</i></td></tr>
<tr><th id="1004">1004</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::min_rts" title='iw_range::min_rts' data-ref="iw_range::min_rts">min_rts</dfn>;	<i>/* Minimal RTS threshold */</i></td></tr>
<tr><th id="1005">1005</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::max_rts" title='iw_range::max_rts' data-ref="iw_range::max_rts">max_rts</dfn>;	<i>/* Maximal RTS threshold */</i></td></tr>
<tr><th id="1006">1006</th><td></td></tr>
<tr><th id="1007">1007</th><td>	<i>/* Frag threshold */</i></td></tr>
<tr><th id="1008">1008</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::min_frag" title='iw_range::min_frag' data-ref="iw_range::min_frag">min_frag</dfn>;	<i>/* Minimal frag threshold */</i></td></tr>
<tr><th id="1009">1009</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::max_frag" title='iw_range::max_frag' data-ref="iw_range::max_frag">max_frag</dfn>;	<i>/* Maximal frag threshold */</i></td></tr>
<tr><th id="1010">1010</th><td></td></tr>
<tr><th id="1011">1011</th><td>	<i>/* Power Management duration &amp; timeout */</i></td></tr>
<tr><th id="1012">1012</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::min_pmp" title='iw_range::min_pmp' data-ref="iw_range::min_pmp">min_pmp</dfn>;	<i>/* Minimal PM period */</i></td></tr>
<tr><th id="1013">1013</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::max_pmp" title='iw_range::max_pmp' data-ref="iw_range::max_pmp">max_pmp</dfn>;	<i>/* Maximal PM period */</i></td></tr>
<tr><th id="1014">1014</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::min_pmt" title='iw_range::min_pmt' data-ref="iw_range::min_pmt">min_pmt</dfn>;	<i>/* Minimal PM timeout */</i></td></tr>
<tr><th id="1015">1015</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::max_pmt" title='iw_range::max_pmt' data-ref="iw_range::max_pmt">max_pmt</dfn>;	<i>/* Maximal PM timeout */</i></td></tr>
<tr><th id="1016">1016</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::pmp_flags" title='iw_range::pmp_flags' data-ref="iw_range::pmp_flags">pmp_flags</dfn>;	<i>/* How to decode max/min PM period */</i></td></tr>
<tr><th id="1017">1017</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::pmt_flags" title='iw_range::pmt_flags' data-ref="iw_range::pmt_flags">pmt_flags</dfn>;	<i>/* How to decode max/min PM timeout */</i></td></tr>
<tr><th id="1018">1018</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::pm_capa" title='iw_range::pm_capa' data-ref="iw_range::pm_capa">pm_capa</dfn>;	<i>/* What PM options are supported */</i></td></tr>
<tr><th id="1019">1019</th><td></td></tr>
<tr><th id="1020">1020</th><td>	<i>/* Encoder stuff */</i></td></tr>
<tr><th id="1021">1021</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>	<dfn class="decl field" id="iw_range::encoding_size" title='iw_range::encoding_size' data-ref="iw_range::encoding_size">encoding_size</dfn>[<a class="macro" href="#478" title="8" data-ref="_M/IW_MAX_ENCODING_SIZES">IW_MAX_ENCODING_SIZES</a>];	<i>/* Different token sizes */</i></td></tr>
<tr><th id="1022">1022</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>	<dfn class="decl field" id="iw_range::num_encoding_sizes" title='iw_range::num_encoding_sizes' data-ref="iw_range::num_encoding_sizes">num_encoding_sizes</dfn>;	<i>/* Number of entry in the list */</i></td></tr>
<tr><th id="1023">1023</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>	<dfn class="decl field" id="iw_range::max_encoding_tokens" title='iw_range::max_encoding_tokens' data-ref="iw_range::max_encoding_tokens">max_encoding_tokens</dfn>;	<i>/* Max number of tokens */</i></td></tr>
<tr><th id="1024">1024</th><td>	<i>/* For drivers that need a "login/passwd" form */</i></td></tr>
<tr><th id="1025">1025</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>	<dfn class="decl field" id="iw_range::encoding_login_index" title='iw_range::encoding_login_index' data-ref="iw_range::encoding_login_index">encoding_login_index</dfn>;	<i>/* token index for login token */</i></td></tr>
<tr><th id="1026">1026</th><td></td></tr>
<tr><th id="1027">1027</th><td>	<i>/* Transmit power */</i></td></tr>
<tr><th id="1028">1028</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::txpower_capa" title='iw_range::txpower_capa' data-ref="iw_range::txpower_capa">txpower_capa</dfn>;	<i>/* What options are supported */</i></td></tr>
<tr><th id="1029">1029</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_range::num_txpower" title='iw_range::num_txpower' data-ref="iw_range::num_txpower">num_txpower</dfn>;	<i>/* Number of entries in the list */</i></td></tr>
<tr><th id="1030">1030</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::txpower" title='iw_range::txpower' data-ref="iw_range::txpower">txpower</dfn>[<a class="macro" href="#436" title="8" data-ref="_M/IW_MAX_TXPOWER">IW_MAX_TXPOWER</a>];	<i>/* list, in bps */</i></td></tr>
<tr><th id="1031">1031</th><td></td></tr>
<tr><th id="1032">1032</th><td>	<i>/* Wireless Extension version info */</i></td></tr>
<tr><th id="1033">1033</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_range::we_version_compiled" title='iw_range::we_version_compiled' data-ref="iw_range::we_version_compiled">we_version_compiled</dfn>;	<i>/* Must be WIRELESS_EXT */</i></td></tr>
<tr><th id="1034">1034</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_range::we_version_source" title='iw_range::we_version_source' data-ref="iw_range::we_version_source">we_version_source</dfn>;	<i>/* Last update of source */</i></td></tr>
<tr><th id="1035">1035</th><td></td></tr>
<tr><th id="1036">1036</th><td>	<i>/* Retry limits and lifetime */</i></td></tr>
<tr><th id="1037">1037</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::retry_capa" title='iw_range::retry_capa' data-ref="iw_range::retry_capa">retry_capa</dfn>;	<i>/* What retry options are supported */</i></td></tr>
<tr><th id="1038">1038</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::retry_flags" title='iw_range::retry_flags' data-ref="iw_range::retry_flags">retry_flags</dfn>;	<i>/* How to decode max/min retry limit */</i></td></tr>
<tr><th id="1039">1039</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::r_time_flags" title='iw_range::r_time_flags' data-ref="iw_range::r_time_flags">r_time_flags</dfn>;	<i>/* How to decode max/min retry life */</i></td></tr>
<tr><th id="1040">1040</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::min_retry" title='iw_range::min_retry' data-ref="iw_range::min_retry">min_retry</dfn>;	<i>/* Minimal number of retries */</i></td></tr>
<tr><th id="1041">1041</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::max_retry" title='iw_range::max_retry' data-ref="iw_range::max_retry">max_retry</dfn>;	<i>/* Maximal number of retries */</i></td></tr>
<tr><th id="1042">1042</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::min_r_time" title='iw_range::min_r_time' data-ref="iw_range::min_r_time">min_r_time</dfn>;	<i>/* Minimal retry lifetime */</i></td></tr>
<tr><th id="1043">1043</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__s32" title='__s32' data-type='int' data-ref="__s32">__s32</a>		<dfn class="decl field" id="iw_range::max_r_time" title='iw_range::max_r_time' data-ref="iw_range::max_r_time">max_r_time</dfn>;	<i>/* Maximal retry lifetime */</i></td></tr>
<tr><th id="1044">1044</th><td></td></tr>
<tr><th id="1045">1045</th><td>	<i>/* Frequency */</i></td></tr>
<tr><th id="1046">1046</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_range::num_channels" title='iw_range::num_channels' data-ref="iw_range::num_channels">num_channels</dfn>;	<i>/* Number of channels [0; num - 1] */</i></td></tr>
<tr><th id="1047">1047</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>		<dfn class="decl field" id="iw_range::num_frequency" title='iw_range::num_frequency' data-ref="iw_range::num_frequency">num_frequency</dfn>;	<i>/* Number of entry in the list */</i></td></tr>
<tr><th id="1048">1048</th><td>	<b>struct</b> <a class="type" href="#iw_freq" title='iw_freq' data-ref="iw_freq">iw_freq</a>	<dfn class="decl field" id="iw_range::freq" title='iw_range::freq' data-ref="iw_range::freq">freq</dfn>[<a class="macro" href="#427" title="32" data-ref="_M/IW_MAX_FREQUENCIES">IW_MAX_FREQUENCIES</a>];	<i>/* list */</i></td></tr>
<tr><th id="1049">1049</th><td>	<i>/* Note : this frequency list doesn't need to fit channel numbers,</i></td></tr>
<tr><th id="1050">1050</th><td><i>	 * because each entry contain its channel index */</i></td></tr>
<tr><th id="1051">1051</th><td></td></tr>
<tr><th id="1052">1052</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_range::enc_capa" title='iw_range::enc_capa' data-ref="iw_range::enc_capa">enc_capa</dfn>;	<i>/* IW_ENC_CAPA_* bit field */</i></td></tr>
<tr><th id="1053">1053</th><td>};</td></tr>
<tr><th id="1054">1054</th><td></td></tr>
<tr><th id="1055">1055</th><td><i>/*</i></td></tr>
<tr><th id="1056">1056</th><td><i> * Private ioctl interface information</i></td></tr>
<tr><th id="1057">1057</th><td><i> */</i></td></tr>
<tr><th id="1058">1058</th><td></td></tr>
<tr><th id="1059">1059</th><td><b>struct</b> <dfn class="type def" id="iw_priv_args" title='iw_priv_args' data-ref="iw_priv_args">iw_priv_args</dfn> {</td></tr>
<tr><th id="1060">1060</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="iw_priv_args::cmd" title='iw_priv_args::cmd' data-ref="iw_priv_args::cmd">cmd</dfn>;		<i>/* Number of the ioctl to issue */</i></td></tr>
<tr><th id="1061">1061</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_priv_args::set_args" title='iw_priv_args::set_args' data-ref="iw_priv_args::set_args">set_args</dfn>;	<i>/* Type and number of args */</i></td></tr>
<tr><th id="1062">1062</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_priv_args::get_args" title='iw_priv_args::get_args' data-ref="iw_priv_args::get_args">get_args</dfn>;	<i>/* Type and number of args */</i></td></tr>
<tr><th id="1063">1063</th><td>	<em>char</em>		<dfn class="decl field" id="iw_priv_args::name" title='iw_priv_args::name' data-ref="iw_priv_args::name">name</dfn>[<a class="macro" href="if.h.html#31" title="16" data-ref="_M/IFNAMSIZ">IFNAMSIZ</a>];	<i>/* Name of the extension */</i></td></tr>
<tr><th id="1064">1064</th><td>};</td></tr>
<tr><th id="1065">1065</th><td></td></tr>
<tr><th id="1066">1066</th><td><i>/* ----------------------- WIRELESS EVENTS ----------------------- */</i></td></tr>
<tr><th id="1067">1067</th><td><i>/*</i></td></tr>
<tr><th id="1068">1068</th><td><i> * Wireless events are carried through the rtnetlink socket to user</i></td></tr>
<tr><th id="1069">1069</th><td><i> * space. They are encapsulated in the IFLA_WIRELESS field of</i></td></tr>
<tr><th id="1070">1070</th><td><i> * a RTM_NEWLINK message.</i></td></tr>
<tr><th id="1071">1071</th><td><i> */</i></td></tr>
<tr><th id="1072">1072</th><td></td></tr>
<tr><th id="1073">1073</th><td><i>/*</i></td></tr>
<tr><th id="1074">1074</th><td><i> * A Wireless Event. Contains basically the same data as the ioctl...</i></td></tr>
<tr><th id="1075">1075</th><td><i> */</i></td></tr>
<tr><th id="1076">1076</th><td><b>struct</b> <dfn class="type def" id="iw_event" title='iw_event' data-ref="iw_event">iw_event</dfn> {</td></tr>
<tr><th id="1077">1077</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_event::len" title='iw_event::len' data-ref="iw_event::len">len</dfn>;			<i>/* Real length of this stuff */</i></td></tr>
<tr><th id="1078">1078</th><td>	<a class="typedef" href="../asm-generic/int-ll64.h.html#__u16" title='__u16' data-type='unsigned short' data-ref="__u16">__u16</a>		<dfn class="decl field" id="iw_event::cmd" title='iw_event::cmd' data-ref="iw_event::cmd">cmd</dfn>;			<i>/* Wireless IOCTL */</i></td></tr>
<tr><th id="1079">1079</th><td>	<b>union</b> <a class="type" href="#iwreq_data" title='iwreq_data' data-ref="iwreq_data">iwreq_data</a>	<dfn class="decl field" id="iw_event::u" title='iw_event::u' data-ref="iw_event::u">u</dfn>;		<i>/* IOCTL fixed payload */</i></td></tr>
<tr><th id="1080">1080</th><td>};</td></tr>
<tr><th id="1081">1081</th><td></td></tr>
<tr><th id="1082">1082</th><td><i>/* Size of the Event prefix (including padding and alignement junk) */</i></td></tr>
<tr><th id="1083">1083</th><td><u>#define <dfn class="macro" id="_M/IW_EV_LCP_LEN" data-ref="_M/IW_EV_LCP_LEN">IW_EV_LCP_LEN</dfn>	(sizeof(struct iw_event) - sizeof(union iwreq_data))</u></td></tr>
<tr><th id="1084">1084</th><td><i>/* Size of the various events */</i></td></tr>
<tr><th id="1085">1085</th><td><u>#define <dfn class="macro" id="_M/IW_EV_CHAR_LEN" data-ref="_M/IW_EV_CHAR_LEN">IW_EV_CHAR_LEN</dfn>	(IW_EV_LCP_LEN + IFNAMSIZ)</u></td></tr>
<tr><th id="1086">1086</th><td><u>#define <dfn class="macro" id="_M/IW_EV_UINT_LEN" data-ref="_M/IW_EV_UINT_LEN">IW_EV_UINT_LEN</dfn>	(IW_EV_LCP_LEN + sizeof(__u32))</u></td></tr>
<tr><th id="1087">1087</th><td><u>#define <dfn class="macro" id="_M/IW_EV_FREQ_LEN" data-ref="_M/IW_EV_FREQ_LEN">IW_EV_FREQ_LEN</dfn>	(IW_EV_LCP_LEN + sizeof(struct iw_freq))</u></td></tr>
<tr><th id="1088">1088</th><td><u>#define <dfn class="macro" id="_M/IW_EV_PARAM_LEN" data-ref="_M/IW_EV_PARAM_LEN">IW_EV_PARAM_LEN</dfn>	(IW_EV_LCP_LEN + sizeof(struct iw_param))</u></td></tr>
<tr><th id="1089">1089</th><td><u>#define <dfn class="macro" id="_M/IW_EV_ADDR_LEN" data-ref="_M/IW_EV_ADDR_LEN">IW_EV_ADDR_LEN</dfn>	(IW_EV_LCP_LEN + sizeof(struct sockaddr))</u></td></tr>
<tr><th id="1090">1090</th><td><u>#define <dfn class="macro" id="_M/IW_EV_QUAL_LEN" data-ref="_M/IW_EV_QUAL_LEN">IW_EV_QUAL_LEN</dfn>	(IW_EV_LCP_LEN + sizeof(struct iw_quality))</u></td></tr>
<tr><th id="1091">1091</th><td></td></tr>
<tr><th id="1092">1092</th><td><i>/* iw_point events are special. First, the payload (extra data) come at</i></td></tr>
<tr><th id="1093">1093</th><td><i> * the end of the event, so they are bigger than IW_EV_POINT_LEN. Second,</i></td></tr>
<tr><th id="1094">1094</th><td><i> * we omit the pointer, so start at an offset. */</i></td></tr>
<tr><th id="1095">1095</th><td><u>#define <dfn class="macro" id="_M/IW_EV_POINT_OFF" data-ref="_M/IW_EV_POINT_OFF">IW_EV_POINT_OFF</dfn> offsetof(struct iw_point, length)</u></td></tr>
<tr><th id="1096">1096</th><td><u>#define <dfn class="macro" id="_M/IW_EV_POINT_LEN" data-ref="_M/IW_EV_POINT_LEN">IW_EV_POINT_LEN</dfn>	(IW_EV_LCP_LEN + sizeof(struct iw_point) - \</u></td></tr>
<tr><th id="1097">1097</th><td><u>			 IW_EV_POINT_OFF)</u></td></tr>
<tr><th id="1098">1098</th><td></td></tr>
<tr><th id="1099">1099</th><td></td></tr>
<tr><th id="1100">1100</th><td><i>/* Size of the Event prefix when packed in stream */</i></td></tr>
<tr><th id="1101">1101</th><td><u>#define <dfn class="macro" id="_M/IW_EV_LCP_PK_LEN" data-ref="_M/IW_EV_LCP_PK_LEN">IW_EV_LCP_PK_LEN</dfn>	(4)</u></td></tr>
<tr><th id="1102">1102</th><td><i>/* Size of the various events when packed in stream */</i></td></tr>
<tr><th id="1103">1103</th><td><u>#define <dfn class="macro" id="_M/IW_EV_CHAR_PK_LEN" data-ref="_M/IW_EV_CHAR_PK_LEN">IW_EV_CHAR_PK_LEN</dfn>	(IW_EV_LCP_PK_LEN + IFNAMSIZ)</u></td></tr>
<tr><th id="1104">1104</th><td><u>#define <dfn class="macro" id="_M/IW_EV_UINT_PK_LEN" data-ref="_M/IW_EV_UINT_PK_LEN">IW_EV_UINT_PK_LEN</dfn>	(IW_EV_LCP_PK_LEN + sizeof(__u32))</u></td></tr>
<tr><th id="1105">1105</th><td><u>#define <dfn class="macro" id="_M/IW_EV_FREQ_PK_LEN" data-ref="_M/IW_EV_FREQ_PK_LEN">IW_EV_FREQ_PK_LEN</dfn>	(IW_EV_LCP_PK_LEN + sizeof(struct iw_freq))</u></td></tr>
<tr><th id="1106">1106</th><td><u>#define <dfn class="macro" id="_M/IW_EV_PARAM_PK_LEN" data-ref="_M/IW_EV_PARAM_PK_LEN">IW_EV_PARAM_PK_LEN</dfn>	(IW_EV_LCP_PK_LEN + sizeof(struct iw_param))</u></td></tr>
<tr><th id="1107">1107</th><td><u>#define <dfn class="macro" id="_M/IW_EV_ADDR_PK_LEN" data-ref="_M/IW_EV_ADDR_PK_LEN">IW_EV_ADDR_PK_LEN</dfn>	(IW_EV_LCP_PK_LEN + sizeof(struct sockaddr))</u></td></tr>
<tr><th id="1108">1108</th><td><u>#define <dfn class="macro" id="_M/IW_EV_QUAL_PK_LEN" data-ref="_M/IW_EV_QUAL_PK_LEN">IW_EV_QUAL_PK_LEN</dfn>	(IW_EV_LCP_PK_LEN + sizeof(struct iw_quality))</u></td></tr>
<tr><th id="1109">1109</th><td><u>#define <dfn class="macro" id="_M/IW_EV_POINT_PK_LEN" data-ref="_M/IW_EV_POINT_PK_LEN">IW_EV_POINT_PK_LEN</dfn>	(IW_EV_LCP_PK_LEN + 4)</u></td></tr>
<tr><th id="1110">1110</th><td></td></tr>
<tr><th id="1111">1111</th><td><u>#<span data-ppcond="11">endif</span> /* _LINUX_WIRELESS_H */</u></td></tr>
<tr><th id="1112">1112</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../qtbase-6.5.0/src/network/kernel/qnetworkinterface_linux.cpp.html'>qtbase-6.5.0/src/network/kernel/qnetworkinterface_linux.cpp</a><br/>Generated on <em>2024-Jun-13</em> from project include<br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
