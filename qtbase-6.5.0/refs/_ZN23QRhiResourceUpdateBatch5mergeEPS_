<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1561' type='void QRhiResourceUpdateBatch::merge(QRhiResourceUpdateBatch * other)'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5951' ll='5954' type='void QRhiResourceUpdateBatch::merge(QRhiResourceUpdateBatch * other)'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5914'>/*!
    Copies all queued operations from the \a other batch into this one.

    \note \a other may no longer contain valid data after the merge operation,
    and must not be submitted, but it will still need to be released by calling
    release().

    This allows for a convenient pattern where resource updates that are
    already known during the initialization step are collected into a batch
    that is then merged into another when starting to first render pass later
    on:

    \badcode
    void init()
    {
        ...
        initialUpdates = rhi-&gt;nextResourceUpdateBatch();
        initialUpdates-&gt;uploadStaticBuffer(vbuf, vertexData);
        initialUpdates-&gt;uploadStaticBuffer(ibuf, indexData);
        ...
    }

    void render()
    {
        ...
        QRhiResourceUpdateBatch *resUpdates = rhi-&gt;nextResourceUpdateBatch();
        if (initialUpdates) {
            resUpdates-&gt;merge(initialUpdates);
            initialUpdates-&gt;release();
            initialUpdates = nullptr;
        }
        resUpdates-&gt;updateDynamicBuffer(...);
        ...
        cb-&gt;beginPass(rt, clearCol, clearDs, resUpdates);
    }
    \endcode
 */</doc>
