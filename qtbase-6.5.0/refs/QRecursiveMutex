<def f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='187' ll='228'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='189' c='_ZN15QRecursiveMutexC1ERKS_'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='189' c='_ZN15QRecursiveMutexaSERKS_'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='189' c='_ZN15QRecursiveMutexaSERKS_'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='189' c='_ZN15QRecursiveMutexC1EOS_'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='189' c='_ZN15QRecursiveMutexaSEOS_'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='189' c='_ZN15QRecursiveMutexaSEOS_'/>
<size>24</size>
<fun r='_ZN15QRecursiveMutexC1ERKS_'/>
<fun r='_ZN15QRecursiveMutexC1EOS_'/>
<mbr r='QRecursiveMutex::owner' o='0' t='QAtomicPointer&lt;void&gt;'/>
<mbr r='QRecursiveMutex::count' o='64' t='uint'/>
<mbr r='QRecursiveMutex::mutex' o='128' t='QMutex'/>
<fun r='_ZN15QRecursiveMutexC1Ev'/>
<fun r='_ZN15QRecursiveMutexD1Ev'/>
<fun r='_ZN15QRecursiveMutex4lockEv'/>
<fun r='_ZN15QRecursiveMutex7tryLockEi'/>
<fun r='_ZN15QRecursiveMutex6unlockEv'/>
<fun r='_ZN15QRecursiveMutex8try_lockEv'/>
<fun r='_ZN15QRecursiveMutex12try_lock_forENSt6chrono8durationIT_T0_EE'/>
<fun r='_ZN15QRecursiveMutex14try_lock_untilENSt6chrono10time_pointIT_T0_EE'/>
<use f='qtbase-6.5.0/src/corelib/io/qresource.cpp' l='168'/>
<use f='qtbase-6.5.0/src/corelib/io/qresource.cpp' l='173' c='_ZL13resourceMutexv'/>
<size>1</size>
<use f='qtbase-6.5.0/src/corelib/plugin/qfactoryloader.cpp' l='128'/>
<size>24</size>
<doc f='qtbase-6.5.0/src/corelib/thread/qmutex.cpp' l='223'>/*!
    \class QRecursiveMutex
    \inmodule QtCore
    \since 5.14
    \brief The QRecursiveMutex class provides access serialization between threads.

    \threadsafe

    \ingroup thread

    The QRecursiveMutex class is a mutex, like QMutex, with which it is
    API-compatible. It differs from QMutex by accepting lock() calls from
    the same thread any number of times. QMutex would deadlock in this situation.

    QRecursiveMutex is much more expensive to construct and operate on, so
    use a plain QMutex whenever you can. Sometimes, one public function,
    however, calls another public function, and they both need to lock the
    same mutex. In this case, you have two options:

    \list
    \li Factor the code that needs mutex protection into private functions,
    which assume that the mutex is held when they are called, and lock a
    plain QMutex in the public functions before you call the private
    implementation ones.
    \li Or use a recursive mutex, so it doesn&apos;t matter that the first public
    function has already locked the mutex when the second one wishes to do so.
    \endlist

    \sa QMutex, QMutexLocker, QReadWriteLock, QSemaphore, QWaitCondition
*/</doc>
<fun r='_ZN15QRecursiveMutexD1Ev'/>
<fun r='_ZN15QRecursiveMutex7tryLockEi'/>
<fun r='_ZN15QRecursiveMutex6unlockEv'/>
<use f='qtbase-6.5.0/src/gui/kernel/qopenglcontext_p.h' l='115'/>
<use f='qtbase-6.5.0/src/gui/kernel/qopenglcontext_p.h' l='154'/>
<size>24</size>
<use f='qtbase-6.5.0/src/gui/text/freetype/qfontengine_ft_p.h' l='90'/>
<size>24</size>
<use f='qtbase-6.5.0/src/gui/text/qfont.cpp' l='234' c='_Z21qt_fontdatabase_mutexv'/>
<size>24</size>
<use f='qtbase-6.5.0/src/gui/text/qfontdatabase.cpp' l='515'/>
<use f='qtbase-6.5.0/src/gui/text/qfontdatabase.cpp' l='526' c='_Z21qt_fontdatabase_mutexv'/>
<size>24</size>
<use f='qtbase-6.5.0/src/gui/util/qdesktopservices.cpp' l='30'/>
<size>24</size>
<use f='qtbase-6.5.0/src/network/access/qnetworkaccessbackend.cpp' l='34'/>
<size>24</size>
<use f='qtbase-6.5.0/src/network/kernel/qnetworkproxy.cpp' l='304'/>
<size>24</size>
<use f='qtbase-6.5.0/src/network/socket/qsocks5socketengine.cpp' l='293'/>
<size>24</size>
