<def f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='98' type='bool QCborStreamReader::isMap() const'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='116' u='c' c='_ZNK17QCborStreamReader11isContainerEv'/>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='336'>/*!
   \fn bool QCborStreamReader::isMap() const

   Returns true if the type of the current element is a map (that is, if type()
   returns QCborStreamReader::Map). If this function returns true, you may call
   enterContainer() to begin parsing that container.

   When the current element is a map, you may also call isLengthKnown() to
   find out if the map&apos;s size is explicit in the CBOR stream. If it is, that
   size can be obtained by calling length().

   The following example pre-allocates a QVariantMap given the map&apos;s size
   for more efficient decoding:

   \snippet code/src_corelib_serialization_qcborstream.cpp 26

   The example above uses a function called \c readElementAsString to read the
   map&apos;s keys and obtain a string. That is because CBOR maps may contain any
   type as keys, not just strings. User code needs to either perform this
   conversion, reject non-string keys, or instead use a different container
   besides \l QVariantMap and \l QVariantHash. For example, if the map is
   expected to contain integer keys, which is recommended as it reduces stream
   size and parsing, the correct container would be \c{\l{QMap}&lt;int, QVariant&gt;}
   or \c{\l{QHash}&lt;int, QVariant&gt;}.

   \note The code above does not validate that the length is a sensible value.
   If the input stream reports that the length is 1 billion elements, the above
   function will try to allocate some 24 GB or more of RAM, which can lead to a
   crash.

   \sa type(), isArray(), isLengthKnown(), length(), enterContainer(), leaveContainer()
 */</doc>
