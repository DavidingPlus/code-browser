<dec f='qtbase-6.5.0/src/corelib/serialization/qcbormap.h' l='195' type='QCborValueRef QCborMap::operator[](const QString &amp; key)'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcbormap.h' l='284' u='c' c='_ZN8QCborMap6insertERK7QStringRK10QCborValue'/>
<def f='qtbase-6.5.0/src/corelib/serialization/qcbormap.cpp' l='638' ll='641' type='QCborValueRef QCborMap::operator[](const QString &amp; key)'/>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcbormap.cpp' l='612'>/*!
    \overload

    Returns a QCborValueRef to the value in this map that corresponds to key \a
    key.

    QCborValueRef has the exact same API as \l QCborValue, with one important
    difference: if you assign new values to it, this map will be updated with
    that new value.

    If the map did not have a key equal to \a key, one is inserted and this
    function returns a reference to the new value, which will be a QCborValue
    with an undefined value. For that reason, it is not possible with this
    function to tell apart the situation where the key was not present from the
    situation where the key was mapped to an undefined value.

    If the map contains more than one key equal to \a key, it is undefined
    which one the return will reference. QCborMap does not allow inserting
    duplicate keys, but it is possible to create such a map by decoding a CBOR
    stream with them. They are usually not permitted and having duplicate keys
    is usually an indication of a problem in the sender.

    \sa value(const QString &amp;), find(const QString &amp;), contains(const QString &amp;),
        remove(const QString &amp;), operator[](qint64), operator[](QLatin1StringView),
        operator[](const QCborValue &amp;)
 */</doc>
