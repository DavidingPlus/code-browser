<inh f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1620' c='QRhiInitParams'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhigles2_p.h' l='28' ll='38'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstorerhisupport.cpp' l='72' c='_ZN23QBackingStoreRhiSupport6createEv'/>
<size>32</size>
<fun r='_ZN19QRhiGles2InitParamsC1Ev'/>
<mbr r='QRhiGles2InitParams::format' o='0' t='QSurfaceFormat'/>
<mbr r='QRhiGles2InitParams::fallbackSurface' o='64' t='QSurface *'/>
<mbr r='QRhiGles2InitParams::window' o='128' t='QWindow *'/>
<mbr r='QRhiGles2InitParams::shareContext' o='192' t='QOpenGLContext *'/>
<fun r='_ZN19QRhiGles2InitParams18newFallbackSurfaceERK14QSurfaceFormat'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2_p_p.h' l='721' c='_ZN9QRhiGles2C1EP19QRhiGles2InitParamsP22QRhiGles2NativeHandles'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5557' c='_ZN4QRhi6createENS_14ImplementationEP14QRhiInitParams6QFlagsINS_4FlagEEP17QRhiNativeHandles'/>
<size>32</size>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='500' c='_ZN9QRhiGles2C1EP19QRhiGles2InitParamsP22QRhiGles2NativeHandles'/>
<size>32</size>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='28'>/*!
    \class QRhiGles2InitParams
    \internal
    \inmodule QtGui
    \brief OpenGL specific initialization parameters.

    An OpenGL-based QRhi needs an already created QSurface that can be used in
    combination with QOpenGLContext. Most commonly, this is a QOffscreenSurface
    in practice. Additionally, while optional, it is recommended that the QWindow
    the first QRhiSwapChain will target is passed in as well.

    \badcode
        QOffscreenSurface *fallbackSurface = QRhiGles2InitParams::newFallbackSurface();
        QRhiGles2InitParams params;
        params.fallbackSurface = fallbackSurface;
        params.window = window;
        rhi = QRhi::create(QRhi::OpenGLES2, &amp;params);
    \endcode

    By default QRhi creates a QOpenGLContext on its own. This approach works
    well in most cases, included threaded scenarios, where there is a dedicated
    QRhi for each rendering thread. As there will be a QOpenGLContext for each
    QRhi, the OpenGL context requirements (a context can only be current on one
    thread) are satisfied. The implicitly created context is destroyed
    automatically together with the QRhi.

    The QSurfaceFormat for the context is specified in \l format. The
    constructor sets this to QSurfaceFormat::defaultFormat() so applications
    that call QSurfaceFormat::setDefaultFormat() with the appropriate settings
    before the constructor runs will not need to change value of \l format.

    \note Remember to set the depth and stencil buffer sizes to 24 and 8 when
    the renderer relies on depth or stencil testing, either in the global
    default QSurfaceFormat, or, alternatively, separately in all the involved
    QSurfaceFormat instances: in \l format, the format argument passed to
    newFallbackSurface(), and on any QWindow that is used with the QRhi.

    A QSurface has to be specified in \l fallbackSurface. In order to prevent
    mistakes in threaded situations, this is never created automatically by the
    QRhi because, like QWindow, instances of QSurface subclasses can often be
    created on the gui/main thread only.

    As a convenience, applications can use newFallbackSurface() which creates
    and returns a QOffscreenSurface that is compatible with the QOpenGLContext
    that is going to be created by the QRhi afterwards. Note that the ownership
    of the returned QOffscreenSurface is transferred to the caller and the QRhi
    will not destroy it.

    \note With the OpenGL backend, QRhiSwapChain can only target QWindow
    instances that have their surface type set to QSurface::OpenGLSurface or
    QSurface::RasterGLSurface.

    \note \l window is optional. It is recommended to specify it whenever
    possible, in order to avoid problems on multi-adapter and multi-screen
    systems. When \l window is not set, the very first
    QOpenGLContext::makeCurrent() happens with \l fallbackSurface which may be
    an invisible window on some platforms (for example, Windows) and that may
    trigger unexpected problems in some cases.

    In case resource sharing with an existing QOpenGLContext is desired, \l
    shareContext can be set to an existing QOpenGLContext. Alternatively,
    Qt::AA_ShareOpenGLContexts is honored as well, when enabled.

    \section2 Working with existing OpenGL contexts

    When interoperating with another graphics engine, it may be necessary to
    get a QRhi instance that uses the same OpenGL context. This can be achieved
    by passing a pointer to a QRhiGles2NativeHandles to QRhi::create(). The
    \l{QRhiGles2NativeHandles::context}{context} must be set to a non-null
    value.

    An alternative approach is to create a QOpenGLContext that
    \l{QOpenGLContext::setShareContext()}{shares resources} with the other
    engine&apos;s context and passing in that context via QRhiGles2NativeHandles.

    The QRhi does not take ownership of the QOpenGLContext passed in via
    QRhiGles2NativeHandles.
 */</doc>
<fun r='_ZN19QRhiGles2InitParamsC1Ev'/>
<fun r='_ZN19QRhiGles2InitParams18newFallbackSurfaceERK14QSurfaceFormat'/>
