<dec f='qtbase-6.5.0/src/corelib/text/qbytearray.h' l='338' type='ushort QByteArray::toUShort(bool * ok = nullptr, int base = 10) const'/>
<def f='qtbase-6.5.0/src/corelib/text/qbytearray.cpp' l='3955' ll='3958' type='ushort QByteArray::toUShort(bool * ok = nullptr, int base = 10) const'/>
<doc f='qtbase-6.5.0/src/corelib/text/qbytearray.cpp' l='3930'>/*!
    Returns the byte array converted to an \c {unsigned short} using base \a
    base, which is ten by default. Bases 0 and 2 through 36 are supported, using
    letters for digits beyond 9; A is ten, B is eleven and so on.

    If \a base is 0, the base is determined automatically using the following
    rules: If the byte array begins with &quot;0x&quot;, it is assumed to be hexadecimal
    (base 16); otherwise, if it begins with &quot;0b&quot;, it is assumed to be binary
    (base 2); otherwise, if it begins with &quot;0&quot;, it is assumed to be octal
    (base 8); otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If \a ok is not \nullptr, failure is reported by setting *\a{ok}
    to \c false, and success by setting *\a{ok} to \c true.

    \note The conversion of the number is performed in the default C locale,
    regardless of the user&apos;s locale. Use QLocale to perform locale-aware
    conversions between numbers and strings.

    \note Support for the &quot;0b&quot; prefix was added in Qt 6.4.

    \sa number()
*/</doc>
<use f='qtbase-6.5.0/src/corelib/time/qtimezoneprivate.cpp' l='768' u='c' c='_ZN19QUtcTimeZonePrivate19offsetFromUtcStringERK10QByteArray'/>
