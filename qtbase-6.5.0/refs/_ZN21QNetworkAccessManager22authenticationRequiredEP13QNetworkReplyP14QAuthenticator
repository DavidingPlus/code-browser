<dec f='qtbase-6.5.0/src/network/access/qnetworkaccessmanager.h' l='119' type='void QNetworkAccessManager::authenticationRequired(QNetworkReply * reply, QAuthenticator * authenticator)'/>
<use f='qtbase-6.5.0/src/network/access/qnetworkaccessmanager.cpp' l='1531' u='c' c='_ZN28QNetworkAccessManagerPrivate22authenticationRequiredEP14QAuthenticatorP13QNetworkReplybR4QUrlPS4_b'/>
<doc f='qtbase-6.5.0/src/network/access/qnetworkaccessmanager.cpp' l='274'>/*!
    \fn void QNetworkAccessManager::authenticationRequired(QNetworkReply *reply, QAuthenticator *authenticator)

    This signal is emitted whenever a final server requests
    authentication before it delivers the requested contents. The slot
    connected to this signal should fill the credentials for the
    contents (which can be determined by inspecting the \a reply
    object) in the \a authenticator object.

    QNetworkAccessManager will cache the credentials internally and
    will send the same values if the server requires authentication
    again, without emitting the authenticationRequired() signal. If it
    rejects the credentials, this signal will be emitted again.

    \note To have the request not send credentials you must not call
    setUser() or setPassword() on the \a authenticator object. This
    will result in the \l finished() signal being emitted with a
    \l QNetworkReply with error \l {QNetworkReply::} {AuthenticationRequiredError}.

    \note It is not possible to use a QueuedConnection to connect to
    this signal, as the connection will fail if the authenticator has
    not been filled in with new information when the signal returns.

    \sa proxyAuthenticationRequired(), QAuthenticator::setUser(), QAuthenticator::setPassword()
*/</doc>
