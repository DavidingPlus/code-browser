<dec f='qtbase-6.5.0/src/corelib/thread/qthreadpool.h' l='42' type='void QThreadPool::startOnReservedThread(QRunnable * runnable)'/>
<def f='qtbase-6.5.0/src/corelib/thread/qthreadpool.cpp' l='784' ll='799' type='void QThreadPool::startOnReservedThread(QRunnable * runnable)'/>
<use f='qtbase-6.5.0/src/corelib/thread/qthreadpool.cpp' l='813' u='c' c='_ZN11QThreadPool21startOnReservedThreadESt8functionIFvvEE'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qthreadpool.cpp' l='765'>/*!
    Releases a thread previously reserved with reserveThread() and uses it
    to run \a runnable.

    Note that the thread pool takes ownership of the \a runnable if
    \l{QRunnable::autoDelete()}{runnable-&gt;autoDelete()} returns \c true,
    and the \a runnable will be deleted automatically by the thread
    pool after the \l{QRunnable::run()}{runnable-&gt;run()} returns. If
    \l{QRunnable::autoDelete()}{runnable-&gt;autoDelete()} returns \c false,
    ownership of \a runnable remains with the caller. Note that
    changing the auto-deletion on \a runnable after calling this
    functions results in undefined behavior.

    \note Calling this when no threads are reserved results in
    undefined behavior.

    \since 6.3
    \sa reserveThread(), start()
*/</doc>
