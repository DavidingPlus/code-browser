<dec f='qtbase-6.5.0/src/corelib/thread/qthread.h' l='38' type='void QThread::~QThread()'/>
<ovr f='qtbase-6.5.0/src/corelib/thread/qthread.cpp' l='138' c='_ZN14QAdoptedThreadD1Ev'/>
<inh f='qtbase-6.5.0/src/corelib/kernel/qobject.h' l='99' c='_ZN7QObjectD1Ev'/>
<def f='qtbase-6.5.0/src/corelib/thread/qthread.cpp' l='455' ll='470' type='void QThread::~QThread()'/>
<ovr f='qtbase-6.5.0/src/corelib/thread/qthread.cpp' l='1203' c='_ZN19QThreadCreateThreadD1Ev'/>
<ovr f='qtbase-6.5.0/src/corelib/thread/qthread.cpp' l='1241' c='_ZN13QDaemonThreadD1Ev'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qthread.cpp' l='437'>/*!
    Destroys the QThread.

    Note that deleting a QThread object will not stop the execution
    of the thread it manages. Deleting a running QThread (i.e.
    isFinished() returns \c false) will result in a program
    crash. Wait for the finished() signal before deleting the
    QThread.

    Since Qt 6.3, it is allowed to delete a QThread instance created by
    a call to QThread::create() even if the corresponding thread is
    still running. In such a case, Qt will post an interruption request
    to that thread (via requestInterruption()); will ask the thread&apos;s
    event loop (if any) to quit (via quit()); and will block until the
    thread has finished.

    \sa create(), isInterruptionRequested(), exec(), quit()
*/</doc>
<ovr f='qtbase-6.5.0/src/gui/itemmodels/qfileinfogatherer.cpp' l='58' c='_ZN17QFileInfoGathererD1Ev'/>
<ovr f='qtbase-6.5.0/src/testlib/qtestcase.cpp' l='1272' c='_ZN5QTest8WatchDogD1Ev'/>
