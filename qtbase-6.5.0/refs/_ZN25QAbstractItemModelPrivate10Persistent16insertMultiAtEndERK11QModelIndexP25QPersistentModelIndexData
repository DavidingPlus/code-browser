<dec f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel_p.h' l='115' type='void QAbstractItemModelPrivate::Persistent::insertMultiAtEnd(const QModelIndex &amp; key, QPersistentModelIndexData * data)'/>
<use f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='884' u='c' c='_ZN25QAbstractItemModelPrivate12rowsInsertedERK11QModelIndexii'/>
<use f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='966' u='c' c='_ZN25QAbstractItemModelPrivate21movePersistentIndexesERK5QListIP25QPersistentModelIndexDataEiRK11QModelIndexN2Qt11OrientationE'/>
<use f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='1029' u='c' c='_ZN25QAbstractItemModelPrivate11rowsRemovedERK11QModelIndexii'/>
<use f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='1069' u='c' c='_ZN25QAbstractItemModelPrivate15columnsInsertedERK11QModelIndexii'/>
<use f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='1115' u='c' c='_ZN25QAbstractItemModelPrivate14columnsRemovedERK11QModelIndexii'/>
<use f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='3427' u='c' c='_ZN18QAbstractItemModel21changePersistentIndexERK11QModelIndexS2_'/>
<use f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='3464' u='c' c='_ZN18QAbstractItemModel25changePersistentIndexListERK5QListI11QModelIndexES4_'/>
<def f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='4146' ll='4156' type='void QAbstractItemModelPrivate::Persistent::insertMultiAtEnd(const QModelIndex &amp; key, QPersistentModelIndexData * data)'/>
<doc f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='4136'>/*!
    \internal
    QMultiHash::insert inserts the value before the old value. and find() return the new value.
    We need insertMultiAtEnd because we don&apos;t want to overwrite the old one, which should be removed later

    There should be only one instance QPersistentModelIndexData per index, but in some intermediate state there may be
    severals of PersistantModelIndex pointing to the same index, but one is already updated, and the other one is not.
    This make sure than when updating the first one we don&apos;t overwrite the second one in the hash, and the second one
    will be updated right later.
 */</doc>
