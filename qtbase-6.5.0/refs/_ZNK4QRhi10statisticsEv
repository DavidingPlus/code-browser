<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1820' type='QRhiStats QRhi::statistics() const'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='7262' ll='7265' type='QRhiStats QRhi::statistics() const'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='7227'>/*!
    Gathers and returns statistics about the timings and allocations of
    graphics resources.

    Data about memory allocations is only available with some backends, where
    such operations are under Qt&apos;s control. With graphics APIs where there is
    no lower level control over resource memory allocations, this will never be
    supported and all relevant fields in the results are 0.

    With Vulkan in particular, the values are valid always, and are queried
    from the underlying memory allocator library. This gives an insight into
    the memory requirements of the active buffers and textures.

    Additional data, such as the total time in milliseconds spent in graphics
    and compute pipeline creation (which usually involves shader compilation or
    cache lookups, and potentially expensive processing) is available with most
    backends.

    \note The elapsed times for operations such as pipeline creation may be
    affected by various factors. The results should not be compared between
    different backends since the concept of &quot;pipelines&quot; and what exactly
    happens under the hood during, for instance, a call to
    QRhiGraphicsPipeline::create(), differ greatly between graphics APIs and
    their implementations.

    \note Additionally, many drivers will likely employ various caching
    strategies for shaders, programs, pipelines. (independently of Qt&apos;s own
    similar facilities, such as setPipelineCacheData() or the OpenGL-specific
    program binary disk cache). Because such internal behavior is transparent
    to the API client, Qt and QRhi have no knowledge or control over the exact
    caching strategy, persistency, invalidation of the cached data, etc. When
    reading timings, such as the time spent on pipeline creation, the potential
    presence and unspecified behavior of driver-level caching mechanisms should
    be kept in mind.
 */</doc>
