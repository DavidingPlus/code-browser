<dec f='qtbase-6.5.0/src/gui/image/qimage.h' l='88' type='void QImage::QImage(const uchar * data, int width, int height, QImage::Format format, QImageCleanupFunction cleanupFunction = nullptr, void * cleanupInfo = nullptr)'/>
<def f='qtbase-6.5.0/src/gui/image/qimage.cpp' l='894' ll='898' type='void QImage::QImage(const uchar * data, int width, int height, QImage::Format format, QImageCleanupFunction cleanupFunction = nullptr, void * cleanupInfo = nullptr)'/>
<use f='qtbase-6.5.0/src/gui/image/qimage.cpp' l='4909' u='c' c='_ZNK6QImage11transformedERK10QTransformN2Qt18TransformationModeE'/>
<doc f='qtbase-6.5.0/src/gui/image/qimage.cpp' l='869'>/*!
    Constructs an image with the given \a width, \a height and \a
    format, that uses an existing read-only memory buffer, \a
    data. The \a width and \a height must be specified in pixels, \a
    data must be 32-bit aligned, and each scanline of data in the
    image must also be 32-bit aligned.

    The buffer must remain valid throughout the life of the QImage and
    all copies that have not been modified or otherwise detached from
    the original buffer. The image does not delete the buffer at destruction.
    You can provide a function pointer \a cleanupFunction along with an
    extra pointer \a cleanupInfo that will be called when the last copy
    is destroyed.

    If \a format is an indexed color format, the image color table is
    initially empty and must be sufficiently expanded with
    setColorCount() or setColorTable() before the image is used.

    Unlike the similar QImage constructor that takes a non-const data buffer,
    this version will never alter the contents of the buffer.  For example,
    calling QImage::bits() will return a deep copy of the image, rather than
    the buffer passed to the constructor.  This allows for the efficiency of
    constructing a QImage from raw data, without the possibility of the raw
    data being changed.
*/</doc>
