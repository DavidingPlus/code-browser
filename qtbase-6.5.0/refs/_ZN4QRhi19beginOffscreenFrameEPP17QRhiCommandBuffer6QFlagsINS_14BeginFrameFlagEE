<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1783' type='QRhi::FrameOpResult QRhi::beginOffscreenFrame(QRhiCommandBuffer ** cb, QRhi::BeginFrameFlags flags = {})'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='7688' ll='7698' type='QRhi::FrameOpResult QRhi::beginOffscreenFrame(QRhiCommandBuffer ** cb, QRhi::BeginFrameFlags flags = {})'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='7649'>/*!
    Starts a new offscreen frame. Provides a command buffer suitable for
    recording rendering commands in \a cb. \a flags is used to indicate
    certain special cases, just like with beginFrame().

    \note The QRhiCommandBuffer stored to *cb is not owned by the caller.

    Rendering without a swapchain is possible as well. The typical use case is
    to use it in completely offscreen applications, e.g. to generate image
    sequences by rendering and reading back without ever showing a window.

    Usage in on-screen applications (so beginFrame, endFrame,
    beginOffscreenFrame, endOffscreenFrame, beginFrame, ...) is possible too
    but it does reduce parallelism so it should be done only infrequently.

    Offscreen frames do not let the CPU - potentially - generate another frame
    while the GPU is still processing the previous one. This has the side
    effect that if readbacks are scheduled, the results are guaranteed to be
    available once endOffscreenFrame() returns. That is not the case with
    frames targeting a swapchain.

    The skeleton of rendering a frame without a swapchain and then reading the
    frame contents back could look like the following:

    \badcode
          QRhiReadbackResult rbResult;
          QRhiCommandBuffer *cb;
          beginOffscreenFrame(&amp;cb);
          beginPass
          ...
          u = nextResourceUpdateBatch();
          u-&gt;readBackTexture(rb, &amp;rbResult);
          endPass(u);
          endOffscreenFrame();
          // image data available in rbResult
   \endcode

   \sa endOffscreenFrame(), beginFrame()
 */</doc>
