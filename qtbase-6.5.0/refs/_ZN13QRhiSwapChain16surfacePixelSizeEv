<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1421' type='QSize QRhiSwapChain::surfacePixelSize()'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='475' u='c' c='_ZN30QBackingStoreDefaultCompositor5flushEP21QPlatformBackingStoreP4QRhiP13QRhiSwapChainP7QWindowdRK7QRegionRK6QPointP20QPlatformTextureListb'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='4799'>/*!
    \fn QSize QRhiSwapChain::surfacePixelSize()

    \return The size of the window&apos;s associated surface or layer.

    \warning Do not assume this is the same as \c{QWindow::size() *
    QWindow::devicePixelRatio()}. With some graphics APIs and windowing system
    interfaces (for example, Vulkan) there is a theoretical possibility for a
    surface to assume a size different from the associated window. To support
    these cases, rendering logic must always base size-derived calculations
    (such as, viewports) on the size reported from QRhiSwapChain, and never on
    the size queried from QWindow.

    \note Can also be called before createOrResize(), if at least window() is
    already set) This in combination with currentPixelSize() allows to detect
    when a swapchain needs to be resized. However, watch out for the fact that
    the size of the underlying native object (surface, layer, or similar) is
    &quot;live&quot;, so whenever this function is called, it returns the latest value
    reported by the underlying implementation, without any atomicity guarantee.
    Therefore, using this function to determine pixel sizes for graphics
    resources that are used in a frame is strongly discouraged. Rely on
    currentPixelSize() instead which returns a size that is atomic and will not
    change between createOrResize() invocations.

    \note For depth-stencil buffers used in combination with the swapchain&apos;s
    color buffers, it is strongly recommended to rely on the automatic sizing
    and rebuilding behavior provided by the
    QRhiRenderBuffer:UsedWithSwapChainOnly flag. Avoid querying the surface
    size via this function just to get a size that can be passed to
    QRhiRenderBuffer::setPixelSize() as that would suffer from the lack of
    atomicity as described above.

    \sa currentPixelSize()
  */</doc>
<ovr f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='5942' c='_ZN15QGles2SwapChain16surfacePixelSizeEv'/>
<ovr f='qtbase-6.5.0/src/gui/rhi/qrhinull.cpp' l='960' c='_ZN14QNullSwapChain16surfacePixelSizeEv'/>
