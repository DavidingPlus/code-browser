<dec f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='30' type='bool QReadWriteLock::tryLockForWrite(int timeout)'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.cpp' l='263' u='c' c='_ZN14QReadWriteLock12lockForWriteEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.cpp' l='283' u='c' c='_ZN14QReadWriteLock15tryLockForWriteEv'/>
<def f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.cpp' l='305' ll='352' type='bool QReadWriteLock::tryLockForWrite(int timeout)'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.cpp' l='286'>/*! \overload

    Attempts to lock for writing. This function returns \c true if the
    lock was obtained; otherwise it returns \c false. If another thread
    has locked for reading or writing, this function will wait for at
    most \a timeout milliseconds for the lock to become available.

    Note: Passing a negative number as the \a timeout is equivalent to
    calling lockForWrite(), i.e. this function will wait forever until
    lock can be locked for writing when \a timeout is negative.

    If the lock was obtained, the lock must be unlocked with unlock()
    before another thread can successfully lock it.

    It is not possible to lock for write if the thread already has
    locked for read.

    \sa unlock(), lockForWrite()
*/</doc>
