<inh f='qtbase-6.5.0/src/widgets/itemviews/qitemeditorfactory.h' l='19' c='QItemEditorCreatorBase'/>
<def f='qtbase-6.5.0/src/widgets/itemviews/qitemeditorfactory.h' l='29' ll='38'/>
<use f='qtbase-6.5.0/src/widgets/itemviews/qitemeditorfactory.h' l='56' c='_ZN18QItemEditorCreatorC1ERK10QByteArray'/>
<fun r='_ZN18QItemEditorCreatorC1ERK10QByteArray'/>
<fun r='_ZNK18QItemEditorCreator12createWidgetEP7QWidget'/>
<fun r='_ZNK18QItemEditorCreator17valuePropertyNameEv'/>
<mbr r='QItemEditorCreator::propertyName' t='QByteArray'/>
<fun r='_ZN18QItemEditorCreatorC1ERK10QByteArray'/>
<doc f='qtbase-6.5.0/src/widgets/itemviews/qitemeditorfactory.cpp' l='410'>/*!
    \class QItemEditorCreator
    \brief The QItemEditorCreator class makes it possible to create
           item editor creator bases without subclassing
           QItemEditorCreatorBase.

    \since 4.2
    \ingroup model-view
    \inmodule QtWidgets

    QItemEditorCreator is a convenience template class. It uses
    the template class to create editors for QItemEditorFactory.
    This way, it is not necessary to subclass
    QItemEditorCreatorBase.

    \snippet code/src_gui_itemviews_qitemeditorfactory.cpp 1

    The constructor takes the name of the property that contains the
    editing data. QStyledItemDelegate can then access the property by name
    when it sets and retrieves editing data. Only use this class if
    your editor does not define a user property (using the USER
    keyword in the Q_PROPERTY macro).  If the widget has a user
    property, you should use QStandardItemEditorCreator instead.

    \sa QItemEditorCreatorBase, QStandardItemEditorCreator,
        QItemEditorFactory, {Color Editor Factory Example}
*/</doc>
