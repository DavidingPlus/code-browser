<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1802' type='QMatrix4x4 QRhi::clipSpaceCorrMatrix() const'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='526' u='c' c='_ZN30QBackingStoreDefaultCompositor5flushEP21QPlatformBackingStoreP4QRhiP13QRhiSwapChainP7QWindowdRK7QRegionRK6QPointP20QPlatformTextureListb'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6966' ll='6969' type='QMatrix4x4 QRhi::clipSpaceCorrMatrix() const'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6949'>/*!
    \return a matrix that can be used to allow applications keep using
    OpenGL-targeted vertex data and perspective projection matrices (such as,
    the ones generated by QMatrix4x4::perspective()), regardless of the active
    QRhi backend.

    In a typical renderer, once \c{this_matrix * mvp} is used instead of just
    \c mvp, vertex data with Y up and viewports with depth range 0 - 1 can be
    used without considering what backend (and so graphics API) is going to be
    used at run time. This way branching based on isYUpInNDC() and
    isClipDepthZeroToOne() can be avoided (although such logic may still become
    required when implementing certain advanced graphics techniques).

    See
    \l{https://matthewwellings.com/blog/the-new-vulkan-coordinate-system/}{this
    page} for a discussion of the topic from Vulkan perspective.
 */</doc>
