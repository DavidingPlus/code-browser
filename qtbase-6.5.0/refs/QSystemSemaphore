<def f='qtbase-6.5.0/src/corelib/kernel/qsystemsemaphore.h' l='18' ll='56'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsystemsemaphore.h' l='54' c='_ZN16QSystemSemaphoreC1ERKS_'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsystemsemaphore.h' l='54' c='_ZN16QSystemSemaphoreaSERKS_'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsystemsemaphore.h' l='54' c='_ZN16QSystemSemaphoreaSERKS_'/>
<size>8</size>
<smbr r='QSystemSemaphore::staticMetaObject' t='const QMetaObject'/>
<fun r='_ZN16QSystemSemaphore26qt_check_for_QGADGET_macroEv'/>
<fun r='_ZN16QSystemSemaphore18qt_static_metacallEP7QObjectN11QMetaObject4CallEiPPv'/>
<fun r='_ZN16QSystemSemaphore2trEPKcS1_i'/>
<fun r='_ZN16QSystemSemaphoreC1ERK7QStringiNS_10AccessModeE'/>
<fun r='_ZN16QSystemSemaphoreD1Ev'/>
<fun r='_ZN16QSystemSemaphore6setKeyERK7QStringiNS_10AccessModeE'/>
<fun r='_ZNK16QSystemSemaphore3keyEv'/>
<fun r='_ZN16QSystemSemaphore7acquireEv'/>
<fun r='_ZN16QSystemSemaphore7releaseEi'/>
<fun r='_ZNK16QSystemSemaphore5errorEv'/>
<fun r='_ZNK16QSystemSemaphore11errorStringEv'/>
<fun r='_ZN16QSystemSemaphoreC1ERKS_'/>
<mbr r='QSystemSemaphore::d' o='0' t='QScopedPointer&lt;QSystemSemaphorePrivate&gt;'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory_p.h' l='92'/>
<size>8</size>
<doc f='qtbase-6.5.0/src/corelib/kernel/qsystemsemaphore.cpp' l='12'>/*!
  \class QSystemSemaphore
  \inmodule QtCore
  \since 4.4

  \brief The QSystemSemaphore class provides a general counting system semaphore.

  A semaphore is a generalization of a mutex. While a mutex can be
  locked only once, a semaphore can be acquired multiple times.
  Typically, a semaphore is used to protect a certain number of
  identical resources.

  Like its lighter counterpart QSemaphore, a QSystemSemaphore can be
  accessed from multiple \l {QThread} {threads}. Unlike QSemaphore, a
  QSystemSemaphore can also be accessed from multiple \l {QProcess}
  {processes}. This means QSystemSemaphore is a much heavier class, so
  if your application doesn&apos;t need to access your semaphores across
  multiple processes, you will probably want to use QSemaphore.

  Semaphores support two fundamental operations, acquire() and release():

  acquire() tries to acquire one resource. If there isn&apos;t a resource
  available, the call blocks until a resource becomes available. Then
  the resource is acquired and the call returns.

  release() releases one resource so it can be acquired by another
  process. The function can also be called with a parameter n &gt; 1,
  which releases n resources.

  A system semaphore is created with a string key that other processes
  can use to use the same semaphore.

  Example: Create a system semaphore
  \snippet code/src_corelib_kernel_qsystemsemaphore.cpp 0

  A typical application of system semaphores is for controlling access
  to a circular buffer shared by a producer process and a consumer
  processes.

  \section1 Platform-Specific Behavior

  When using this class, be aware of the following platform
  differences:

  \b{Windows:} QSystemSemaphore does not own its underlying system
  semaphore. Windows owns it. This means that when all instances of
  QSystemSemaphore for a particular key have been destroyed, either by
  having their destructors called, or because one or more processes
  crash, Windows removes the underlying system semaphore.

  \b{Unix:}

  \list
  \li QSystemSemaphore owns the underlying system semaphore
  in Unix systems. This means that the last process having an instance of
  QSystemSemaphore for a particular key must remove the underlying
  system semaphore in its destructor. If the last process crashes
  without running the QSystemSemaphore destructor, Unix does not
  automatically remove the underlying system semaphore, and the
  semaphore survives the crash. A subsequent process that constructs a
  QSystemSemaphore with the same key will then be given the existing
  system semaphore. In that case, if the QSystemSemaphore constructor
  has specified its \l {QSystemSemaphore::AccessMode} {access mode} as
  \l {QSystemSemaphore::} {Open}, its initial resource count will not
  be reset to the one provided but remain set to the value it received
  in the crashed process. To protect against this, the first process
  to create a semaphore for a particular key (usually a server), must
  pass its \l {QSystemSemaphore::AccessMode} {access mode} as \l
  {QSystemSemaphore::} {Create}, which will force Unix to reset the
  resource count in the underlying system semaphore.

  \li When a process using QSystemSemaphore terminates for
  any reason, Unix automatically reverses the effect of all acquire
  operations that were not released. Thus if the process acquires a
  resource and then exits without releasing it, Unix will release that
  resource.

  \endlist

  \b{Apple platforms:} Sandboxed applications (including apps
  shipped through the Apple App Store) require the key to
  be in the form \c {&lt;application group identifier&gt;/&lt;custom identifier&gt;},
  as documented \l {https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html#//apple_ref/doc/uid/TP40011183-CH3-SW24}
  {here} and \l {https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_application-groups}
  {here}, and the key length is limited to 30 characters.

  \sa QSharedMemory, QSemaphore
 */</doc>
<fun r='_ZN16QSystemSemaphoreC1ERK7QStringiNS_10AccessModeE'/>
<fun r='_ZN16QSystemSemaphoreD1Ev'/>
<fun r='_ZN16QSystemSemaphore6setKeyERK7QStringiNS_10AccessModeE'/>
<fun r='_ZNK16QSystemSemaphore3keyEv'/>
<fun r='_ZN16QSystemSemaphore7acquireEv'/>
<fun r='_ZN16QSystemSemaphore7releaseEi'/>
<fun r='_ZNK16QSystemSemaphore5errorEv'/>
<fun r='_ZNK16QSystemSemaphore11errorStringEv'/>
<use f='qtbase-6.5.0/src/tools/androidtestrunner/main.cpp' l='481'/>
<size>8</size>
