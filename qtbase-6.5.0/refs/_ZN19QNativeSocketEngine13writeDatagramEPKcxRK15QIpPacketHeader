<dec f='qtbase-6.5.0/src/network/socket/qnativesocketengine_p.h' l='91' type='qint64 QNativeSocketEngine::writeDatagram(const char * data, qint64 len, const QIpPacketHeader &amp; )'/>
<inh f='qtbase-6.5.0/src/network/socket/qabstractsocketengine_p.h' l='125' c='_ZN21QAbstractSocketEngine13writeDatagramEPKcxRK15QIpPacketHeader'/>
<def f='qtbase-6.5.0/src/network/socket/qnativesocketengine.cpp' l='859' ll='867' type='qint64 QNativeSocketEngine::writeDatagram(const char * data, qint64 size, const QIpPacketHeader &amp; header)'/>
<doc f='qtbase-6.5.0/src/network/socket/qnativesocketengine.cpp' l='837'>/*!
    Writes a datagram of size \a size bytes to the socket from
    \a data to the destination contained in \a header, and returns the
    number of bytes written, or -1 if an error occurred. If \a header
    contains other settings like hop limit or source address, this function
    will try to pass them to the operating system too, but will not
    indicate an error if it could not pass them.

    Only one datagram is sent, and if there is too much data to fit
    into a single datagram, the operation will fail and error()
    will return QAbstractSocket::DatagramTooLargeError. Operating systems impose an
    upper limit to the size of a datagram, but this size is different
    on almost all platforms. Sending large datagrams is in general
    disadvised, as even if they are sent successfully, they are likely
    to be fragmented before arriving at their destination.

    Experience has shown that it is in general safe to send IPv4 datagrams
    no larger than 512 bytes or IPv6 datagrams no larger than 1280 (the
    minimum MTU).

    \sa readDatagram()
*/</doc>
