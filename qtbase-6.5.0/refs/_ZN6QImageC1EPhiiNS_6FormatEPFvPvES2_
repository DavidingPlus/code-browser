<dec f='qtbase-6.5.0/src/gui/image/qimage.h' l='87' type='void QImage::QImage(uchar * data, int width, int height, QImage::Format format, QImageCleanupFunction cleanupFunction = nullptr, void * cleanupInfo = nullptr)'/>
<def f='qtbase-6.5.0/src/gui/image/qimage.cpp' l='863' ll='867' type='void QImage::QImage(uchar * data, int width, int height, QImage::Format format, QImageCleanupFunction cleanupFunction = nullptr, void * cleanupInfo = nullptr)'/>
<doc f='qtbase-6.5.0/src/gui/image/qimage.cpp' l='846'>/*!
    Constructs an image with the given \a width, \a height and \a
    format, that uses an existing memory buffer, \a data. The \a width
    and \a height must be specified in pixels, \a data must be 32-bit aligned,
    and each scanline of data in the image must also be 32-bit aligned.

    The buffer must remain valid throughout the life of the QImage and
    all copies that have not been modified or otherwise detached from
    the original buffer. The image does not delete the buffer at destruction.
    You can provide a function pointer \a cleanupFunction along with an
    extra pointer \a cleanupInfo that will be called when the last copy
    is destroyed.

    If \a format is an indexed color format, the image color table is
    initially empty and must be sufficiently expanded with
    setColorCount() or setColorTable() before the image is used.
*/</doc>
<use f='qtbase-6.5.0/src/gui/text/freetype/qfontengine_ft.cpp' l='2013' u='c' c='_ZN13QFontEngineFT14bitmapForGlyphEjRK11QFixedPointRK10QTransformRK6QColor'/>
<use f='qtbase-6.5.0/src/gui/text/freetype/qfontengine_ft.cpp' l='2015' u='c' c='_ZN13QFontEngineFT14bitmapForGlyphEjRK11QFixedPointRK10QTransformRK6QColor'/>
