<dec f='qtbase-6.5.0/src/dbus/qdbusservicewatcher.h' l='58' type='void QDBusServiceWatcher::serviceOwnerChanged(const QString &amp; service, const QString &amp; oldOwner, const QString &amp; newOwner)'/>
<use f='qtbase-6.5.0/src/dbus/qdbusservicewatcher.cpp' l='52' u='c' c='_ZN26QDBusServiceWatcherPrivate22_q_serviceOwnerChangedERK7QStringS2_S2_'/>
<doc f='qtbase-6.5.0/src/dbus/qdbusservicewatcher.cpp' l='184'>/*!
    \fn void QDBusServiceWatcher::serviceOwnerChanged(const QString &amp;serviceName, const QString &amp;oldOwner, const QString &amp;newOwner)

    This signal is emitted whenever this object detects that there was a
    service ownership change relating to the \a serviceName service. The \a
    oldOwner parameter contains the old owner name and \a newOwner is the new
    owner. Both \a oldOwner and \a newOwner are unique connection names.

    Note that this signal is also emitted whenever the \a serviceName service
    was registered or unregistered. If it was registered, \a oldOwner will
    contain an empty string, whereas if it was unregistered, \a newOwner will
    contain an empty string.

    If you need only to find out if the service is registered or unregistered
    only, without being notified that the ownership changed, consider using
    the specific modes for those operations. This class is more efficient if
    you use the more specific modes.

    \sa serviceRegistered(), serviceUnregistered()
*/</doc>
