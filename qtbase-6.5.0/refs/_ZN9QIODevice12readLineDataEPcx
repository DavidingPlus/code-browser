<dec f='qtbase-6.5.0/src/corelib/io/qiodevice.h' l='122' type='qint64 QIODevice::readLineData(char * data, qint64 maxlen)'/>
<ovr f='qtbase-6.5.0/src/corelib/io/qfiledevice.cpp' l='392' c='_ZN11QFileDevice12readLineDataEPcx'/>
<use f='qtbase-6.5.0/src/corelib/io/qfiledevice.cpp' l='404' u='c' c='_ZN11QFileDevice12readLineDataEPcx'/>
<use f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='1396' u='c' c='_ZN16QIODevicePrivate8readLineEPcx'/>
<use f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='1397' u='c' c='_ZN16QIODevicePrivate8readLineEPcx'/>
<def f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='1500' ll='1522' type='qint64 QIODevice::readLineData(char * data, qint64 maxSize)'/>
<doc f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='1483'>/*!
    Reads up to \a maxSize characters into \a data and returns the
    number of characters read.

    This function is called by readLine(), and provides its base
    implementation, using getChar(). Buffered devices can improve the
    performance of readLine() by reimplementing this function.

    readLine() appends a &apos;\\0&apos; byte to \a data; readLineData() does not
    need to do this.

    If you reimplement this function, be careful to return the correct
    value: it should return the number of bytes read in this line,
    including the terminating newline, or 0 if there is no line to be
    read at this point. If an error occurs, it should return -1 if and
    only if no bytes were read. Reading past EOF is considered an error.
*/</doc>
<ovr f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2413' c='_ZN15QAbstractSocket12readLineDataEPcx'/>
<use f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2415' u='c' c='_ZN15QAbstractSocket12readLineDataEPcx'/>
<ovr f='qtbase-6.5.0/src/network/socket/qlocalsocket_unix.cpp' l='450' c='_ZN12QLocalSocket12readLineDataEPcx'/>
