<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1639' type='8'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='434'>\value EnablePipelineCacheDataSave Enables retrieving the pipeline cache
    contents, where applicable. When not set, pipelineCacheData() will return
    an empty blob always. With backends where retrieving and restoring the
    pipeline cache contents is not supported, the flag has no effect and the
    serialized cache data is always empty. The flag provides an opt-in
    mechanism because the cost of maintaining the related data structures is
    not insignificant with some backends. With Vulkan this feature maps
    directly to VkPipelineCache, vkGetPipelineCacheData and
    VkPipelineCacheCreateInfo::pInitialData. With D3D11 there is no real
    pipline cache, but the results of HLSL-&gt;DXBC compilations are stored and
    can be serialized/deserialized via this mechanism. This allows skipping the
    time consuming D3DCompile() in future runs of the applications for shaders
    that come with HLSL source instead of offline pre-compiled bytecode. This
    can provide a huge boost in startup and load times, if there is a lot of
    HLSL source compilation happening. With OpenGL the &quot;pipeline cache&quot; is
    simulated by retrieving and loading shader program binaries (if supported
    by the driver). With OpenGL there are additional, disk-based caching
    mechanisms for shader/program binaries provided by Qt. Writing to those may
    get disabled whenever this flag is set since storing program binaries to
    multiple caches is not sensible.</doc>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='5729' u='r' c='_ZN22QGles2GraphicsPipeline6createEv'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='5740' u='r' c='_ZN22QGles2GraphicsPipeline6createEv'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='5846' u='r' c='_ZN21QGles2ComputePipeline6createEv'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='5857' u='r' c='_ZN21QGles2ComputePipeline6createEv'/>
