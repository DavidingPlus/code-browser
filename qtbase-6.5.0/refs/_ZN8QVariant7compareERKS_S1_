<dec f='qtbase-6.5.0/src/corelib/kernel/qvariant.h' l='463' type='static QPartialOrdering QVariant::compare(const QVariant &amp; lhs, const QVariant &amp; rhs)'/>
<def f='qtbase-6.5.0/src/corelib/kernel/qvariant.cpp' l='2381' ll='2395' type='static QPartialOrdering QVariant::compare(const QVariant &amp; lhs, const QVariant &amp; rhs)'/>
<doc f='qtbase-6.5.0/src/corelib/kernel/qvariant.cpp' l='2359'>/*!
    Compares the objects at \a lhs and \a rhs for ordering.

    Returns QPartialOrdering::Unordered if comparison is not supported
    or the values are unordered. Otherwise, returns
    QPartialOrdering::Less, QPartialOrdering::Equivalent or
    QPartialOrdering::Greater if \a lhs is less than, equivalent
    to or greater than \a rhs, respectively.

    If the variants contain data with a different metatype, the values are considered
    unordered unless they are both of numeric or pointer types, where regular numeric or
    pointer comparison rules will be used.
    \note: If a numeric comparison is done and at least one value is NaN, QPartialOrdering::Unordered
    is returned.

    If both variants contain data of the same metatype, the method will use the
    QMetaType::compare method to determine the ordering of the two variants, which can
    also indicate that it can&apos;t establish an ordering between the two values.

    \since 6.0
    \sa QMetaType::compare(), QMetaType::isOrdered()
*/</doc>
