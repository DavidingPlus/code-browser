<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1488' type='void QRhiCommandBuffer::beginPass(QRhiRenderTarget * rt, const QColor &amp; colorClearValue, const QRhiDepthStencilClearValue &amp; depthStencilClearValue, QRhiResourceUpdateBatch * resourceUpdates = nullptr, QRhiCommandBuffer::BeginPassFlags flags = {})'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='585' u='c' c='_ZN30QBackingStoreDefaultCompositor5flushEP21QPlatformBackingStoreP4QRhiP13QRhiSwapChainP7QWindowdRK7QRegionRK6QPointP20QPlatformTextureListb'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6386' ll='6393' type='void QRhiCommandBuffer::beginPass(QRhiRenderTarget * rt, const QColor &amp; colorClearValue, const QRhiDepthStencilClearValue &amp; depthStencilClearValue, QRhiResourceUpdateBatch * resourceUpdates = nullptr, QRhiCommandBuffer::BeginPassFlags flags = {})'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6337'>/*!
    Records starting a new render pass targeting the render target \a rt.

    \a resourceUpdates, when not null, specifies a resource update batch that
    is to be committed and then released.

    The color and depth/stencil buffers of the render target are normally
    cleared. The clear values are specified in \a colorClearValue and \a
    depthStencilClearValue. The exception is when the render target was created
    with QRhiTextureRenderTarget::PreserveColorContents and/or
    QRhiTextureRenderTarget::PreserveDepthStencilContents. The clear values are
    ignored then.

    \note Enabling preserved color or depth contents leads to decreased
    performance depending on the underlying hardware. Mobile GPUs with tiled
    architecture benefit from not having to reload the previous contents into
    the tile buffer. Similarly, a QRhiTextureRenderTarget with a QRhiTexture as
    the depth buffer is less efficient than a QRhiRenderBuffer since using a
    depth texture triggers requiring writing the data out to it, while with
    renderbuffers this is not needed (as the API does not allow sampling or
    reading from a renderbuffer).

    \note Do not assume that any state or resource bindings persist between
    passes.

    \note The QRhiCommandBuffer&apos;s \c set and \c draw functions can only be
    called inside a pass. Also, with the exception of setGraphicsPipeline(),
    they expect to have a pipeline set already on the command buffer.
    Unspecified issues may arise otherwise, depending on the backend.

    If \a rt is a QRhiTextureRenderTarget, beginPass() performs a check to see
    if the texture and renderbuffer objects referenced from the render target
    are up-to-date. This is similar to what setShaderResources() does for
    QRhiShaderResourceBindings. If any of the attachments had been rebuilt
    since QRhiTextureRenderTarget::create(), an implicit call to create() is
    made on \a rt. Therefore, if \a rt has a QRhiTexture color attachment \c
    texture, and one needs to make the texture a different size, the following
    is then valid:
    \badcode
      rt = rhi-&gt;newTextureRenderTarget({ { texture } });
      rt-&gt;create();
      ...
      texture-&gt;setPixelSize(new_size);
      texture-&gt;create();
      cb-&gt;beginPass(rt, ...); // this is ok, no explicit rt-&gt;create() is required before
    \endcode

    \sa endPass()
 */</doc>
