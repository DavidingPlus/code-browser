<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1800' type='bool QRhi::isClipDepthZeroToOne() const'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6944' ll='6947' type='bool QRhi::isClipDepthZeroToOne() const'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6924'>/*!
    \return \c true if the underlying graphics API uses depth range [0, 1] in
    clip space.

    In practice this is \c false for OpenGL only, because OpenGL uses a
    post-projection depth range of [-1, 1]. (not to be confused with the
    NDC-to-window mapping controlled by glDepthRange(), which uses a range of
    [0, 1], unless overridden by the QRhiViewport) In some OpenGL versions
    glClipControl() could be used to change this, but the OpenGL backend of
    QRhi does not use that function as it is not available in OpenGL ES or
    OpenGL versions lower than 4.5.

    \note clipSpaceCorrMatrix() includes the corresponding adjustment in its
    returned matrix. Therefore, many users of QRhi do not need to take any
    further measures apart from pre-multiplying their projection matrices with
    clipSpaceCorrMatrix(). However, some graphics techniques, such as, some
    types of shadow mapping, involve working with and outputting depth values
    in the shaders. These will need to query and take the value of this
    function into account as appropriate.
 */</doc>
