<def f='qtbase-6.5.0/src/corelib/text/qstringtokenizer.h' l='245' ll='329'/>
<use f='qtbase-6.5.0/src/corelib/text/qstringtokenizer.h' l='345'/>
<use f='qtbase-6.5.0/src/corelib/text/qstringtokenizer.h' l='345' c='{deductionguideforQStringTokenizer}'/>
<use f='qtbase-6.5.0/src/corelib/text/qstringtokenizer.h' l='345' c='{deductionguideforQStringTokenizer}'/>
<use f='qtbase-6.5.0/src/corelib/text/qstringtokenizer.h' l='345' c='{deductionguideforQStringTokenizer}'/>
<use f='qtbase-6.5.0/src/corelib/text/qstringtokenizer.h' l='345' c='{deductionguideforQStringTokenizer}'/>
<use f='qtbase-6.5.0/src/corelib/text/qstringtokenizer.h' l='345' c='{deductionguideforQStringTokenizer}'/>
<fun r='_ZN16QStringTokenizerC1ET_T0_N2Qt15CaseSensitivityE6QFlagsINS2_18SplitBehaviorFlagsEE'/>
<fun r='_ZN16QStringTokenizerC1ET_T0_6QFlagsIN2Qt18SplitBehaviorFlagsEENS3_15CaseSensitivityE'/>
<fun r='_ZNKR16QStringTokenizer11toContainerEOTL0__'/>
<fun r='_ZNKO16QStringTokenizer11toContainerEOTL0__'/>
<doc f='qtbase-6.5.0/src/corelib/text/qstringtokenizer.cpp' l='9'>/*!
    \class QStringTokenizer
    \inmodule QtCore
    \since 6.0
    \brief The QStringTokenizer class splits strings into tokens along given separators.
    \reentrant
    \ingroup tools
    \ingroup string-processing

    Splits a string into substrings wherever a given separator occurs,
    returning a (lazily constructed) list of those strings. If the separator does
    not match anywhere in the string, produces a single-element list
    containing this string.  If the separator is empty,
    QStringTokenizer produces an empty string, followed by each of the
    string&apos;s characters, followed by another empty string. The two
    enumerations Qt::SplitBehavior and Qt::CaseSensitivity further
    control the output.

    QStringTokenizer drives QStringView::tokenize(), but, at least with a
    recent compiler, you can use it directly, too:

    \code
    for (auto it : QStringTokenizer{string, separator})
        use(*it);
    \endcode

    \note You should never, ever, name the template arguments of a
    QStringTokenizer explicitly.  If you can use C++17 Class Template
    Argument Deduction (CTAD), you may write
    \c{QStringTokenizer{string, separator}} (without template
    arguments).  If you can&apos;t use C++17 CTAD, you must use the
    QStringView::split() or QLatin1StringView::split() member functions
    and store the return value only in \c{auto} variables:

    \code
    auto result = string.split(sep);
    \endcode

    This is because the template arguments of QStringTokenizer have a
    very subtle dependency on the specific string and separator types
    from with which they are constructed, and they don&apos;t usually
    correspond to the actual types passed.

    \section1 Lazy Sequences

    QStringTokenizer acts as a so-called lazy sequence, that is, each
    next element is only computed once you ask for it. Lazy sequences
    have the advantage that they only require O(1) memory. They have
    the disadvantage that, at least for QStringTokenizer, they only
    allow forward, not random-access, iteration.

    The intended use-case is that you just plug it into a ranged for loop:

    \code
    for (auto it : QStringTokenizer{string, separator})
        use(*it);
    \endcode

    or a C++20 ranged algorithm:

    \code
    std::ranges::for_each(QStringTokenizer{string, separator},
                          [] (auto token) { use(token); });
    \endcode

    \section1 End Sentinel

    The QStringTokenizer iterators cannot be used with classical STL
    algorithms, because those require iterator/iterator pairs, while
    QStringTokenizer uses sentinels. That is, it uses a different
    type, QStringTokenizer::sentinel, to mark the end of the
    range. This improves performance, because the sentinel is an empty
    type. Sentinels are supported from C++17 (for ranged for)
    and C++20 (for algorithms using the new ranges library).

    \section1 Temporaries

    QStringTokenizer is very carefully designed to avoid dangling
    references. If you construct a tokenizer from a temporary string
    (an rvalue), that argument is stored internally, so the referenced
    data isn&apos;t deleted before it is tokenized:

    \code
    auto tok = QStringTokenizer{widget.text(), u&apos;,&apos;};
    // return value of `widget.text()` is destroyed, but content was moved into `tok`
    for (auto e : tok)
       use(e);
    \endcode

    If you pass named objects (lvalues), then QStringTokenizer does
    not store a copy. You are responsible to keep the named object&apos;s
    data around for longer than the tokenizer operates on it:

    \code
    auto text = widget.text();
    auto tok = QStringTokenizer{text, u&apos;,&apos;};
    text.clear();      // destroy content of `text`
    for (auto e : tok) // ERROR: `tok` references deleted data!
        use(e);
    \endcode

    \sa QStringView::split(), QString::split(), QRegularExpression
*/</doc>
