<def f='qtbase-6.5.0/src/3rdparty/tinycbor/src/cbor.h' l='336' ll='347'/>
<use f='qtbase-6.5.0/src/3rdparty/tinycbor/src/cbor.h' l='348'/>
<size>24</size>
<mbr r='CborValue::parser' o='0' t='const CborParser *'/>
<mbr r='CborValue::source' o='64' t='union (unnamed union at /home/lzx0626/DavidingPlus/qtbase/src/corelib/../3rdparty/tinycbor/src/cbor.h:339:5)'/>
<mbr r='CborValue::remaining' o='128' t='uint32_t'/>
<mbr r='CborValue::extra' o='160' t='uint16_t'/>
<mbr r='CborValue::type' o='176' t='uint8_t'/>
<mbr r='CborValue::flags' o='184' t='uint8_t'/>
<doc f='qtbase-6.5.0/src/3rdparty/tinycbor/src/cborparser.c' l='128'>/**
 * \struct CborValue
 *
 * This type contains one value parsed from the CBOR stream. Each CborValue
 * behaves as an iterator in a StAX-style parser.
 *
 * \if privatedocs
 * Implementation details: the CborValue contains these fields:
 * \list
 *   \li ptr: pointer to the actual data
 *   \li flags: flags from the decoder
 *   \li extra: partially decoded integer value (0, 1 or 2 bytes)
 *   \li remaining: remaining items in this collection after this item or UINT32_MAX if length is unknown
 * \endlist
 * \endif
 */</doc>
