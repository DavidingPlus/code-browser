<def f='qtbase-6.5.0/src/corelib/kernel/qeventloop.h' l='54' ll='65'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qeventloop.h' l='63' c='_ZN16QEventLoopLockerC1ERKS_'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qeventloop.h' l='63' c='_ZN16QEventLoopLockeraSERKS_'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qeventloop.h' l='63' c='_ZN16QEventLoopLockeraSERKS_'/>
<size>8</size>
<fun r='_ZN16QEventLoopLockerC1Ev'/>
<fun r='_ZN16QEventLoopLockerC1EP10QEventLoop'/>
<fun r='_ZN16QEventLoopLockerC1EP7QThread'/>
<fun r='_ZN16QEventLoopLockerD1Ev'/>
<fun r='_ZN16QEventLoopLockerC1ERKS_'/>
<mbr r='QEventLoopLocker::d_ptr' o='0' t='QEventLoopLockerPrivate *'/>
<doc f='qtbase-6.5.0/src/corelib/kernel/qeventloop.cpp' l='348'>/*!
    \class QEventLoopLocker
    \inmodule QtCore
    \brief The QEventLoopLocker class provides a means to quit an event loop when it is no longer needed.
    \since 5.0

    The QEventLoopLocker operates on particular objects - either a QCoreApplication
    instance, a QEventLoop instance or a QThread instance.

    This makes it possible to, for example, run a batch of jobs with an event loop
    and exit that event loop after the last job is finished. That is accomplished
    by keeping a QEventLoopLocker with each job instance.

    The variant which operates on QCoreApplication makes it possible to finish
    asynchronously running jobs after the last gui window has been closed. This
    can be useful for example for running a job which uploads data to a network.

    \sa QEventLoop, QCoreApplication
*/</doc>
<fun r='_ZN16QEventLoopLockerC1Ev'/>
<fun r='_ZN16QEventLoopLockerC1EP10QEventLoop'/>
<fun r='_ZN16QEventLoopLockerC1EP7QThread'/>
<fun r='_ZN16QEventLoopLockerD1Ev'/>
