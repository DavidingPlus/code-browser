<dec f='qtbase-6.5.0/src/sql/kernel/qsqlquery.h' l='83' type='bool QSqlQuery::execBatch(QSqlQuery::BatchExecutionMode mode = ValuesAsRows)'/>
<def f='qtbase-6.5.0/src/sql/kernel/qsqlquery.cpp' l='1072' ll='1076' type='bool QSqlQuery::execBatch(QSqlQuery::BatchExecutionMode mode = ValuesAsRows)'/>
<doc f='qtbase-6.5.0/src/sql/kernel/qsqlquery.cpp' l='1029'>/*!
    \since 4.2

  Executes a previously prepared SQL query in a batch. All the bound
  parameters have to be lists of variants. If the database doesn&apos;t
  support batch executions, the driver will simulate it using
  conventional exec() calls.

  Returns \c true if the query is executed successfully; otherwise
  returns \c false.

  Example:

  \snippet code/src_sql_kernel_qsqlquery.cpp 2

  The example above inserts four new rows into \c myTable:

  \snippet code/src_sql_kernel_qsqlquery_snippet.cpp 3

  To bind NULL values, a null QVariant of the relevant type has to be
  added to the bound QVariantList; for example, \c
  {QVariant(QMetaType::fromType&lt;QString&gt;())} should be used if you are
  using strings.

  \note Every bound QVariantList must contain the same amount of
  variants.

  \note The type of the QVariants in a list must not change. For
  example, you cannot mix integer and string variants within a
  QVariantList.

  The \a mode parameter indicates how the bound QVariantList will be
  interpreted.  If \a mode is \c ValuesAsRows, every variant within
  the QVariantList will be interpreted as a value for a new row. \c
  ValuesAsColumns is a special case for the Oracle driver. In this
  mode, every entry within a QVariantList will be interpreted as
  array-value for an IN or OUT value within a stored procedure.  Note
  that this will only work if the IN or OUT value is a table-type
  consisting of only one column of a basic type, for example \c{TYPE
  myType IS TABLE OF VARCHAR(64) INDEX BY BINARY_INTEGER;}

  \sa prepare(), bindValue(), addBindValue()
*/</doc>
