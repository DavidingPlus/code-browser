<dec f='qtbase-6.5.0/src/gui/text/qfontmetrics.h' l='60' type='QRect QFontMetrics::boundingRect(const QRect &amp; r, int flags, const QString &amp; text, int tabstops = 0, int * tabarray = nullptr) const'/>
<use f='qtbase-6.5.0/src/gui/text/qfontmetrics.h' l='63' u='c' c='_ZNK12QFontMetrics12boundingRectEiiiiiRK7QStringiPi'/>
<def f='qtbase-6.5.0/src/gui/text/qfontmetrics.cpp' l='756' ll='770' type='QRect QFontMetrics::boundingRect(const QRect &amp; rect, int flags, const QString &amp; text, int tabStops = 0, int * tabArray = nullptr) const'/>
<use f='qtbase-6.5.0/src/gui/text/qfontmetrics.cpp' l='797' u='c' c='_ZNK12QFontMetrics4sizeEiRK7QStringiPi'/>
<doc f='qtbase-6.5.0/src/gui/text/qfontmetrics.cpp' l='700'>/*!
    \overload

    Returns the bounding rectangle of the characters in the string
    specified by \a text, which is the set of pixels the text would
    cover if drawn at (0, 0). The drawing, and hence the bounding
    rectangle, is constrained to the rectangle \a rect.

    The \a flags argument is the bitwise OR of the following flags:
    \list
    \li Qt::AlignLeft aligns to the left border, except for
          Arabic and Hebrew where it aligns to the right.
    \li Qt::AlignRight aligns to the right border, except for
          Arabic and Hebrew where it aligns to the left.
    \li Qt::AlignJustify produces justified text.
    \li Qt::AlignHCenter aligns horizontally centered.
    \li Qt::AlignTop aligns to the top border.
    \li Qt::AlignBottom aligns to the bottom border.
    \li Qt::AlignVCenter aligns vertically centered
    \li Qt::AlignCenter (== \c{Qt::AlignHCenter | Qt::AlignVCenter})
    \li Qt::TextSingleLine ignores newline characters in the text.
    \li Qt::TextExpandTabs expands tabs (see below)
    \li Qt::TextShowMnemonic interprets &quot;&amp;x&quot; as \underline{x}; i.e., underlined.
    \li Qt::TextWordWrap breaks the text to fit the rectangle.
    \endlist

    Qt::Horizontal alignment defaults to Qt::AlignLeft and vertical
    alignment defaults to Qt::AlignTop.

    If several of the horizontal or several of the vertical alignment
    flags are set, the resulting alignment is undefined.

    If Qt::TextExpandTabs is set in \a flags, then: if \a tabArray is
    non-null, it specifies a 0-terminated sequence of pixel-positions
    for tabs; otherwise if \a tabStops is non-zero, it is used as the
    tab spacing (in pixels).

    Note that the bounding rectangle may extend to the left of (0, 0),
    e.g. for italicized fonts, and that the text output may cover \e
    all pixels in the bounding rectangle.

    Newline characters are processed as linebreaks.

    Despite the different actual character heights, the heights of the
    bounding rectangles of &quot;Yes&quot; and &quot;yes&quot; are the same.

    The bounding rectangle returned by this function is somewhat larger
    than that calculated by the simpler boundingRect() function. This
    function uses the \l{minLeftBearing()}{maximum left} and
    \l{minRightBearing()}{right} font bearings as is
    necessary for multi-line text to align correctly. Also,
    fontHeight() and lineSpacing() are used to calculate the height,
    rather than individual character heights.

    \sa horizontalAdvance(), QPainter::boundingRect(), Qt::Alignment
*/</doc>
<use f='qtbase-6.5.0/src/widgets/styles/qcommonstyle.cpp' l='1356' u='c' c='_ZNK12QCommonStyle11drawControlEN6QStyle14ControlElementEPK12QStyleOptionP8QPainterPK7QWidget'/>
<use f='qtbase-6.5.0/src/widgets/styles/qstylesheetstyle.cpp' l='3747' u='c' c='_ZNK16QStyleSheetStyle11drawControlEN6QStyle14ControlElementEPK12QStyleOptionP8QPainterPK7QWidget'/>
<use f='qtbase-6.5.0/src/widgets/styles/qstylesheetstyle.cpp' l='5393' u='c' c='_ZNK16QStyleSheetStyle16sizeFromContentsEN6QStyle12ContentsTypeEPK12QStyleOptionRK5QSizePK7QWidget'/>
<use f='qtbase-6.5.0/src/widgets/widgets/qmenu.cpp' l='418' u='c' c='_ZNK12QMenuPrivate17updateActionRectsERK5QRect'/>
