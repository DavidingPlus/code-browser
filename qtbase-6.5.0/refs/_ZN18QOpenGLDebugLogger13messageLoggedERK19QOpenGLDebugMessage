<dec f='qtbase-6.5.0/src/opengl/qopengldebug.h' l='170' type='void QOpenGLDebugLogger::messageLogged(const QOpenGLDebugMessage &amp; debugMessage)'/>
<use f='qtbase-6.5.0/src/opengl/qopengldebug.cpp' l='1117' u='c' c='_ZN25QOpenGLDebugLoggerPrivate13handleMessageEjjjjiPKc'/>
<doc f='qtbase-6.5.0/src/opengl/qopengldebug.cpp' l='1730'>/*!
    \fn void QOpenGLDebugLogger::messageLogged(const QOpenGLDebugMessage &amp;debugMessage)

    This signal is emitted when a debug message (wrapped by the \a debugMessage
    argument) is logged from the OpenGL server.

    Depending on the OpenGL implementation, this signal can be emitted
    from other threads than the one(s) the receiver(s) lives in, and even
    different from the thread the QOpenGLContext in which this object has
    been initialized lives in. Moreover, the signal could be emitted from
    multiple threads at the same time. This is normally not a problem,
    as Qt will utilize a queued connection for cross-thread signal emissions,
    but if you force the connection type to Direct then you must be aware of
    the potential races in the slots connected to this signal.

    If logging have been started in SynchronousLogging mode, OpenGL guarantees
    that this signal will be emitted from the same thread the QOpenGLContext
    has been bound to, and no concurrent invocations will ever happen.

    \note Logging must have been started, or this signal will not be emitted.

    \sa startLogging()
*/</doc>
