<dec f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.h' l='256' type='QByteArray QCborValue::toCbor(QCborValue::EncodingOptions opt = NoTransformation) const'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.h' l='394' u='c' c='_ZNK18QCborValueConstRef6toCborE6QFlagsIN10QCborValue14EncodingOptionEE'/>
<def f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.cpp' l='2519' ll='2525' type='QByteArray QCborValue::toCbor(QCborValue::EncodingOptions opt = NoTransformation) const'/>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.cpp' l='2493'>/*!
    Encodes this QCborValue object to its CBOR representation, using the
    options specified in \a opt, and return the byte array containing that
    representation.

    This function will not fail, except if this QCborValue or any of the
    contained items, if this is a map or array, are invalid. Invalid types are
    not produced normally by the API, but can result from decoding errors.

    By default, this function performs no transformation on the values in the
    QCborValue, writing all floating point directly as double-precision (\c
    double) types. If the \l{EncodingOption}{UseFloat} option is specified, it
    will use single precision (\c float) for any floating point value for which
    there&apos;s no loss of precision in using that representation. That includes
    infinities and NaN values.

    Similarly, if \l{EncodingOption}{UseFloat16} is specified, this function
    will try to use half-precision (\c qfloat16) floating point if the
    conversion to that results in no loss of precision. This is always true for
    infinities and NaN.

    If \l{EncodingOption}{UseIntegers} is specified, it will use integers for
    any floating point value that contains an actual integer.

    \sa fromCbor(), fromVariant(), fromJsonValue()
 */</doc>
