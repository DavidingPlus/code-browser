<def f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='97' type='bool QCborStreamReader::isArray() const'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='116' u='c' c='_ZNK17QCborStreamReader11isContainerEv'/>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='312'>/*!
   \fn bool QCborStreamReader::isArray() const

   Returns true if the type of the current element is an array (that is,
   if type() returns QCborStreamReader::Array). If this function returns
   true, you may call enterContainer() to begin parsing that container.

   When the current element is an array, you may also call isLengthKnown() to
   find out if the array&apos;s size is explicit in the CBOR stream. If it is, that
   size can be obtained by calling length().

   The following example pre-allocates a QVariantList given the array&apos;s size
   for more efficient decoding:

   \snippet code/src_corelib_serialization_qcborstream.cpp 25

   \note The code above does not validate that the length is a sensible value.
   If the input stream reports that the length is 1 billion elements, the above
   function will try to allocate some 16 GB or more of RAM, which can lead to a
   crash.

   \sa type(), isMap(), isLengthKnown(), length(), enterContainer(), leaveContainer()
 */</doc>
