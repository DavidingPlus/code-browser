<dec f='qtbase-6.5.0/src/corelib/io/qiodevice.h' l='124' type='qint64 QIODevice::writeData(const char * data, qint64 len)'/>
<ovr f='qtbase-6.5.0/src/corelib/io/qbuffer.cpp' l='397' c='_ZN7QBuffer9writeDataEPKcx'/>
<ovr f='qtbase-6.5.0/src/corelib/io/qfiledevice.cpp' l='503' c='_ZN11QFileDevice9writeDataEPKcx'/>
<use f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='1704' u='c' c='_ZN9QIODevice5writeEPKcx'/>
<doc f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='2167'>/*!
    \fn qint64 QIODevice::writeData(const char *data, qint64 maxSize)

    Writes up to \a maxSize bytes from \a data to the device. Returns
    the number of bytes written, or -1 if an error occurred.

    This function is called by QIODevice. Reimplement this function
    when creating a subclass of QIODevice.

    When reimplementing this function it is important that this function
    writes all the data available before returning. This is required in order
    for QDataStream to be able to operate on the class. QDataStream assumes
    all the information was written and therefore does not retry writing if
    there was a problem.

    \sa read(), write()
*/</doc>
<ovr f='qtbase-6.5.0/src/corelib/io/qnoncontiguousbytedevice.cpp' l='418' c='_ZN27QByteDeviceWrappingIoDevice9writeDataEPKcx'/>
<ovr f='qtbase-6.5.0/src/corelib/io/qprocess_unix.cpp' l='633' c='_ZN8QProcess9writeDataEPKcx'/>
<ovr f='qtbase-6.5.0/src/network/access/qhttpmultipart.cpp' l='508' c='_ZN22QHttpMultiPartIODevice9writeDataEPKcx'/>
<ovr f='qtbase-6.5.0/src/network/access/qnetworkreply.cpp' l='810' c='_ZN13QNetworkReply9writeDataEPKcx'/>
<ovr f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2420' c='_ZN15QAbstractSocket9writeDataEPKcx'/>
<ovr f='qtbase-6.5.0/src/network/socket/qlocalsocket_unix.cpp' l='465' c='_ZN12QLocalSocket9writeDataEPKcx'/>
