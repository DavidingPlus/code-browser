<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='204' u='c' c='_ZN15QRecursiveMutex4lockEv'/>
<dec f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='205' type='bool QRecursiveMutex::tryLock(int timeout = 0)'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='210' u='c' c='_ZN15QRecursiveMutex8try_lockEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='216' u='c' c='_ZN15QRecursiveMutex12try_lock_forENSt6chrono8durationIT_T0_EE'/>
<def f='qtbase-6.5.0/src/corelib/thread/qmutex.cpp' l='299' ll='326' type='bool QRecursiveMutex::tryLock(int timeout = 0)'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qmutex.cpp' l='281'>/*!
    Attempts to lock the mutex. This function returns \c true if the lock
    was obtained; otherwise it returns \c false. If another thread has
    locked the mutex, this function will wait for at most \a timeout
    milliseconds for the mutex to become available.

    Note: Passing a negative number as the \a timeout is equivalent to
    calling lock(), i.e. this function will wait forever until mutex
    can be locked if \a timeout is negative.

    If the lock was obtained, the mutex must be unlocked with unlock()
    before another thread can successfully lock it.

    Calling this function multiple times on the same mutex from the
    same thread is allowed.

    \sa lock(), unlock()
*/</doc>
