<dec f='qtbase-6.5.0/src/corelib/thread/qthread.h' l='32' type='static Qt::HANDLE QThread::currentThreadId()'/>
<def f='qtbase-6.5.0/src/corelib/thread/qthread.h' l='151' ll='192' type='static Qt::HANDLE QThread::currentThreadId()'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qthread.h' l='138'>/*
    On architectures and platforms we know, interpret the thread control
    block (TCB) as a unique identifier for a thread within a process. Otherwise,
    fall back to a slower but safe implementation.

    As per the documentation of currentThreadId, we return an opaque handle
    as a thread identifier, and application code is not supposed to use that
    value for anything. In Qt we use the handle to check if threads are identical,
    for which the TCB is sufficient.

    So we use the fastest possible way, rather than spend time on returning
    some pseudo-interoperable value.
*/</doc>
<use f='qtbase-6.5.0/src/corelib/kernel/qmetaobject.cpp' l='1600' u='c' c='_ZN11QMetaObject16invokeMethodImplEP7QObjectPN9QtPrivate15QSlotObjectBaseEN2Qt14ConnectionTypeEPv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qmetaobject.cpp' l='2677' u='c' c='_ZN18QMetaMethodInvoker10invokeImplE11QMetaMethodPvN2Qt14ConnectionTypeExPKPKvPKPKcPKPKN9QtPrivate18QMetaTypeInterfaceE'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qobject.cpp' l='1254' u='c' c='_ZNK7QObject10objectNameEv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qobject.cpp' l='3918' u='c' c='_Z10doActivateP7QObjectiPPv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qproperty.cpp' l='634' u='c' c='_ZNK9QtPrivate20QPropertyBindingData21notifyObserver_helperEP20QUntypedPropertyDataP15QBindingStorage24QPropertyObserverPointerR15QVarLengthArrayI19QB5277606'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qproperty.cpp' l='2318' u='c' c='_ZNK15QBindingStorage25registerDependency_helperEPK20QUntypedPropertyData'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qproperty.cpp' l='2357' u='c' c='_ZN9QtPrivate25initBindingStatusThreadIdEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.cpp' l='304' u='c' c='_ZN15QRecursiveMutex7tryLockEi'/>
<use f='qtbase-6.5.0/src/corelib/thread/qmutex.cpp' l='387' u='c' c='_ZN15QRecursiveMutex6unlockEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.cpp' l='517' u='c' c='_ZN21QReadWriteLockPrivate20recursiveLockForReadEi'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.cpp' l='539' u='c' c='_ZN21QReadWriteLockPrivate21recursiveLockForWriteEi'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.cpp' l='557' u='c' c='_ZN21QReadWriteLockPrivate15recursiveUnlockEv'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qthread.cpp' l='294'>/*!
    \fn Qt::HANDLE QThread::currentThreadId()

    Returns the thread handle of the currently executing thread.

    \warning The handle returned by this function is used for internal
    purposes and should not be used in any application code.

    \note On Windows, this function returns the DWORD (Windows-Thread
    ID) returned by the Win32 function GetCurrentThreadId(), not the pseudo-HANDLE
    (Windows-Thread HANDLE) returned by the Win32 function GetCurrentThread().
*/</doc>
