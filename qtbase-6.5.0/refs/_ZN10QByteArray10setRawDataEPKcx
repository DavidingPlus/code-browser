<dec f='qtbase-6.5.0/src/corelib/text/qbytearray.h' l='364' type='QByteArray &amp; QByteArray::setRawData(const char * a, qsizetype n)'/>
<use f='qtbase-6.5.0/src/corelib/global/qsysinfo.cpp' l='278' u='c' c='_ZL11readEtcFileR14QUnixOSVersionPKcRK10QByteArrayS5_S5_'/>
<def f='qtbase-6.5.0/src/corelib/text/qbytearray.cpp' l='4420' ll='4427' type='QByteArray &amp; QByteArray::setRawData(const char * data, qsizetype size)'/>
<doc f='qtbase-6.5.0/src/corelib/text/qbytearray.cpp' l='4406'>/*!
    \since 4.7

    Resets the QByteArray to use the first \a size bytes of the
    \a data array. The bytes are \e not copied. The QByteArray will
    contain the \a data pointer. The caller guarantees that \a data
    will not be deleted or modified as long as this QByteArray and any
    copies of it exist that have not been modified.

    This function can be used instead of fromRawData() to re-use
    existing QByteArray objects to save memory re-allocations.

    \sa fromRawData(), data(), constData()
*/</doc>
