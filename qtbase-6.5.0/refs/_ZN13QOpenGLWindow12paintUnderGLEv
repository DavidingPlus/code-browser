<dec f='qtbase-6.5.0/src/opengl/qopenglwindow.h' l='55' type='void QOpenGLWindow::paintUnderGL()'/>
<use f='qtbase-6.5.0/src/opengl/qopenglwindow.cpp' l='244' u='c' c='_ZN20QOpenGLWindowPrivate10beginPaintERK7QRegion'/>
<def f='qtbase-6.5.0/src/opengl/qopenglwindow.cpp' l='587' ll='589' type='void QOpenGLWindow::paintUnderGL()'/>
<doc f='qtbase-6.5.0/src/opengl/qopenglwindow.cpp' l='567'>/*!
  The virtual function is called before each invocation of paintGL().

  When the update mode is set to \c NoPartialUpdate, there is no difference
  between this function and paintGL(), performing rendering in either of them
  leads to the same result.

  The difference becomes significant when using \c PartialUpdateBlend, where an
  extra framebuffer object is used. There, paintGL() targets this additional
  framebuffer object, which preserves its contents, while paintUnderGL() and
  paintOverGL() target the default framebuffer, i.e. directly the window
  surface, the contents of which is lost after each displayed frame.

  \note Avoid relying on this function when the update behavior is
  \c PartialUpdateBlit. This mode involves blitting the extra framebuffer used by
  paintGL() onto the default framebuffer after each invocation of paintGL(),
  thus overwriting all drawing generated in this function.

  \sa paintGL(), paintOverGL(), UpdateBehavior
 */</doc>
