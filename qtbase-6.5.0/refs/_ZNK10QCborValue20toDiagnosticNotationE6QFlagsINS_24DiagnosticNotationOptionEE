<dec f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.h' l='260' type='QString QCborValue::toDiagnosticNotation(QCborValue::DiagnosticNotationOptions opts = Compact) const'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.h' l='400' u='c' c='_ZNK18QCborValueConstRef20toDiagnosticNotationE6QFlagsIN10QCborValue24DiagnosticNotationOptionEE'/>
<def f='qtbase-6.5.0/src/corelib/serialization/qcbordiagnostic.cpp' l='311' ll='314' type='QString QCborValue::toDiagnosticNotation(QCborValue::DiagnosticNotationOptions opts = Compact) const'/>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcbordiagnostic.cpp' l='285'>/*!
    Creates the diagnostic notation equivalent of this CBOR object and returns
    it. The \a opts parameter controls the dialect of the notation. Diagnostic
    notation is useful in debugging, to aid the developer in understanding what
    value is stored in the QCborValue or in a CBOR stream. For that reason, the
    Qt API provides no support for parsing the diagnostic back into the
    in-memory format or CBOR stream, though the representation is unique and it
    would be possible.

    CBOR diagnostic notation is specified by
    \l{RFC 7049, section 6}{section 6} of RFC 7049.
    It is a text representation of the CBOR stream and it is very similar to
    JSON, but it supports the CBOR types not found in JSON. The extended format
    enabled by the \l{DiagnosticNotationOption}{ExtendedFormat} flag is
    currently in some IETF drafts and its format is subject to change.

    This function produces the equivalent representation of the stream that
    toCbor() would produce, without any transformation option provided there.
    This also implies this function may not produce a representation of the
    stream that was used to create the object, if it was created using
    fromCbor(), as that function may have applied transformations. For a
    high-fidelity notation of a stream, without transformation, see the \c
    cbordump example.

    \sa toCbor(), QJsonDocument::toJson()
 */</doc>
