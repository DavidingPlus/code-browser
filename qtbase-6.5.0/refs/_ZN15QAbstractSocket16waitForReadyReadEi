<dec f='qtbase-6.5.0/src/network/socket/qabstractsocket.h' l='179' type='bool QAbstractSocket::waitForReadyRead(int msecs = 30000)'/>
<inh f='qtbase-6.5.0/src/corelib/io/qiodevice.h' l='96' c='_ZN9QIODevice16waitForReadyReadEi'/>
<def f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2131' ll='2183' type='bool QAbstractSocket::waitForReadyRead(int msecs = 30000)'/>
<doc f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2116'>/*!
    This function blocks until new data is available for reading and the
    \l{QIODevice::}{readyRead()} signal has been emitted. The function
    will timeout after \a msecs milliseconds; the default timeout is
    30000 milliseconds.

    The function returns \c true if the readyRead() signal is emitted and
    there is new data available for reading; otherwise it returns \c false
    (if an error occurred or the operation timed out).

    \note This function may fail randomly on Windows. Consider using the event
    loop and the readyRead() signal if your software will run on Windows.

    \sa waitForBytesWritten()
*/</doc>
<use f='qtbase-6.5.0/src/network/socket/qhttpsocketengine.cpp' l='325' u='c' c='_ZN17QHttpSocketEngine11waitForReadEiPb'/>
<use f='qtbase-6.5.0/src/network/socket/qhttpsocketengine.cpp' l='337' u='c' c='_ZN17QHttpSocketEngine11waitForReadEiPb'/>
<use f='qtbase-6.5.0/src/network/socket/qhttpsocketengine.cpp' l='373' u='c' c='_ZN17QHttpSocketEngine12waitForWriteEiPb'/>
<use f='qtbase-6.5.0/src/network/socket/qlocalsocket_unix.cpp' l='622' u='c' c='_ZN12QLocalSocket16waitForReadyReadEi'/>
<use f='qtbase-6.5.0/src/network/socket/qsocks5socketengine.cpp' l='1694' u='c' c='_ZN26QSocks5SocketEnginePrivate16waitForConnectedEiPb'/>
<use f='qtbase-6.5.0/src/network/socket/qsocks5socketengine.cpp' l='1733' u='c' c='_ZN19QSocks5SocketEngine11waitForReadEiPb'/>
<use f='qtbase-6.5.0/src/network/socket/qsocks5socketengine.cpp' l='1746' u='c' c='_ZN19QSocks5SocketEngine11waitForReadEiPb'/>
