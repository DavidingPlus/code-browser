<use f='qtbase-6.5.0/src/gui/painting/qplatformbackingstore.h' l='174' c='_ZNK21QPlatformBackingStore3rhiEv'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='688' c='_ZNK12QRhiResource3rhiEv'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1579'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1624' ll='1830'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1718' c='_ZN4QRhi6createENS_14ImplementationEP14QRhiInitParams6QFlagsINS_4FlagEEP17QRhiNativeHandles'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1730'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1828' c='_ZN4QRhiC1ERKS_'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1828' c='_ZN4QRhiaSERKS_'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1828' c='_ZN4QRhiaSERKS_'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor_p.h' l='31' c='_ZNK30QBackingStoreDefaultCompositor9toTextureEPK21QPlatformBackingStoreP4QRhiP23QRhiResourceUpdateBatchRK7QRegionP6QFlagsINS0_11TextureFlagEE'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor_p.h' l='37' c='_ZN30QBackingStoreDefaultCompositor5flushEP21QPlatformBackingStoreP4QRhiP13QRhiSwapChainP7QWindowdRK7QRegionRK6QPointP20QPlatformTextureListb'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor_p.h' l='55' c='_ZNK30QBackingStoreDefaultCompositor9toTextureERK6QImageP4QRhiP23QRhiResourceUpdateBatchRK7QRegionP6QFlagsIN21QPlatformBackingStore11TextureFlagEE'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor_p.h' l='60'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='38' c='_ZNK30QBackingStoreDefaultCompositor9toTextureEPK21QPlatformBackingStoreP4QRhiP23QRhiResourceUpdateBatchRK7QRegionP6QFlagsINS0_11TextureFlagEE'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='47' c='_ZNK30QBackingStoreDefaultCompositor9toTextureERK6QImageP4QRhiP23QRhiResourceUpdateBatchRK7QRegionP6QFlagsIN21QPlatformBackingStore11TextureFlagEE'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='280' c='_ZL22createGraphicsPipelineP4QRhiP26QRhiShaderResourceBindingsP13QRhiSwapChain13PipelineBlend'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='448' c='_ZN30QBackingStoreDefaultCompositor5flushEP21QPlatformBackingStoreP4QRhiP13QRhiSwapChainP7QWindowdRK7QRegionRK6QPointP20QPlatformTextureListb'/>
<size>8</size>
<fun r='_ZN4QRhiD1Ev'/>
<fun r='_ZN4QRhi6createENS_14ImplementationEP14QRhiInitParams6QFlagsINS_4FlagEEP17QRhiNativeHandles'/>
<fun r='_ZN4QRhi5probeENS_14ImplementationEP14QRhiInitParams'/>
<fun r='_ZNK4QRhi7backendEv'/>
<fun r='_ZNK4QRhi11backendNameEv'/>
<fun r='_ZN4QRhi11backendNameENS_14ImplementationE'/>
<fun r='_ZNK4QRhi10driverInfoEv'/>
<fun r='_ZNK4QRhi6threadEv'/>
<fun r='_ZN4QRhi18addCleanupCallbackERKSt8functionIFvPS_EE'/>
<fun r='_ZN4QRhi10runCleanupEv'/>
<fun r='_ZN4QRhi23addGpuFrameTimeCallbackERKSt8functionIFvfEE'/>
<fun r='_ZN4QRhi19newGraphicsPipelineEv'/>
<fun r='_ZN4QRhi18newComputePipelineEv'/>
<fun r='_ZN4QRhi25newShaderResourceBindingsEv'/>
<fun r='_ZN4QRhi9newBufferEN10QRhiBuffer4TypeE6QFlagsINS0_9UsageFlagEEj'/>
<fun r='_ZN4QRhi15newRenderBufferEN16QRhiRenderBuffer4TypeERK5QSizei6QFlagsINS0_4FlagEEN11QRhiTexture6FormatE'/>
<fun r='_ZN4QRhi10newTextureEN11QRhiTexture6FormatERK5QSizei6QFlagsINS0_4FlagEE'/>
<fun r='_ZN4QRhi10newTextureEN11QRhiTexture6FormatEiiii6QFlagsINS0_4FlagEE'/>
<fun r='_ZN4QRhi15newTextureArrayEN11QRhiTexture6FormatEiRK5QSizei6QFlagsINS0_4FlagEE'/>
<fun r='_ZN4QRhi10newSamplerEN11QRhiSampler6FilterES1_S1_NS0_11AddressModeES2_S2_'/>
<fun r='_ZN4QRhi22newTextureRenderTargetERK34QRhiTextureRenderTargetDescription6QFlagsIN23QRhiTextureRenderTarget4FlagEE'/>
<fun r='_ZN4QRhi12newSwapChainEv'/>
<fun r='_ZN4QRhi10beginFrameEP13QRhiSwapChain6QFlagsINS_14BeginFrameFlagEE'/>
<fun r='_ZN4QRhi8endFrameEP13QRhiSwapChain6QFlagsINS_12EndFrameFlagEE'/>
<fun r='_ZNK4QRhi16isRecordingFrameEv'/>
<fun r='_ZNK4QRhi16currentFrameSlotEv'/>
<fun r='_ZN4QRhi19beginOffscreenFrameEPP17QRhiCommandBuffer6QFlagsINS_14BeginFrameFlagEE'/>
<fun r='_ZN4QRhi17endOffscreenFrameE6QFlagsINS_12EndFrameFlagEE'/>
<fun r='_ZN4QRhi6finishEv'/>
<fun r='_ZN4QRhi23nextResourceUpdateBatchEv'/>
<fun r='_ZNK4QRhi21supportedSampleCountsEv'/>
<fun r='_ZNK4QRhi13ubufAlignmentEv'/>
<fun r='_ZNK4QRhi11ubufAlignedEi'/>
<fun r='_ZNK4QRhi16mipLevelsForSizeERK5QSize'/>
<fun r='_ZNK4QRhi15sizeForMipLevelEiRK5QSize'/>
<fun r='_ZNK4QRhi18isYUpInFramebufferEv'/>
<fun r='_ZNK4QRhi10isYUpInNDCEv'/>
<fun r='_ZNK4QRhi20isClipDepthZeroToOneEv'/>
<fun r='_ZNK4QRhi19clipSpaceCorrMatrixEv'/>
<fun r='_ZNK4QRhi24isTextureFormatSupportedEN11QRhiTexture6FormatE6QFlagsINS0_4FlagEE'/>
<fun r='_ZNK4QRhi18isFeatureSupportedENS_7FeatureE'/>
<fun r='_ZNK4QRhi13resourceLimitENS_13ResourceLimitE'/>
<fun r='_ZN4QRhi13nativeHandlesEv'/>
<fun r='_ZN4QRhi35makeThreadLocalNativeContextCurrentEv'/>
<smbr r='QRhi::MAX_MIP_LEVELS' t='const int'/>
<fun r='_ZN4QRhi22releaseCachedResourcesEv'/>
<fun r='_ZNK4QRhi12isDeviceLostEv'/>
<fun r='_ZN4QRhi17pipelineCacheDataEv'/>
<fun r='_ZN4QRhi20setPipelineCacheDataERK10QByteArray'/>
<fun r='_ZNK4QRhi10statisticsEv'/>
<fun r='_ZN4QRhi24updateSwapChainProxyDataENS_14ImplementationEP7QWindow'/>
<fun r='_ZN4QRhiC1Ev'/>
<fun r='_ZN4QRhiC1ERKS_'/>
<mbr r='QRhi::d' o='0' t='QRhiImplementation *'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstorerhisupport_p.h' l='48' c='_ZNK23QBackingStoreRhiSupport3rhiEv'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstorerhisupport_p.h' l='54'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstorerhisupport.cpp' l='65' c='_ZN23QBackingStoreRhiSupport6createEv'/>
<size>8</size>
<use f='qtbase-6.5.0/src/gui/painting/qplatformbackingstore.cpp' l='370' c='_ZNK21QPlatformBackingStore3rhiEv'/>
<size>8</size>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p_p.h' l='223'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p_p.h' l='244'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='2224' c='_ZNK12QRhiResource3rhiEv'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5537' c='_ZN4QRhi6createENS_14ImplementationEP14QRhiInitParams6QFlagsINS_4FlagEEP17QRhiNativeHandles'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5539' c='_ZN4QRhi6createENS_14ImplementationEP14QRhiInitParams6QFlagsINS_4FlagEEP17QRhiNativeHandles'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5539' c='_ZN4QRhi6createENS_14ImplementationEP14QRhiInitParams6QFlagsINS_4FlagEEP17QRhiNativeHandles'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5632' c='_ZN4QRhi5probeENS_14ImplementationEP14QRhiInitParams'/>
<size>8</size>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='28'>/*!
    \class QRhi
    \internal
    \inmodule QtGui

    \brief Accelerated 2D/3D graphics API abstraction.

    The Qt Rendering Hardware Interface is an abstraction for hardware accelerated
    graphics APIs, such as, \l{https://www.khronos.org/opengl/}{OpenGL},
    \l{https://www.khronos.org/opengles/}{OpenGL ES},
    \l{https://docs.microsoft.com/en-us/windows/desktop/direct3d}{Direct3D},
    \l{https://developer.apple.com/metal/}{Metal}, and
    \l{https://www.khronos.org/vulkan/}{Vulkan}.

    Some of the main design goals are:

    \list

    \li Simple, minimal, understandable, extensible. Follow the proven path of the
    Qt Quick scenegraph.

    \li Aim to be a product - and in the bigger picture, part of a product (Qt) -
    that is usable out of the box both by internal (such as, Qt Quick) and,
    eventually, external users.

    \li Not a complete 1:1 wrapper for any of the underlying APIs. The feature set
    is tuned towards the needs of Qt&apos;s 2D and 3D offering (QPainter, Qt Quick, Qt
    3D Studio). Iterate and evolve in a sustainable manner.

    \li Intrinsically cross-platform, without reinventing: abstracting
    cross-platform aspects of certain APIs (such as, OpenGL context creation and
    windowing system interfaces, Vulkan instance and surface management) is not in
    scope here. These are delegated to the existing QtGui facilities (QWindow,
    QOpenGLContext, QVulkanInstance) and its backing QPA architecture.

    \endlist

    Each QRhi instance is backed by a backend for a specific graphics API. The
    selection of the backend is a run time choice and is up to the application
    or library that creates the QRhi instance. Some backends are available on
    multiple platforms (OpenGL, Vulkan, Null), while APIs specific to a given
    platform are only available when running on the platform in question (Metal
    on macOS/iOS/tvOS, Direct3D on Windows).

    The available backends currently are:

    \list

    \li OpenGL 2.1 or OpenGL ES 2.0 or newer. Some extensions are utilized when
    present, for example to enable multisample framebuffers.

    \li Direct3D 11.1

    \li Metal

    \li Vulkan 1.0, optionally with some extensions that are part of Vulkan 1.1

    \li Null - A &quot;dummy&quot; backend that issues no graphics calls at all.

    \endlist

    In order to allow shader code to be written once in Qt applications and
    libraries, all shaders are expected to be written in a single language
    which is then compiled into SPIR-V. Versions for various shading language
    are then generated from that, together with reflection information (inputs,
    outputs, shader resources). This is then packed into easily and efficiently
    serializable QShader instances. The compilers and tools to generate such
    shaders are not part of QRhi, but the core classes for using such shaders,
    QShader and QShaderDescription, are.

    \section2 Design Fundamentals

    A QRhi cannot be instantiated directly. Instead, use the create()
    function. Delete the QRhi instance normally to release the graphics device.

    \section3 Resources

    Instances of classes deriving from QRhiResource, such as, QRhiBuffer,
    QRhiTexture, etc., encapsulate zero, one, or more native graphics
    resources. Instances of such classes are always created via the \c new
    functions of the QRhi, such as, newBuffer(), newTexture(),
    newTextureRenderTarget(), newSwapChain().

    \badcode
        vbuf = rhi-&gt;newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertexData));
        if (!vbuf-&gt;create()) { error }
        ...
        delete vbuf;
    \endcode

    \list

    \li The returned value from functions like newBuffer() is always owned by
    the caller.

    \li Just creating a QRhiResource subclass never allocates or initializes any
    native resources. That is only done when calling the \c create() function of a
    subclass, for example, QRhiBuffer::create() or QRhiTexture::create().

    \li The exceptions are
    QRhiTextureRenderTarget::newCompatibleRenderPassDescriptor(),
    QRhiSwapChain::newCompatibleRenderPassDescriptor(), and
    QRhiRenderPassDescriptor::newCompatibleRenderPassDescriptor(). There is no
    \c create() operation for these and the returned object is immediately
    active.

    \li The resource objects themselves are treated as immutable: once a
    resource has create() called, changing any parameters via the setters, such as,
    QRhiTexture::setPixelSize(), has no effect, unless the underlying native
    resource is released and \c create() is called again. See more about resource
    reuse in the sections below.

    \li The underlying native resources are scheduled for releasing by the
    QRhiResource destructor, or by calling QRhiResource::destroy(). Backends
    often queue release requests and defer executing them to an unspecified
    time, this is hidden from the applications. This way applications do not
    have to worry about releasing native resources that may still be in use by
    an in-flight frame.

    \li Note that this does not mean that a QRhiResource can freely be
    destroy()&apos;ed or deleted within a frame (that is, in a
    \l{QRhiCommandBuffer::beginFrame()}{beginFrame()} -
    \l{QRhiCommandBuffer::endFrame()}{endFrame()} section). As a general rule,
    all referenced QRhiResource objects must stay unchanged until the frame is
    submitted by calling \l{QRhiCommandBuffer::endFrame()}{endFrame()}. To ease
    this, QRhiResource::deleteLater() is provided as a convenience.

    \endlist

    \section3 Command buffers and deferred command execution

    Regardless of the design and capabilities of the underlying graphics API,
    all QRhi backends implement some level of command buffers. No
    QRhiCommandBuffer function issues any native bind or draw command (such as,
    \c glDrawElements) directly. Commands are always recorded in a queue,
    either native or provided by the QRhi backend. The command buffer is
    submitted, and so execution starts only upon QRhi::endFrame() or
    QRhi::finish().

    The deferred nature has consequences for some types of objects. For example,
    writing to a dynamic buffer multiple times within a frame, in case such
    buffers are backed by host-visible memory, will result in making the
    results of all writes are visible to all draw calls in the command buffer
    of the frame, regardless of when the dynamic buffer update was recorded
    relative to a draw call.

    Furthermore, instances of QRhiResource subclasses must be treated immutable
    within a frame in which they are referenced in any way. Create
    all resources upfront, before starting to record commands for the next
    frame. Reusing a QRhiResource instance within a frame (by calling \c create()
    then referencing it again in the same \c{beginFrame - endFrame} section)
    should be avoided as it may lead to unexpected results, depending on the
    backend.

    As a general rule, all referenced QRhiResource objects must stay valid and
    unmodified until the frame is submitted by calling
    \l{QRhiCommandBuffer::endFrame()}{endFrame()}. On the other hand, calling
    \l{QRhiResource::destroy()}{destroy()} or deleting the QRhiResource are
    always safe once the frame is submitted, regardless of the status of the
    underlying native resources (which may still be in use by the GPU - but
    that is taken care of internally).

    Unlike APIs like OpenGL, upload and copy type of commands cannot be mixed
    with draw commands. The typical renderer will involve a sequence similar to
    the following: \c{(re)create resources} - \c{begin frame} - \c{record
    uploads and copies} - \c{start renderpass} - \c{record draw calls} - \c{end
    renderpass} - \c{end frame}. Recording copy type of operations happens via
    QRhiResourceUpdateBatch. Such operations are committed typically on
    \l{QRhiCommandBuffer::beginPass()}{beginPass()}.

    When working with legacy rendering engines designed for OpenGL, the
    migration to QRhi often involves redesigning from having a single \c render
    step (that performs copies and uploads, clears buffers, and issues draw
    calls, all mixed together) to a clearly separated, two phase \c prepare -
    \c render setup where the \c render step only starts a renderpass and
    records draw calls, while all resource creation and queuing of updates,
    uploads and copies happens beforehand, in the \c prepare step.

    QRhi does not at the moment allow freely creating and submitting command
    buffers. This may be lifted in the future to some extent, in particular if
    compute support is introduced, but the model of well defined
    \c{frame-start} and \c{frame-end} points, combined with a dedicated,
    &quot;frame&quot; command buffer, where \c{frame-end} implies presenting, is going to
    remain the primary way of operating since this is what fits Qt&apos;s various UI
    technologies best.

    \section3 Threading

    A QRhi instance and the associated resources can be created and used on any
    thread but all usage must be limited to that one single thread. When
    rendering to multiple QWindows in an application, having a dedicated thread
    and QRhi instance for each window is often advisable, as this can eliminate
    issues with unexpected throttling caused by presenting to multiple windows.
    Conceptually that is then the same as how Qt Quick scene graph&apos;s threaded
    render loop operates when working directly with OpenGL: one thread for each
    window, one QOpenGLContext for each thread. When moving onto QRhi,
    QOpenGLContext is replaced by QRhi, making the migration straightforward.

    When it comes to externally created native objects, such as OpenGL contexts
    passed in via QRhiGles2NativeHandles, it is up to the application to ensure
    they are not misused by other threads.

    Resources are not shareable between QRhi instances. This is an intentional
    choice since QRhi hides most queue, command buffer, and resource
    synchronization related tasks, and provides no API for them. Safe and
    efficient concurrent use of graphics resources from multiple threads is
    tied to those concepts, however, and is thus a topic that is currently out
    of scope, but may be introduced in the future.

    \note The Metal backend requires that an autorelease pool is available on
    the rendering thread, ideally wrapping each iteration of the render loop.
    This needs no action from the users of QRhi when rendering on the main
    (gui) thread, but becomes important when a separate, dedicated render
    thread is used.

    \section3 Resource synchronization

    QRhi does not expose APIs for resource barriers or image layout
    transitions. Such synchronization is done implicitly by the backends, where
    applicable (for example, Vulkan), by tracking resource usage as necessary.
    Buffer and image barriers are inserted before render or compute passes
    transparently to the application.

    \note Resources within a render or compute pass are expected to be bound to
    a single usage during that pass. For example, a buffer can be used as
    vertex, index, uniform, or storage buffer, but not a combination of them
    within a single pass. However, it is perfectly fine to use a buffer as a
    storage buffer in a compute pass, and then as a vertex buffer in a render
    pass, for example, assuming the buffer declared both usages upon creation.

    \note Textures have this rule relaxed in certain cases, because using two
    subresources (typically two different mip levels) of the same texture for
    different access (one for load, one for store) is supported even within the
    same pass.

    \section3 Resource reuse

    From the user&apos;s point of view a QRhiResource is reusable immediately after
    calling QRhiResource::destroy(). With the exception of swapchains, calling
    \c create() on an already created object does an implicit \c destroy(). This
    provides a handy shortcut to reuse a QRhiResource instance with different
    parameters, with a new native graphics object underneath.

    The importance of reusing the same object lies in the fact that some
    objects reference other objects: for example, a QRhiShaderResourceBindings
    can reference QRhiBuffer, QRhiTexture, and QRhiSampler instances. If in a
    later frame one of these buffers need to be resized or a sampler parameter
    needs changing, destroying and creating a whole new QRhiBuffer or
    QRhiSampler would invalidate all references to the old instance. By just
    changing the appropriate parameters via QRhiBuffer::setSize() or similar
    and then calling QRhiBuffer::create(), everything works as expected and
    there is no need to touch the QRhiShaderResourceBindings at all, even
    though there is a good chance that under the hood the QRhiBuffer is now
    backed by a whole new native buffer.

    \badcode
        ubuf = rhi-&gt;newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 256);
        ubuf-&gt;create();

        srb = rhi-&gt;newShaderResourceBindings()
        srb-&gt;setBindings({
            QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage, ubuf)
        });
        srb-&gt;create();

        ...

        // now in a later frame we need to grow the buffer to a larger size
        ubuf-&gt;setSize(512);
        ubuf-&gt;create(); // same as ubuf-&gt;destroy(); ubuf-&gt;create();

        // That&apos;s it, srb needs no changes whatsoever, any references in it to
        // ubuf stay valid. When it comes to internal details, such as that
        // ubuf may now be backed by a completely different native buffer
        // resource, that is is recognized and handled automatically by the
        // next setShaderResources().
    \endcode

    QRhiTextureRenderTarget offers the same contract: calling
    QRhiCommandBuffer::beginPass() is safe even when one of the render target&apos;s
    associated textures or renderbuffers has been rebuilt (by calling \c
    create() on it) since the creation of the render target object. This allows
    the application to resize a texture by setting a new pixel size on the
    QRhiTexture and calling create(), thus creating a whole new native texture
    resource underneath, without having to update the QRhiTextureRenderTarget
    as that will be done implicitly in beginPass().

    \section3 Pooled objects

    In addition to resources, there are pooled objects as well, such as,
    QRhiResourceUpdateBatch. An instance is retrieved via a \c next function,
    such as, nextResourceUpdateBatch(). The caller does not own the returned
    instance in this case. The only valid way of operating here is calling
    functions on the QRhiResourceUpdateBatch and then passing it to
    QRhiCommandBuffer::beginPass() or QRhiCommandBuffer::endPass(). These
    functions take care of returning the batch to the pool. Alternatively, a
    batch can be &quot;canceled&quot; and returned to the pool without processing by
    calling QRhiResourceUpdateBatch::destroy().

    A typical pattern is thus:

    \badcode
        QRhiResourceUpdateBatch *resUpdates = rhi-&gt;nextResourceUpdateBatch();
        ...
        resUpdates-&gt;updateDynamicBuffer(ubuf, 0, 64, mvp.constData());
        if (!image.isNull()) {
            resUpdates-&gt;uploadTexture(texture, image);
            image = QImage();
        }
        ...
        QRhiCommandBuffer *cb = m_sc-&gt;currentFrameCommandBuffer();
        cb-&gt;beginPass(swapchain-&gt;currentFrameRenderTarget(), clearCol, clearDs, resUpdates);
    \endcode

    \section3 Swapchain specifics

    QRhiSwapChain features some special semantics due to the peculiar nature of
    swapchains.

    \list

    \li It has no \c create() but rather a QRhiSwapChain::createOrResize().
    Repeatedly calling this function is \b not the same as calling
    QRhiSwapChain::destroy() followed by QRhiSwapChain::createOrResize(). This
    is because swapchains often have ways to handle the case where buffers need
    to be resized in a manner that is more efficient than a brute force
    destroying and recreating from scratch.

    \li An active QRhiSwapChain must be released by calling
    \l{QRhiSwapChain::destroy()}{destroy()}, or by destroying the object, before
    the QWindow&apos;s underlying QPlatformWindow, and so the associated native
    window object, is destroyed. It should not be postponed because releasing
    the swapchain may become problematic (and with some APIs, like Vulkan, is
    explicitly disallowed) when the native window is not around anymore, for
    example because the QPlatformWindow got destroyed upon getting a
    QWindow::close(). Therefore, releasing the swapchain must happen whenever
    the targeted QWindow sends the
    QPlatformSurfaceEvent::SurfaceAboutToBeDestroyed event. If the event does
    not arrive before the destruction of the QWindow - this can happen when
    using QCoreApplication::quit() -, then check QWindow::handle() after the
    event loop exits and invoke the swapchain release when non-null (meaning
    the underlying native window is still around).

    \endlist

    \section3 Ownership

    The general rule is no ownership transfer. Creating a QRhi with an already
    existing graphics device does not mean the QRhi takes ownership of the
    device object. Similarly, ownership is not given away when a device or
    texture object is &quot;exported&quot; via QRhi::nativeHandles() or
    QRhiTexture::nativeHandles(). Most importantly, passing pointers in structs
    and via setters does not transfer ownership.

    \section2 Troubleshooting

    Errors are printed to the output via qWarning(). Additional debug messages
    can be enabled via the following logging categories. Messages from these
    categories are not printed by default unless explicitly enabled via
    QLoggingCategory or the \c QT_LOGGING_RULES environment variable.

    \list
    \li \c{qt.rhi.general}
    \endlist

    It is strongly advised to inspect the output with the logging categories
    (\c{qt.rhi.*}) enabled whenever a QRhi-based application is not behaving as
    expected. For better interoperation with Qt Quick, the environment variable
    \c{QSG_INFO} also enables these debug prints.
 */</doc>
<fun r='_ZN4QRhiC1Ev'/>
<fun r='_ZN4QRhiD1Ev'/>
<fun r='_ZN4QRhi6createENS_14ImplementationEP14QRhiInitParams6QFlagsINS_4FlagEEP17QRhiNativeHandles'/>
<fun r='_ZN4QRhi5probeENS_14ImplementationEP14QRhiInitParams'/>
<fun r='_ZN4QRhi24updateSwapChainProxyDataENS_14ImplementationEP7QWindow'/>
<fun r='_ZNK4QRhi7backendEv'/>
<fun r='_ZN4QRhi11backendNameENS_14ImplementationE'/>
<fun r='_ZNK4QRhi11backendNameEv'/>
<fun r='_ZNK4QRhi10driverInfoEv'/>
<fun r='_ZNK4QRhi6threadEv'/>
<fun r='_ZN4QRhi18addCleanupCallbackERKSt8functionIFvPS_EE'/>
<fun r='_ZN4QRhi10runCleanupEv'/>
<fun r='_ZN4QRhi23addGpuFrameTimeCallbackERKSt8functionIFvfEE'/>
<fun r='_ZN4QRhi23nextResourceUpdateBatchEv'/>
<fun r='_ZNK4QRhi11ubufAlignedEi'/>
<fun r='_ZNK4QRhi16mipLevelsForSizeERK5QSize'/>
<fun r='_ZNK4QRhi15sizeForMipLevelEiRK5QSize'/>
<fun r='_ZNK4QRhi18isYUpInFramebufferEv'/>
<fun r='_ZNK4QRhi10isYUpInNDCEv'/>
<fun r='_ZNK4QRhi20isClipDepthZeroToOneEv'/>
<fun r='_ZNK4QRhi19clipSpaceCorrMatrixEv'/>
<fun r='_ZNK4QRhi24isTextureFormatSupportedEN11QRhiTexture6FormatE6QFlagsINS0_4FlagEE'/>
<fun r='_ZNK4QRhi18isFeatureSupportedENS_7FeatureE'/>
<fun r='_ZNK4QRhi13resourceLimitENS_13ResourceLimitE'/>
<fun r='_ZN4QRhi13nativeHandlesEv'/>
<fun r='_ZN4QRhi35makeThreadLocalNativeContextCurrentEv'/>
<fun r='_ZN4QRhi22releaseCachedResourcesEv'/>
<fun r='_ZNK4QRhi12isDeviceLostEv'/>
<fun r='_ZN4QRhi17pipelineCacheDataEv'/>
<fun r='_ZN4QRhi20setPipelineCacheDataERK10QByteArray'/>
<fun r='_ZNK4QRhi10statisticsEv'/>
<fun r='_ZN4QRhi19newGraphicsPipelineEv'/>
<fun r='_ZN4QRhi18newComputePipelineEv'/>
<fun r='_ZN4QRhi25newShaderResourceBindingsEv'/>
<fun r='_ZN4QRhi9newBufferEN10QRhiBuffer4TypeE6QFlagsINS0_9UsageFlagEEj'/>
<fun r='_ZN4QRhi15newRenderBufferEN16QRhiRenderBuffer4TypeERK5QSizei6QFlagsINS0_4FlagEEN11QRhiTexture6FormatE'/>
<fun r='_ZN4QRhi10newTextureEN11QRhiTexture6FormatERK5QSizei6QFlagsINS0_4FlagEE'/>
<fun r='_ZN4QRhi10newTextureEN11QRhiTexture6FormatEiiii6QFlagsINS0_4FlagEE'/>
<fun r='_ZN4QRhi15newTextureArrayEN11QRhiTexture6FormatEiRK5QSizei6QFlagsINS0_4FlagEE'/>
<fun r='_ZN4QRhi10newSamplerEN11QRhiSampler6FilterES1_S1_NS0_11AddressModeES2_S2_'/>
<fun r='_ZN4QRhi22newTextureRenderTargetERK34QRhiTextureRenderTargetDescription6QFlagsIN23QRhiTextureRenderTarget4FlagEE'/>
<fun r='_ZN4QRhi12newSwapChainEv'/>
<fun r='_ZN4QRhi10beginFrameEP13QRhiSwapChain6QFlagsINS_14BeginFrameFlagEE'/>
<fun r='_ZN4QRhi8endFrameEP13QRhiSwapChain6QFlagsINS_12EndFrameFlagEE'/>
<fun r='_ZNK4QRhi16isRecordingFrameEv'/>
<fun r='_ZNK4QRhi16currentFrameSlotEv'/>
<fun r='_ZN4QRhi19beginOffscreenFrameEPP17QRhiCommandBuffer6QFlagsINS_14BeginFrameFlagEE'/>
<fun r='_ZN4QRhi17endOffscreenFrameE6QFlagsINS_12EndFrameFlagEE'/>
<fun r='_ZN4QRhi6finishEv'/>
<fun r='_ZNK4QRhi21supportedSampleCountsEv'/>
<fun r='_ZNK4QRhi13ubufAlignmentEv'/>
<use f='qtbase-6.5.0/src/opengl/qopenglcompositorbackingstore_p.h' l='68'/>
<size>8</size>
<use f='qtbase-6.5.0/src/widgets/kernel/qwidgetrepaintmanager_p.h' l='75' c='_ZNK21QWidgetRepaintManager3rhiEv'/>
<use f='qtbase-6.5.0/src/openglwidgets/qopenglwidget.cpp' l='778' c='_ZN20QOpenGLWidgetPrivate27ensureRhiDependentResourcesEv'/>
<use f='qtbase-6.5.0/src/openglwidgets/qopenglwidget.cpp' l='835' c='_ZN20QOpenGLWidgetPrivate10initializeEv'/>
<size>8</size>
<use f='qtbase-6.5.0/src/widgets/kernel/qwidgetrepaintmanager.cpp' l='1037' c='_ZN21QWidgetRepaintManager5flushEP7QWidgetRK7QRegionP20QPlatformTextureList'/>
<use f='qtbase-6.5.0/src/widgets/kernel/qwidgetrepaintmanager.cpp' l='1279' c='_ZNK21QWidgetRepaintManager3rhiEv'/>
<size>8</size>
