<dec f='qtbase-6.5.0/src/corelib/io/qiodevice.h' l='96' type='bool QIODevice::waitForReadyRead(int msecs)'/>
<def f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='2074' ll='2078' type='bool QIODevice::waitForReadyRead(int msecs)'/>
<doc f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='2051'>/*!
    Blocks until new data is available for reading and the readyRead()
    signal has been emitted, or until \a msecs milliseconds have
    passed. If msecs is -1, this function will not time out.

    Returns \c true if new data is available for reading; otherwise returns
    false (if the operation timed out or if an error occurred).

    This function can operate without an event loop. It is
    useful when writing non-GUI applications and when performing
    I/O operations in a non-GUI thread.

    If called from within a slot connected to the readyRead() signal,
    readyRead() will not be reemitted.

    Reimplement this function to provide a blocking API for a custom
    device. The default implementation does nothing, and returns \c false.

    \warning Calling this function from the main (GUI) thread
    might cause your user interface to freeze.

    \sa waitForBytesWritten()
*/</doc>
<ovr f='qtbase-6.5.0/src/corelib/io/qprocess.cpp' l='1812' c='_ZN8QProcess16waitForReadyReadEi'/>
<ovr f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2131' c='_ZN15QAbstractSocket16waitForReadyReadEi'/>
<ovr f='qtbase-6.5.0/src/network/socket/qlocalsocket_unix.cpp' l='617' c='_ZN12QLocalSocket16waitForReadyReadEi'/>
