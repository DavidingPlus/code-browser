<dec f='qtbase-6.5.0/src/widgets/util/qscroller.h' l='63' type='static Qt::GestureType QScroller::grabGesture(QObject * target, QScroller::ScrollerGestureType gestureType = TouchGesture)'/>
<use f='qtbase-6.5.0/src/widgets/styles/qpixmapstyle.cpp' l='168' u='c' c='_ZN12QPixmapStyle6polishEP7QWidget'/>
<def f='qtbase-6.5.0/src/widgets/util/qscroller.cpp' l='358' ll='394' type='static Qt::GestureType QScroller::grabGesture(QObject * target, QScroller::ScrollerGestureType scrollGestureType = TouchGesture)'/>
<doc f='qtbase-6.5.0/src/widgets/util/qscroller.cpp' l='337'>/*!
    Registers a custom scroll gesture recognizer, grabs it for the \a
    target and returns the resulting gesture type.  If \a scrollGestureType is
    set to TouchGesture the gesture triggers on touch events. If it is set to
    one of LeftMouseButtonGesture, RightMouseButtonGesture or
    MiddleMouseButtonGesture it triggers on mouse events of the
    corresponding button.

    Only one scroll gesture can be active on a single object at the same
    time. If you call this function twice on the same object, it will
    ungrab the existing gesture before grabbing the new one.

    \note To avoid unwanted side-effects, mouse events are consumed while
    the gesture is triggered. Since the initial mouse press event is
    not consumed, the gesture sends a fake mouse release event
    at the global position \c{(INT_MIN, INT_MIN)}. This ensures that
    internal states of the widget that received the original mouse press
    are consistent.

    \sa ungrabGesture(), grabbedGesture()
*/</doc>
