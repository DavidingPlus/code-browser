<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1497' type='void QRhiCommandBuffer::setShaderResources(QRhiShaderResourceBindings * srb = nullptr, int dynamicOffsetCount = 0, const QRhiCommandBuffer::DynamicOffset * dynamicOffsets = nullptr)'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='601' u='c' c='_ZN30QBackingStoreDefaultCompositor5flushEP21QPlatformBackingStoreP4QRhiP13QRhiSwapChainP7QWindowdRK7QRegionRK6QPointP20QPlatformTextureListb'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='611' u='c' c='_ZN30QBackingStoreDefaultCompositor5flushEP21QPlatformBackingStoreP4QRhiP13QRhiSwapChainP7QWindowdRK7QRegionRK6QPointP20QPlatformTextureListb'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='629' u='c' c='_ZN30QBackingStoreDefaultCompositor5flushEP21QPlatformBackingStoreP4QRhiP13QRhiSwapChainP7QWindowdRK7QRegionRK6QPointP20QPlatformTextureListb'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6481' ll='6486' type='void QRhiCommandBuffer::setShaderResources(QRhiShaderResourceBindings * srb = nullptr, int dynamicOffsetCount = 0, const QRhiCommandBuffer::DynamicOffset * dynamicOffsets = nullptr)'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6429'>/*!
    Records binding a set of shader resources, such as, uniform buffers or
    textures, that are made visible to one or more shader stages.

    \a srb can be null in which case the current graphics or compute pipeline&apos;s
    associated QRhiShaderResourceBindings is used. When \a srb is non-null, it
    must be
    \l{QRhiShaderResourceBindings::isLayoutCompatible()}{layout-compatible},
    meaning the layout (number of bindings, the type and binding number of each
    binding) must fully match the QRhiShaderResourceBindings that was
    associated with the pipeline at the time of calling the pipeline&apos;s create().

    There are cases when a seemingly unnecessary setShaderResources() call is
    mandatory: when rebuilding a resource referenced from \a srb, for example
    changing the size of a QRhiBuffer followed by a QRhiBuffer::create(), this
    is the place where associated native objects (such as descriptor sets in
    case of Vulkan) are updated to refer to the current native resources that
    back the QRhiBuffer, QRhiTexture, QRhiSampler objects referenced from \a
    srb. In this case setShaderResources() must be called even if \a srb is
    the same as in the last call.

    When \a srb is not null, the QRhiShaderResourceBindings object the pipeline
    was built with in create() is guaranteed to be not accessed in any form. In
    fact, it does not need to be valid even at this point: destroying the
    pipeline&apos;s associated srb after create() and instead explicitly specifying
    another, \l{QRhiShaderResourceBindings::isLayoutCompatible()}{layout
    compatible} one in every setShaderResources() call is valid.

    \a dynamicOffsets allows specifying buffer offsets for uniform buffers that
    were associated with \a srb via
    QRhiShaderResourceBinding::uniformBufferWithDynamicOffset(). This is
    different from providing the offset in the \a srb itself: dynamic offsets
    do not require building a new QRhiShaderResourceBindings for every
    different offset, can avoid writing the underlying descriptors (with
    backends where applicable), and so they may be more efficient. Each element
    of \a dynamicOffsets is a \c binding - \c offset pair.
    \a dynamicOffsetCount specifies the number of elements in \a dynamicOffsets.

    \note All offsets in \a dynamicOffsets must be byte aligned to the value
    returned from QRhi::ubufAlignment().

    \note Some backends may limit the number of supported dynamic offsets.
    Avoid using a \a dynamicOffsetCount larger than 8.

    \note QRhi will optimize out unnecessary invocations within a pass (taking
    the conditions described above into account), so therefore overoptimizing
    to avoid calls to this function is not necessary on the applications&apos; side.

    \note This function can only be called inside a render or compute pass,
    meaning between a beginPass() and endPass(), or beginComputePass() and
    endComputePass().
 */</doc>
