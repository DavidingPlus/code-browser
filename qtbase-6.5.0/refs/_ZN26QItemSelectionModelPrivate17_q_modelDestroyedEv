<dec f='qtbase-6.5.0/src/corelib/itemmodels/qitemselectionmodel_p.h' l='44' type='void QItemSelectionModelPrivate::_q_modelDestroyed()'/>
<def f='qtbase-6.5.0/src/corelib/itemmodels/qitemselectionmodel.cpp' l='1081' ll='1085' type='void QItemSelectionModelPrivate::_q_modelDestroyed()'/>
<doc f='qtbase-6.5.0/src/corelib/itemmodels/qitemselectionmodel.cpp' l='1054'>/*!
    \internal

    Called when the used model gets destroyed.

    It is impossible to have a correct implementation here.
    In the following situation, there are two contradicting rules:

    \code
    QProperty&lt;QAbstractItemModel *&gt; leader(mymodel);
    QItemSelectionModel myItemSelectionModel;
    myItemSelectionModel.bindableModel().setBinding([&amp;](){ return leader.value(); }
    delete mymodel;
    QAbstractItemModel *returnedModel = myItemSelectionModel.model();
    \endcode

    What should returnedModel be in this situation?

    Rules for bindable properties say that myItemSelectionModel.model()
    should return the same as leader.value(), namely the pointer to the now deleted model.

    However, backward compatibility requires myItemSelectionModel.model() to return a
    nullptr, because that was done in the past after the model used was deleted.

    We decide to break the new rule, imposed by bindable properties, and not break the old
    rule, because that may break existing code.
*/</doc>
