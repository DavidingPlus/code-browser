<dec f='qtbase-6.5.0/src/corelib/tools/qcommandlineparser.h' l='51' type='bool QCommandLineParser::parse(const QStringList &amp; arguments)'/>
<def f='qtbase-6.5.0/src/corelib/tools/qcommandlineparser.cpp' l='490' ll='493' type='bool QCommandLineParser::parse(const QStringList &amp; arguments)'/>
<doc f='qtbase-6.5.0/src/corelib/tools/qcommandlineparser.cpp' l='471'>/*!
    Parses the command line \a arguments.

    Most programs don&apos;t need to call this, a simple call to process() is enough.

    parse() is more low-level, and only does the parsing. The application will have to
    take care of the error handling, using errorText() if parse() returns \c false.
    This can be useful for instance to show a graphical error message in graphical programs.

    Calling parse() instead of process() can also be useful in order to ignore unknown
    options temporarily, because more option definitions will be provided later on
    (depending on one of the arguments), before calling process().

    Don&apos;t forget that \a arguments must start with the name of the executable (ignored, though).

    Returns \c false in case of a parse error (unknown option or missing value); returns \c true otherwise.

    \sa process()
*/</doc>
