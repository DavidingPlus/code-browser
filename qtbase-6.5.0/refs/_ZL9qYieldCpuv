<def f='qtbase-6.5.0/src/corelib/global/qsimd_p.h' l='403' ll='423' type='void qYieldCpu()'/>
<use f='qtbase-6.5.0/src/concurrent/qtconcurrentthreadengine.cpp' l='68' u='c' c='_ZN12QtConcurrent19ThreadEngineBarrier7acquireEv'/>
<use f='qtbase-6.5.0/src/concurrent/qtconcurrentthreadengine.cpp' l='88' u='c' c='_ZN12QtConcurrent19ThreadEngineBarrier7releaseEv'/>
<use f='qtbase-6.5.0/src/concurrent/qtconcurrentthreadengine.cpp' l='105' u='c' c='_ZN12QtConcurrent19ThreadEngineBarrier4waitEv'/>
<use f='qtbase-6.5.0/src/concurrent/qtconcurrentthreadengine.cpp' l='129' u='c' c='_ZN12QtConcurrent19ThreadEngineBarrier17releaseUnlessLastEv'/>
<doc f='qtbase-6.5.0/src/corelib/global/qsimd_p.h' l='381'>/*
    Small wrapper around x86&apos;s PAUSE and ARM&apos;s YIELD instructions.

    This is completely different from QThread::yieldCurrentThread(), which is
    an OS-level operation that takes the whole thread off the CPU.

    This is just preventing one SMT thread from filling a core&apos;s pipeline with
    speculated further loop iterations (which need to be expensively flushed on
    final success) when it could just give those pipeline slots to a second SMT
    thread that can do something useful with the core, such as unblocking this
    SMT thread :)

    So, instead of

        while (!condition)
            ;

    it&apos;s better to use

        while (!condition)
            qYieldCpu();
*/</doc>
<use f='qtbase-6.5.0/src/corelib/thread/qfutureinterface.cpp' l='80' u='c' c='_ZL14switch_from_toR10QAtomicIntii'/>
