<dec f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='5195' type='int sqlite3_step(sqlite3_stmt * )'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='52065' u='c' c='sqlite3_serialize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='52139' u='c' c='sqlite3_deserialize'/>
<def f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='88538' ll='88585' type='int sqlite3_step(sqlite3_stmt * pStmt)'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='99200' u='c' c='blobSeekToRow'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='131948' u='c' c='sqlite3_exec'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='132974'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='137056' u='c' c='pragmaVtabNext'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='149879' u='c' c='execSql'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='180907' u='c' c='fts3DatabasePageSize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='181991' u='c' c='fts3CursorSeek'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='183142' u='c' c='fts3SegReaderCursor'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='183394' u='c' c='fts3NextMethod'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='190847' u='c' c='fts3SelectDocsize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='190870' u='c' c='sqlite3Fts3SelectDoctotal'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='190909' u='c' c='fts3SqlExec'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='190938' u='c' c='fts3Writelock'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='191420' u='c' c='fts3InsertData'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='191482' u='c' c='fts3DeleteTerms'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='191550' u='c' c='fts3AllocateSegdirIdx'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='192339' u='c' c='fts3WriteSegment'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='192358' u='c' c='sqlite3Fts3MaxLevel'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='192396' u='c' c='fts3WriteSegdir'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='192671' u='c' c='fts3SegWriterAdd'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='192854' u='c' c='fts3IsEmpty'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='192893' u='c' c='fts3SegmentMaxLevel'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='192924' u='c' c='fts3SegmentIsMaxLevel'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='192946' u='c' c='fts3DeleteSegment'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193005' u='c' c='fts3DeleteSegdir'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193543' u='c' c='fts3PromoteSegments'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193583' u='c' c='fts3PromoteSegments'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193587' u='c' c='fts3PromoteSegments'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193602' u='c' c='fts3PromoteSegments'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193742' u='c' c='sqlite3Fts3PendingTermsFlush'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193822' u='c' c='fts3InsertDocsize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193871' u='c' c='fts3UpdateDocTotals'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193907' u='c' c='fts3UpdateDocTotals'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193930' u='c' c='fts3DoOptimize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='193992' u='c' c='fts3DoRebuild'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194066' u='c' c='fts3IncrmergeCsr'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194628' u='c' c='fts3IsAppendable'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194675' u='c' c='fts3IncrmergeLoad'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194813' u='c' c='fts3IncrmergeOutputIdx'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194865' u='c' c='fts3IncrmergeWriter'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194875' u='c' c='fts3IncrmergeWriter'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194924' u='c' c='fts3RemoveSegdirEntry'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194952' u='c' c='fts3RepackSegdirLevel'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='194982' u='c' c='fts3RepackSegdirLevel'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195089' u='c' c='fts3TruncateSegment'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195121' u='c' c='fts3TruncateSegment'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195134' u='c' c='fts3TruncateSegment'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195214' u='c' c='fts3IncrmergeHintStore'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195239' u='c' c='fts3IncrmergeHintLoad'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195350' u='c' c='sqlite3Fts3Incrmerge'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195572' u='c' c='fts3DoAutoincrmerge'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195701' u='c' c='fts3IntegrityCheck'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='195726' u='c' c='fts3IntegrityCheck'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='202350' u='c' c='nodeWrite'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='203228' u='c' c='rtreeColumn'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='203259' u='c' c='findLeafNode'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='203772' u='c' c='rowidWrite'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='203782' u='c' c='parentWrite'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204207' u='c' c='fixLeafParent'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204262' u='c' c='removeNode'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204269' u='c' c='removeNode'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204517' u='c' c='rtreeNewRowid'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204563' u='c' c='rtreeDeleteRowid'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204771' u='c' c='rtreeUpdate'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204827' u='c' c='rtreeUpdate'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204929' u='c' c='rtreeQueryStat1'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='205120' u='c' c='getIntFromStmt'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='205521' u='c' c='rtreeCheckGetNode'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='205576' u='c' c='rtreeCheckMapping'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='205721' u='c' c='rtreeCheckCount'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='205782' u='c' c='rtreeCheckTable'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='207441' u='c' c='geopolyColumn'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='207528' u='c' c='geopolyUpdate'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='207600' u='c' c='geopolyUpdate'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='226930' u='c' c='sqlite3Fts5ConfigLoad'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='231368' u='c' c='fts5DataWrite'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='231392' u='c' c='fts5DataDelete'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='231412' u='c' c='fts5DataRemoveSegment'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='231681' u='c' c='fts5IndexDataVersion'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='233058' u='c' c='fts5SegIterSeekInit'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='234424' u='c' c='fts5WriteFlushBtree'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='236708' u='c' c='fts5IndexIntegrityCheckSegment'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='238235' u='c' c='fts5SorterNext'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='238360' u='c' c='fts5NextMethod'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='238544' u='c' c='fts5FindRankFunction'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='238906' u='c' c='fts5SeekCursor'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='240768' u='c' c='fts5StorageDeleteFromIndex'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='240833' u='c' c='fts5StorageInsertDocsize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='240907' u='c' c='sqlite3Fts5StorageDelete'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='240919' u='c' c='sqlite3Fts5StorageDelete'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='240979' u='c' c='sqlite3Fts5StorageRebuild'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='241045' u='c' c='fts5StorageNewRowid'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='241081' u='c' c='sqlite3Fts5StorageContentInsert'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='241150' u='c' c='fts5StorageCount'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='241273' u='c' c='sqlite3Fts5StorageIntegrity'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='241429' u='c' c='sqlite3Fts5StorageDocsize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='241516' u='c' c='sqlite3Fts5StorageConfigValue'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='244424' u='c' c='fts5VocabOpenMethod'/>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='5113'>/*
** CAPI3REF: Evaluate An SQL Statement
** METHOD: sqlite3_stmt
**
** After a [prepared statement] has been prepared using any of
** [sqlite3_prepare_v2()], [sqlite3_prepare_v3()], [sqlite3_prepare16_v2()],
** or [sqlite3_prepare16_v3()] or one of the legacy
** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this function
** must be called one or more times to evaluate the statement.
**
** The details of the behavior of the sqlite3_step() interface depend
** on whether the statement was prepared using the newer &quot;vX&quot; interfaces
** [sqlite3_prepare_v3()], [sqlite3_prepare_v2()], [sqlite3_prepare16_v3()],
** [sqlite3_prepare16_v2()] or the older legacy
** interfaces [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the
** new &quot;vX&quot; interface is recommended for new applications but the legacy
** interface will continue to be supported.
**
** ^In the legacy interface, the return value will be either [SQLITE_BUSY],
** [SQLITE_DONE], [SQLITE_ROW], [SQLITE_ERROR], or [SQLITE_MISUSE].
** ^With the &quot;v2&quot; interface, any of the other [result codes] or
** [extended result codes] might be returned as well.
**
** ^[SQLITE_BUSY] means that the database engine was unable to acquire the
** database locks it needs to do its job.  ^If the statement is a [COMMIT]
** or occurs outside of an explicit transaction, then you can retry the
** statement.  If the statement is not a [COMMIT] and occurs within an
** explicit transaction then you should rollback the transaction before
** continuing.
**
** ^[SQLITE_DONE] means that the statement has finished executing
** successfully.  sqlite3_step() should not be called again on this virtual
** machine without first calling [sqlite3_reset()] to reset the virtual
** machine back to its initial state.
**
** ^If the SQL statement being executed returns any data, then [SQLITE_ROW]
** is returned each time a new row of data is ready for processing by the
** caller. The values may be accessed using the [column access functions].
** sqlite3_step() is called again to retrieve the next row of data.
**
** ^[SQLITE_ERROR] means that a run-time error (such as a constraint
** violation) has occurred.  sqlite3_step() should not be called again on
** the VM. More information may be found by calling [sqlite3_errmsg()].
** ^With the legacy interface, a more specific error code (for example,
** [SQLITE_INTERRUPT], [SQLITE_SCHEMA], [SQLITE_CORRUPT], and so forth)
** can be obtained by calling [sqlite3_reset()] on the
** [prepared statement].  ^In the &quot;v2&quot; interface,
** the more specific error code is returned directly by sqlite3_step().
**
** [SQLITE_MISUSE] means that the this routine was called inappropriately.
** Perhaps it was called on a [prepared statement] that has
** already been [sqlite3_finalize | finalized] or on one that had
** previously returned [SQLITE_ERROR] or [SQLITE_DONE].  Or it could
** be the case that the same database connection is being used by two or
** more threads at the same moment in time.
**
** For all versions of SQLite up to and including 3.6.23.1, a call to
** [sqlite3_reset()] was required after sqlite3_step() returned anything
** other than [SQLITE_ROW] before any subsequent invocation of
** sqlite3_step().  Failure to reset the prepared statement using
** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return from
** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],
** sqlite3_step() began
** calling [sqlite3_reset()] automatically in this circumstance rather
** than returning [SQLITE_MISUSE].  This is not considered a compatibility
** break because any application that ever receives an SQLITE_MISUSE error
** is broken by definition.  The [SQLITE_OMIT_AUTORESET] compile-time option
** can be used to restore the legacy behavior.
**
** &lt;b&gt;Goofy Interface Alert:&lt;/b&gt; In the legacy interface, the sqlite3_step()
** API always returns a generic error code, [SQLITE_ERROR], following any
** error other than [SQLITE_BUSY] and [SQLITE_MISUSE].  You must call
** [sqlite3_reset()] or [sqlite3_finalize()] in order to find one of the
** specific [error codes] that better describes the error.
** We admit that this is a goofy design.  The problem has been fixed
** with the &quot;v2&quot; interface.  If you prepare all of your SQL statements
** using [sqlite3_prepare_v3()] or [sqlite3_prepare_v2()]
** or [sqlite3_prepare16_v2()] or [sqlite3_prepare16_v3()] instead
** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,
** then the more specific [error codes] are returned directly
** by sqlite3_step().  The use of the &quot;vX&quot; interfaces is recommended.
*/</doc>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='88533'>/*
** This is the top-level implementation of sqlite3_step().  Call
** sqlite3Step() to do most of the work.  If a schema error occurs,
** call sqlite3Reprepare() and try again.
*/</doc>
<dec f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.h' l='4889' type='int sqlite3_step(sqlite3_stmt * )'/>
<use f='qtbase-6.5.0/src/plugins/sqldrivers/sqlite/qsql_sqlite.cpp' l='243' u='c' c='_ZN20QSQLiteResultPrivate9fetchNextER5QListI8QVariantEib'/>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.h' l='4807'>/*
** CAPI3REF: Evaluate An SQL Statement
** METHOD: sqlite3_stmt
**
** After a [prepared statement] has been prepared using any of
** [sqlite3_prepare_v2()], [sqlite3_prepare_v3()], [sqlite3_prepare16_v2()],
** or [sqlite3_prepare16_v3()] or one of the legacy
** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this function
** must be called one or more times to evaluate the statement.
**
** The details of the behavior of the sqlite3_step() interface depend
** on whether the statement was prepared using the newer &quot;vX&quot; interfaces
** [sqlite3_prepare_v3()], [sqlite3_prepare_v2()], [sqlite3_prepare16_v3()],
** [sqlite3_prepare16_v2()] or the older legacy
** interfaces [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the
** new &quot;vX&quot; interface is recommended for new applications but the legacy
** interface will continue to be supported.
**
** ^In the legacy interface, the return value will be either [SQLITE_BUSY],
** [SQLITE_DONE], [SQLITE_ROW], [SQLITE_ERROR], or [SQLITE_MISUSE].
** ^With the &quot;v2&quot; interface, any of the other [result codes] or
** [extended result codes] might be returned as well.
**
** ^[SQLITE_BUSY] means that the database engine was unable to acquire the
** database locks it needs to do its job.  ^If the statement is a [COMMIT]
** or occurs outside of an explicit transaction, then you can retry the
** statement.  If the statement is not a [COMMIT] and occurs within an
** explicit transaction then you should rollback the transaction before
** continuing.
**
** ^[SQLITE_DONE] means that the statement has finished executing
** successfully.  sqlite3_step() should not be called again on this virtual
** machine without first calling [sqlite3_reset()] to reset the virtual
** machine back to its initial state.
**
** ^If the SQL statement being executed returns any data, then [SQLITE_ROW]
** is returned each time a new row of data is ready for processing by the
** caller. The values may be accessed using the [column access functions].
** sqlite3_step() is called again to retrieve the next row of data.
**
** ^[SQLITE_ERROR] means that a run-time error (such as a constraint
** violation) has occurred.  sqlite3_step() should not be called again on
** the VM. More information may be found by calling [sqlite3_errmsg()].
** ^With the legacy interface, a more specific error code (for example,
** [SQLITE_INTERRUPT], [SQLITE_SCHEMA], [SQLITE_CORRUPT], and so forth)
** can be obtained by calling [sqlite3_reset()] on the
** [prepared statement].  ^In the &quot;v2&quot; interface,
** the more specific error code is returned directly by sqlite3_step().
**
** [SQLITE_MISUSE] means that the this routine was called inappropriately.
** Perhaps it was called on a [prepared statement] that has
** already been [sqlite3_finalize | finalized] or on one that had
** previously returned [SQLITE_ERROR] or [SQLITE_DONE].  Or it could
** be the case that the same database connection is being used by two or
** more threads at the same moment in time.
**
** For all versions of SQLite up to and including 3.6.23.1, a call to
** [sqlite3_reset()] was required after sqlite3_step() returned anything
** other than [SQLITE_ROW] before any subsequent invocation of
** sqlite3_step().  Failure to reset the prepared statement using
** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return from
** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],
** sqlite3_step() began
** calling [sqlite3_reset()] automatically in this circumstance rather
** than returning [SQLITE_MISUSE].  This is not considered a compatibility
** break because any application that ever receives an SQLITE_MISUSE error
** is broken by definition.  The [SQLITE_OMIT_AUTORESET] compile-time option
** can be used to restore the legacy behavior.
**
** &lt;b&gt;Goofy Interface Alert:&lt;/b&gt; In the legacy interface, the sqlite3_step()
** API always returns a generic error code, [SQLITE_ERROR], following any
** error other than [SQLITE_BUSY] and [SQLITE_MISUSE].  You must call
** [sqlite3_reset()] or [sqlite3_finalize()] in order to find one of the
** specific [error codes] that better describes the error.
** We admit that this is a goofy design.  The problem has been fixed
** with the &quot;v2&quot; interface.  If you prepare all of your SQL statements
** using [sqlite3_prepare_v3()] or [sqlite3_prepare_v2()]
** or [sqlite3_prepare16_v2()] or [sqlite3_prepare16_v3()] instead
** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,
** then the more specific [error codes] are returned directly
** by sqlite3_step().  The use of the &quot;vX&quot; interfaces is recommended.
*/</doc>
