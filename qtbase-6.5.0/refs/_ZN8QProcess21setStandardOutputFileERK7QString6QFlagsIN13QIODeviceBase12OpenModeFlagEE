<dec f='qtbase-6.5.0/src/corelib/io/qprocess.h' l='149' type='void QProcess::setStandardOutputFile(const QString &amp; fileName, QIODeviceBase::OpenMode mode = Truncate)'/>
<def f='qtbase-6.5.0/src/corelib/io/qprocess.cpp' l='1423' ll='1430' type='void QProcess::setStandardOutputFile(const QString &amp; fileName, QIODeviceBase::OpenMode mode = Truncate)'/>
<use f='qtbase-6.5.0/src/corelib/io/qprocess.cpp' l='2183' u='c' c='_ZN15QProcessPrivate5startE6QFlagsIN13QIODeviceBase12OpenModeFlagEE'/>
<doc f='qtbase-6.5.0/src/corelib/io/qprocess.cpp' l='1394'>/*!
    \since 4.2

    Redirects the process&apos; standard output to the file \a
    fileName. When the redirection is in place, the standard output
    read channel is closed: reading from it using read() will always
    fail, as will readAllStandardOutput().

    To discard all standard output from the process, pass nullDevice()
    here. This is more efficient than simply never reading the standard
    output, as no QProcess buffers are filled.

    If the file \a fileName doesn&apos;t exist at the moment start() is
    called, it will be created. If it cannot be created, the starting
    will fail.

    If the file exists and \a mode is QIODevice::Truncate, the file
    will be truncated. Otherwise (if \a mode is QIODevice::Append),
    the file will be appended to.

    Calling setStandardOutputFile() after the process has started has
    no effect.

    If \a fileName is an empty string, it stops redirecting the standard
    output. This is useful for restoring the standard output after redirection.

    \sa setStandardInputFile(), setStandardErrorFile(),
        setStandardOutputProcess()
*/</doc>
