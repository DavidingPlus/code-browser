<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.h' l='248' c='_ZN10QCborValue8fromCborER17QCborStreamReader'/>
<def f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='27' ll='165'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='68' c='_ZN17QCborStreamReaderC1ERKS_'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='68' c='_ZN17QCborStreamReaderaSERKS_'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='68' c='_ZN17QCborStreamReaderaSERKS_'/>
<size>24</size>
<smbr r='QCborStreamReader::staticMetaObject' t='const QMetaObject'/>
<fun r='_ZN17QCborStreamReader26qt_check_for_QGADGET_macroEv'/>
<fun r='_ZN17QCborStreamReader18qt_static_metacallEP7QObjectN11QMetaObject4CallEiPPv'/>
<fun r='_ZN17QCborStreamReaderC1Ev'/>
<fun r='_ZN17QCborStreamReaderC1EPKcx'/>
<fun r='_ZN17QCborStreamReaderC1EPKhx'/>
<fun r='_ZN17QCborStreamReaderC1ERK10QByteArray'/>
<fun r='_ZN17QCborStreamReaderC1EP9QIODevice'/>
<fun r='_ZN17QCborStreamReaderD1Ev'/>
<fun r='_ZN17QCborStreamReaderC1ERKS_'/>
<fun r='_ZN17QCborStreamReader9setDeviceEP9QIODevice'/>
<fun r='_ZNK17QCborStreamReader6deviceEv'/>
<fun r='_ZN17QCborStreamReader7addDataERK10QByteArray'/>
<fun r='_ZN17QCborStreamReader7addDataEPKcx'/>
<fun r='_ZN17QCborStreamReader7addDataEPKhx'/>
<fun r='_ZN17QCborStreamReader7reparseEv'/>
<fun r='_ZN17QCborStreamReader5clearEv'/>
<fun r='_ZN17QCborStreamReader5resetEv'/>
<fun r='_ZN17QCborStreamReader9lastErrorEv'/>
<fun r='_ZNK17QCborStreamReader13currentOffsetEv'/>
<fun r='_ZNK17QCborStreamReader7isValidEv'/>
<fun r='_ZNK17QCborStreamReader14containerDepthEv'/>
<fun r='_ZNK17QCborStreamReader19parentContainerTypeEv'/>
<fun r='_ZNK17QCborStreamReader7hasNextEv'/>
<fun r='_ZN17QCborStreamReader4nextEi'/>
<fun r='_ZNK17QCborStreamReader4typeEv'/>
<fun r='_ZNK17QCborStreamReader17isUnsignedIntegerEv'/>
<fun r='_ZNK17QCborStreamReader17isNegativeIntegerEv'/>
<fun r='_ZNK17QCborStreamReader9isIntegerEv'/>
<fun r='_ZNK17QCborStreamReader11isByteArrayEv'/>
<fun r='_ZNK17QCborStreamReader8isStringEv'/>
<fun r='_ZNK17QCborStreamReader7isArrayEv'/>
<fun r='_ZNK17QCborStreamReader5isMapEv'/>
<fun r='_ZNK17QCborStreamReader5isTagEv'/>
<fun r='_ZNK17QCborStreamReader12isSimpleTypeEv'/>
<fun r='_ZNK17QCborStreamReader9isFloat16Ev'/>
<fun r='_ZNK17QCborStreamReader7isFloatEv'/>
<fun r='_ZNK17QCborStreamReader8isDoubleEv'/>
<fun r='_ZNK17QCborStreamReader9isInvalidEv'/>
<fun r='_ZNK17QCborStreamReader12isSimpleTypeE15QCborSimpleType'/>
<fun r='_ZNK17QCborStreamReader7isFalseEv'/>
<fun r='_ZNK17QCborStreamReader6isTrueEv'/>
<fun r='_ZNK17QCborStreamReader6isBoolEv'/>
<fun r='_ZNK17QCborStreamReader6isNullEv'/>
<fun r='_ZNK17QCborStreamReader11isUndefinedEv'/>
<fun r='_ZNK17QCborStreamReader13isLengthKnownEv'/>
<fun r='_ZNK17QCborStreamReader6lengthEv'/>
<fun r='_ZNK17QCborStreamReader11isContainerEv'/>
<fun r='_ZN17QCborStreamReader14enterContainerEv'/>
<fun r='_ZN17QCborStreamReader14leaveContainerEv'/>
<fun r='_ZN17QCborStreamReader10readStringEv'/>
<fun r='_ZN17QCborStreamReader13readByteArrayEv'/>
<fun r='_ZNK17QCborStreamReader22currentStringChunkSizeEv'/>
<fun r='_ZN17QCborStreamReader15readStringChunkEPcx'/>
<fun r='_ZNK17QCborStreamReader6toBoolEv'/>
<fun r='_ZNK17QCborStreamReader5toTagEv'/>
<fun r='_ZNK17QCborStreamReader17toUnsignedIntegerEv'/>
<fun r='_ZNK17QCborStreamReader17toNegativeIntegerEv'/>
<fun r='_ZNK17QCborStreamReader12toSimpleTypeEv'/>
<fun r='_ZNK17QCborStreamReader9toFloat16Ev'/>
<fun r='_ZNK17QCborStreamReader7toFloatEv'/>
<fun r='_ZNK17QCborStreamReader8toDoubleEv'/>
<fun r='_ZNK17QCborStreamReader9toIntegerEv'/>
<fun r='_ZN17QCborStreamReader8preparseEv'/>
<fun r='_ZN17QCborStreamReader22_enterContainer_helperEv'/>
<fun r='_ZN17QCborStreamReader18_readString_helperEv'/>
<fun r='_ZN17QCborStreamReader21_readByteArray_helperEv'/>
<fun r='_ZNK17QCborStreamReader23_currentStringChunkSizeEv'/>
<fun r='_ZNK17QCborStreamReader16_toFloatingPointEv'/>
<mbr r='QCborStreamReader::value64' o='0' t='quint64'/>
<mbr r='QCborStreamReader::d' o='64' t='QScopedPointer&lt;QCborStreamReaderPrivate&gt;'/>
<mbr r='QCborStreamReader::type_' o='128' t='quint8'/>
<mbr r='QCborStreamReader::reserved' o='136' t='quint8[3]'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue_p.h' l='441' c='_ZN21QCborContainerPrivate19decodeValueFromCborER17QCborStreamReaderi'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue_p.h' l='442' c='_ZN21QCborContainerPrivate20decodeStringFromCborER17QCborStreamReader'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue_p.h' l='443' c='_ZN21QCborContainerPrivate16setErrorInReaderER17QCborStreamReader10QCborError'/>
<size>24</size>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='631' c='_ZN24QCborStreamReaderPrivate17appendStringChunkER17QCborStreamReaderP10QByteArray'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='765' c='_ZN17QCborStreamReaderC1EPKcx'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='776' c='_ZN17QCborStreamReaderC1EPKhx'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='1420' c='_Z27qt_cbor_append_string_chunkR17QCborStreamReaderP10QByteArray'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='1426' c='_ZN24QCborStreamReaderPrivate17appendStringChunkER17QCborStreamReaderP10QByteArray'/>
<size>24</size>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='59'>/*!
   \class QCborStreamReader
   \inmodule QtCore
   \ingroup cbor
   \ingroup qtserialization
   \reentrant
   \since 5.12

   \brief The QCborStreamReader class is a simple CBOR stream decoder, operating
   on either a QByteArray or QIODevice.

   This class can be used to decode a stream of CBOR content directly from
   either a QByteArray or a QIODevice. CBOR is the Concise Binary Object
   Representation, a very compact form of binary data encoding that is
   compatible with JSON. It was created by the IETF Constrained RESTful
   Environments (CoRE) WG, which has used it in many new RFCs. It is meant to
   be used alongside the \l{RFC 7252}{CoAP
   protocol}.

   QCborStreamReader provides a StAX-like API, similar to that of
   \l{QXmlStreamReader}. Using it requires a bit of knowledge of CBOR encoding.
   For a simpler API, see \l{QCborValue} and especially the decoding function
   QCborValue::fromCbor().

   Typically, one creates a QCborStreamReader by passing the source QByteArray
   or QIODevice as a parameter to the constructor, then pop elements off the
   stream if there were no errors in decoding. There are three kinds of CBOR
   types:

   \table
     \header \li Kind       \li Types       \li Behavior
     \row   \li Fixed-width \li Integers, Tags, Simple types, Floating point
            \li Value is pre-parsed by QCborStreamReader, so accessor functions
                are \c const. Must call next() to advance.
     \row   \li Strings     \li Byte arrays, Text strings
            \li Length (if known) is pre-parsed, but the string itself is not.
                The accessor functions are not const and may allocate memory.
                Once called, the accessor functions automatically advance to
                the next element.
     \row   \li Containers  \li Arrays, Maps
            \li Length (if known) is pre-parsed. To access the elements, you
                must call enterContainer(), read all elements, then call
                leaveContainer(). That function advances to the next element.
   \endtable

   So a processor function typically looks like this:

   \snippet code/src_corelib_serialization_qcborstream.cpp 24

   \section1 CBOR support

   The following table lists the CBOR features that QCborStreamReader supports.

   \table
     \header \li Feature                        \li Support
     \row   \li Unsigned numbers                \li Yes (full range)
     \row   \li Negative numbers                \li Yes (full range)
     \row   \li Byte strings                    \li Yes
     \row   \li Text strings                    \li Yes
     \row   \li Chunked strings                 \li Yes
     \row   \li Tags                            \li Yes (arbitrary)
     \row   \li Booleans                        \li Yes
     \row   \li Null                            \li Yes
     \row   \li Undefined                       \li Yes
     \row   \li Arbitrary simple values         \li Yes
     \row   \li Half-precision float (16-bit)   \li Yes
     \row   \li Single-precision float (32-bit) \li Yes
     \row   \li Double-precision float (64-bit) \li Yes
     \row   \li Infinities and NaN floating point \li Yes
     \row   \li Determinate-length arrays and maps \li Yes
     \row   \li Indeterminate-length arrays and maps \li Yes
     \row   \li Map key types other than strings and integers \li Yes (arbitrary)
   \endtable

   \section1 Dealing with invalid or incomplete CBOR streams

   QCborStreamReader is capable of detecting corrupt input on its own. The
   library it uses has been extensively tested against invalid input of any
   kind and is quite able to report errors. If any is detected,
   QCborStreamReader will set lastError() to a value besides
   QCborError::NoError, indicating which situation was detected.

   Most errors detected by QCborStreamReader during normal item parsing are not
   recoverable. The code using QCborStreamReader may opt to handle the data
   that was properly decoded or it can opt to discard the entire data.

   The only recoverable error is QCborError::EndOfFile, which indicates that
   more data is required in order to complete the parsing. This situation is
   useful when data is being read from an asynchronous source, such as a pipe
   (QProcess) or a socket (QTcpSocket, QUdpSocket, QNetworkReply, etc.). When
   more data arrives, the surrounding code needs to call either addData(), if
   parsing from a QByteArray, or reparse(), if it is instead reading directly
   a the QIDOevice that now has more data available (see setDevice()).

   \sa QCborStreamWriter, QCborValue, QXmlStreamReader, {Cbordump Example}
   \sa {Convert Example}, {JSON Save Game Example}
 */</doc>
<fun r='_ZN17QCborStreamReader8preparseEv'/>
<fun r='_ZN17QCborStreamReaderC1Ev'/>
<fun r='_ZN17QCborStreamReaderC1EPKcx'/>
<fun r='_ZN17QCborStreamReaderC1EPKhx'/>
<fun r='_ZN17QCborStreamReaderC1ERK10QByteArray'/>
<fun r='_ZN17QCborStreamReaderC1EP9QIODevice'/>
<fun r='_ZN17QCborStreamReaderD1Ev'/>
<fun r='_ZN17QCborStreamReader9setDeviceEP9QIODevice'/>
<fun r='_ZNK17QCborStreamReader6deviceEv'/>
<fun r='_ZN17QCborStreamReader7addDataERK10QByteArray'/>
<fun r='_ZN17QCborStreamReader7addDataEPKcx'/>
<fun r='_ZN17QCborStreamReader7reparseEv'/>
<fun r='_ZN17QCborStreamReader5clearEv'/>
<fun r='_ZN17QCborStreamReader5resetEv'/>
<fun r='_ZN17QCborStreamReader9lastErrorEv'/>
<fun r='_ZNK17QCborStreamReader13currentOffsetEv'/>
<fun r='_ZNK17QCborStreamReader14containerDepthEv'/>
<fun r='_ZNK17QCborStreamReader19parentContainerTypeEv'/>
<fun r='_ZNK17QCborStreamReader7hasNextEv'/>
<fun r='_ZN17QCborStreamReader4nextEi'/>
<fun r='_ZNK17QCborStreamReader13isLengthKnownEv'/>
<fun r='_ZNK17QCborStreamReader6lengthEv'/>
<fun r='_ZN17QCborStreamReader22_enterContainer_helperEv'/>
<fun r='_ZN17QCborStreamReader14leaveContainerEv'/>
<fun r='_ZN17QCborStreamReader18_readString_helperEv'/>
<fun r='_ZN17QCborStreamReader21_readByteArray_helperEv'/>
<fun r='_ZNK17QCborStreamReader23_currentStringChunkSizeEv'/>
<fun r='_ZN17QCborStreamReader15readStringChunkEPcx'/>
