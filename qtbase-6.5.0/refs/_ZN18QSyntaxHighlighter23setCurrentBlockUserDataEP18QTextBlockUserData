<dec f='qtbase-6.5.0/src/gui/text/qsyntaxhighlighter.h' l='52' type='void QSyntaxHighlighter::setCurrentBlockUserData(QTextBlockUserData * data)'/>
<def f='qtbase-6.5.0/src/gui/text/qsyntaxhighlighter.cpp' l='545' ll='552' type='void QSyntaxHighlighter::setCurrentBlockUserData(QTextBlockUserData * data)'/>
<doc f='qtbase-6.5.0/src/gui/text/qsyntaxhighlighter.cpp' l='511'>/*!
    Attaches the given \a data to the current text block.  The
    ownership is passed to the underlying text document, i.e. the
    provided QTextBlockUserData object will be deleted if the
    corresponding text block gets deleted.

    QTextBlockUserData can be used to store custom settings. In the
    case of syntax highlighting, it is in particular interesting as
    cache storage for information that you may figure out while
    parsing the paragraph&apos;s text.

    For example while parsing the text, you can keep track of
    parenthesis characters that you encounter (&apos;{[(&apos; and the like),
    and store their relative position and the actual QChar in a simple
    class derived from QTextBlockUserData:

    \snippet code/src_gui_text_qsyntaxhighlighter.cpp 3

    During cursor navigation in the associated editor, you can ask the
    current QTextBlock (retrieved using the QTextCursor::block()
    function) if it has a user data object set and cast it to your \c
    BlockData object. Then you can check if the current cursor
    position matches with a previously recorded parenthesis position,
    and, depending on the type of parenthesis (opening or closing),
    find the next opening or closing parenthesis on the same level.

    In this way you can do a visual parenthesis matching and highlight
    from the current cursor position to the matching parenthesis. That
    makes it easier to spot a missing parenthesis in your code and to
    find where a corresponding opening/closing parenthesis is when
    editing parenthesis intensive code.

    \sa QTextBlock::setUserData()
*/</doc>
