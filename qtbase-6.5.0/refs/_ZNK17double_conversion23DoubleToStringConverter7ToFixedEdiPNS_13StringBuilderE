<dec f='qtbase-6.5.0/src/3rdparty/double-conversion/double-conversion/double-to-string.h' l='260' type='bool double_conversion::DoubleToStringConverter::ToFixed(double value, int requested_digits, double_conversion::StringBuilder * result_builder) const'/>
<def f='qtbase-6.5.0/src/3rdparty/double-conversion/double-conversion/double-to-string.cc' l='205' ll='238' type='bool double_conversion::DoubleToStringConverter::ToFixed(double value, int requested_digits, double_conversion::StringBuilder * result_builder) const'/>
<doc f='qtbase-6.5.0/src/3rdparty/double-conversion/double-conversion/double-to-string.h' l='225'>// Computes a decimal representation with a fixed number of digits after the
  // decimal point. The last emitted digit is rounded.
  //
  // Examples:
  //   ToFixed(3.12, 1) -&gt; &quot;3.1&quot;
  //   ToFixed(3.1415, 3) -&gt; &quot;3.142&quot;
  //   ToFixed(1234.56789, 4) -&gt; &quot;1234.5679&quot;
  //   ToFixed(1.23, 5) -&gt; &quot;1.23000&quot;
  //   ToFixed(0.1, 4) -&gt; &quot;0.1000&quot;
  //   ToFixed(1e30, 2) -&gt; &quot;1000000000000000019884624838656.00&quot;
  //   ToFixed(0.1, 30) -&gt; &quot;0.100000000000000005551115123126&quot;
  //   ToFixed(0.1, 17) -&gt; &quot;0.10000000000000001&quot;
  //
  // If requested_digits equals 0, then the tail of the result depends on
  // the EMIT_TRAILING_DECIMAL_POINT and EMIT_TRAILING_ZERO_AFTER_POINT.
  // Examples, for requested_digits == 0,
  //   let EMIT_TRAILING_DECIMAL_POINT and EMIT_TRAILING_ZERO_AFTER_POINT be
  //    - false and false: then 123.45 -&gt; 123
  //                             0.678 -&gt; 1
  //    - true and false: then 123.45 -&gt; 123.
  //                            0.678 -&gt; 1.
  //    - true and true: then 123.45 -&gt; 123.0
  //                           0.678 -&gt; 1.0
  //
  // Returns true if the conversion succeeds. The conversion always succeeds
  // except for the following cases:
  //   - the input value is special and no infinity_symbol or nan_symbol has
  //     been provided to the constructor,
  //   - &apos;value&apos; &gt; 10^kMaxFixedDigitsBeforePoint, or
  //   - &apos;requested_digits&apos; &gt; kMaxFixedDigitsAfterPoint.
  // The last two conditions imply that the result for non-special values never
  // contains more than
  //  1 + kMaxFixedDigitsBeforePoint + 1 + kMaxFixedDigitsAfterPoint characters
  // (one additional character for the sign, and one for the decimal point).
  // In addition, the buffer must be able to hold the trailing &apos;\0&apos; character.</doc>
