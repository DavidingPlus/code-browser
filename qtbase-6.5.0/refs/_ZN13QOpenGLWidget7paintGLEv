<dec f='qtbase-6.5.0/src/openglwidgets/qopenglwidget.h' l='71' type='void QOpenGLWidget::paintGL()'/>
<use f='qtbase-6.5.0/src/openglwidgets/qopenglwidget.cpp' l='962' u='c' c='_ZN20QOpenGLWidgetPrivate6renderEv'/>
<use f='qtbase-6.5.0/src/openglwidgets/qopenglwidget.cpp' l='967' u='c' c='_ZN20QOpenGLWidgetPrivate6renderEv'/>
<def f='qtbase-6.5.0/src/openglwidgets/qopenglwidget.cpp' l='1435' ll='1437' type='void QOpenGLWidget::paintGL()'/>
<doc f='qtbase-6.5.0/src/openglwidgets/qopenglwidget.cpp' l='1413'>/*!
  This virtual function is called whenever the widget needs to be
  painted. Reimplement it in a subclass.

  There is no need to call makeCurrent() because this has already
  been done when this function is called.

  Before invoking this function, the context and the framebuffer are
  bound, and the viewport is set up by a call to glViewport(). No
  other state is set and no clearing or drawing is performed by the
  framework.

  When \l QSurfaceFormat::StereoBuffers is enabled, this function
  will be called twice - once for each buffer. Query what buffer is
  currently bound by calling currentTargetBuffer().

  \note The framebuffer of each target will be drawn to even when
  stereoscopic rendering is not supported by the hardware.
  Only the left buffer will actually be visible in the window.

  \sa initializeGL(), resizeGL(), currentTargetBuffer()
*/</doc>
