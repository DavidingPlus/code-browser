<dec f='qtbase-6.5.0/src/opengl/qopenglwindow.h' l='38' type='void QOpenGLWindow::makeCurrent()'/>
<use f='qtbase-6.5.0/src/opengl/qopenglwindow.cpp' l='176' u='c' c='_ZN20QOpenGLWindowPrivateD1Ev'/>
<use f='qtbase-6.5.0/src/opengl/qopenglwindow.cpp' l='353' u='c' c='_ZN13QOpenGLWindowD1Ev'/>
<def f='qtbase-6.5.0/src/opengl/qopenglwindow.cpp' l='396' ll='417' type='void QOpenGLWindow::makeCurrent()'/>
<use f='qtbase-6.5.0/src/opengl/qopenglwindow.cpp' l='497' u='c' c='_ZN13QOpenGLWindow15grabFramebufferEv'/>
<doc f='qtbase-6.5.0/src/opengl/qopenglwindow.cpp' l='376'>/*!
  Prepares for rendering OpenGL content for this window by making the
  corresponding context current and binding the framebuffer object, if there is
  one, in that context context.

  It is not necessary to call this function in most cases, because it is called
  automatically before invoking paintGL(). It is provided nonetheless to support
  advanced, multi-threaded scenarios where a thread different than the GUI or main
  thread may want to update the surface or framebuffer contents. See QOpenGLContext
  for more information on threading related issues.

  This function is suitable for calling also when the underlying platform window
  is already destroyed. This means that it is safe to call this function from
  a QOpenGLWindow subclass&apos; destructor. If there is no native window anymore,
  an offscreen surface is used instead. This ensures that OpenGL resource
  cleanup operations in the destructor will always work, as long as
  this function is called first.

  \sa QOpenGLContext, context(), paintGL(), doneCurrent()
 */</doc>
