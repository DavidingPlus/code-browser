<dec f='qtbase-6.5.0/src/3rdparty/forkfd/forkfd.h' l='56' type='int vforkfd(int flags, pid_t * ppid, int (*)(void *) childFn, void * token)'/>
<def f='qtbase-6.5.0/src/3rdparty/forkfd/forkfd.c' l='809' ll='825' type='int vforkfd(int flags, pid_t * ppid, int (*)(void *) childFn, void * token)'/>
<doc f='qtbase-6.5.0/src/3rdparty/forkfd/forkfd.c' l='776'>/**
 * @brief vforkfd returns a file descriptor representing a child process
 * @return a file descriptor, or -1 in case of failure
 *
 * vforkfd() operates in the same way as forkfd() and the @a flags and @a ppid
 * arguments are the same. See the forkfd() documentation for details on the
 * possible values and information on the returned file descriptor.
 *
 * This function does not return @c FFD_CHILD_PROCESS. Instead, the function @a
 * childFn is called in the child process with the @a token parameter as
 * argument. If that function returns, its return value will be passed to
 * _exit(2).
 *
 * This function differs from forkfd() the same way that vfork() differs from
 * fork(): the parent process may be suspended while the child is has not yet
 * called _exit(2) or execve(2). Additionally, on some systems, the child
 * process may share memory with the parent process the same way an auxiliary
 * thread would, so extreme care should be employed on what functions the child
 * process uses before termination.
 *
 * The @c FFD_USE_FORK flag retains its behavior as described in the forkfd()
 * documentation, including that of actually using fork(2) and no other
 * implementation.
 *
 * Currently, only on Linux will this function have any behavior different from
 * forkfd(). In all other systems, it is equivalent to the following code:
 *
 * @code
 *     int ffd = forkfd(flags, &amp;pid);
 *     if (ffd == FFD_CHILD_PROCESS)
 *         _exit(childFn(token));
 * @endcode
 */</doc>
<use f='qtbase-6.5.0/src/corelib/io/qprocess_unix.cpp' l='472' u='c' c='_ZN15QProcessPrivate12startProcessEv'/>
