<dec f='qtbase-6.5.0/src/corelib/io/qbuffer.h' l='33' type='void QBuffer::setBuffer(QByteArray * a)'/>
<def f='qtbase-6.5.0/src/corelib/io/qbuffer.cpp' l='196' ll='209' type='void QBuffer::setBuffer(QByteArray * byteArray)'/>
<doc f='qtbase-6.5.0/src/corelib/io/qbuffer.cpp' l='174'>/*!
    Makes QBuffer use the QByteArray pointed to by \a
    byteArray as its internal buffer. The caller is responsible for
    ensuring that \a byteArray remains valid until the QBuffer is
    destroyed, or until setBuffer() is called to change the buffer.
    QBuffer doesn&apos;t take ownership of the QByteArray.

    Does nothing if isOpen() is true.

    If you open the buffer in write-only mode or read-write mode and
    write something into the QBuffer, \a byteArray will be modified.

    Example:

    \snippet buffer/buffer.cpp 4

    If \a byteArray is \nullptr, the buffer creates its own internal
    QByteArray to work on. This byte array is initially empty.

    \sa buffer(), setData(), open()
*/</doc>
