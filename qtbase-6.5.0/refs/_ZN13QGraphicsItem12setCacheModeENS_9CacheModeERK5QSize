<dec f='qtbase-6.5.0/src/widgets/graphicsview/qgraphicsitem.h' l='152' type='void QGraphicsItem::setCacheMode(QGraphicsItem::CacheMode mode, const QSize &amp; cacheSize = QSize())'/>
<use f='qtbase-6.5.0/src/printsupport/widgets/qprintpreviewwidget.cpp' l='28' u='c' c='_ZN9QtPrivate8PageItemC1EiPK8QPicture5QSize5QRect'/>
<def f='qtbase-6.5.0/src/widgets/graphicsview/qgraphicsitem.cpp' l='2092' ll='2116' type='void QGraphicsItem::setCacheMode(QGraphicsItem::CacheMode mode, const QSize &amp; logicalCacheSize = QSize())'/>
<doc f='qtbase-6.5.0/src/widgets/graphicsview/qgraphicsitem.cpp' l='2055'>/*!
    \since 4.4
    Sets the item&apos;s cache mode to \a mode.

    The optional \a logicalCacheSize argument is used only by
    ItemCoordinateCache mode, and describes the resolution of the cache
    buffer; if \a logicalCacheSize is (100, 100), QGraphicsItem will fit the
    item into 100x100 pixels in graphics memory, regardless of the logical
    size of the item itself. By default QGraphicsItem uses the size of
    boundingRect(). For all other cache modes than ItemCoordinateCache, \a
    logicalCacheSize is ignored.

    Caching can speed up rendering if your item spends a significant time
    redrawing itself. In some cases the cache can also slow down rendering, in
    particular when the item spends less time redrawing than QGraphicsItem
    spends redrawing from the cache.

    When caching is enabled, an item&apos;s paint() function will generally draw into an
    offscreen pixmap cache; for any subsequent
    repaint requests, the Graphics View framework will redraw from the
    cache. This approach works particularly well with QGLWidget, which stores
    all the cache as OpenGL textures.

    Be aware that QPixmapCache&apos;s cache limit may need to be changed to obtain
    optimal performance.

    You can read more about the different cache modes in the CacheMode
    documentation.

    \note Enabling caching does not imply that the item&apos;s paint() function will be
    called only in response to an explicit update() call. For instance, under
    memory pressure, Qt may decide to drop some of the cache information;
    in such cases an item&apos;s paint() function will be called even if there
    was no update() call (that is, exactly as if there were no caching enabled).

    \sa CacheMode, QPixmapCache::setCacheLimit()
*/</doc>
