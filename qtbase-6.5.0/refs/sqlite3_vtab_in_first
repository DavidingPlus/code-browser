<dec f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='10150' type='int sqlite3_vtab_in_first(sqlite3_value * pVal, sqlite3_value ** ppOut)'/>
<def f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='88701' ll='88703' type='int sqlite3_vtab_in_first(sqlite3_value * pVal, sqlite3_value ** ppOut)'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='133232'/>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='10105'>/*
** CAPI3REF: Find all elements on the right-hand side of an IN constraint.
**
** These interfaces are only useful from within the
** [xFilter|xFilter() method] of a [virtual table] implementation.
** The result of invoking these interfaces from any other context
** is undefined and probably harmful.
**
** The X parameter in a call to sqlite3_vtab_in_first(X,P) or
** sqlite3_vtab_in_next(X,P) should be one of the parameters to the
** xFilter method which invokes these routines, and specifically
** a parameter that was previously selected for all-at-once IN constraint
** processing use the [sqlite3_vtab_in()] interface in the
** [xBestIndex|xBestIndex method].  ^(If the X parameter is not
** an xFilter argument that was selected for all-at-once IN constraint
** processing, then these routines return [SQLITE_ERROR].)^
**
** ^(Use these routines to access all values on the right-hand side
** of the IN constraint using code like the following:
**
** &lt;blockquote&gt;&lt;pre&gt;
** &amp;nbsp;  for(rc=sqlite3_vtab_in_first(pList, &amp;pVal);
** &amp;nbsp;      rc==SQLITE_OK &amp;&amp; pVal;
** &amp;nbsp;      rc=sqlite3_vtab_in_next(pList, &amp;pVal)
** &amp;nbsp;  ){
** &amp;nbsp;    // do something with pVal
** &amp;nbsp;  }
** &amp;nbsp;  if( rc!=SQLITE_OK ){
** &amp;nbsp;    // an error has occurred
** &amp;nbsp;  }
** &lt;/pre&gt;&lt;/blockquote&gt;)^
**
** ^On success, the sqlite3_vtab_in_first(X,P) and sqlite3_vtab_in_next(X,P)
** routines return SQLITE_OK and set *P to point to the first or next value
** on the RHS of the IN constraint.  ^If there are no more values on the
** right hand side of the IN constraint, then *P is set to NULL and these
** routines return [SQLITE_DONE].  ^The return value might be
** some other value, such as SQLITE_NOMEM, in the event of a malfunction.
**
** The *ppOut values returned by these routines are only valid until the
** next call to either of these routines or until the end of the xFilter
** method from which these routines were called.  If the virtual table
** implementation needs to retain the *ppOut values for longer, it must make
** copies.  The *ppOut values are [protected sqlite3_value|protected].
*/</doc>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='88697'>/*
** Set the iterator value pVal to point to the first value in the set.
** Set (*ppOut) to point to this value before returning.
*/</doc>
<dec f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.h' l='9844' type='int sqlite3_vtab_in_first(sqlite3_value * pVal, sqlite3_value ** ppOut)'/>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.h' l='9799'>/*
** CAPI3REF: Find all elements on the right-hand side of an IN constraint.
**
** These interfaces are only useful from within the
** [xFilter|xFilter() method] of a [virtual table] implementation.
** The result of invoking these interfaces from any other context
** is undefined and probably harmful.
**
** The X parameter in a call to sqlite3_vtab_in_first(X,P) or
** sqlite3_vtab_in_next(X,P) should be one of the parameters to the
** xFilter method which invokes these routines, and specifically
** a parameter that was previously selected for all-at-once IN constraint
** processing use the [sqlite3_vtab_in()] interface in the
** [xBestIndex|xBestIndex method].  ^(If the X parameter is not
** an xFilter argument that was selected for all-at-once IN constraint
** processing, then these routines return [SQLITE_ERROR].)^
**
** ^(Use these routines to access all values on the right-hand side
** of the IN constraint using code like the following:
**
** &lt;blockquote&gt;&lt;pre&gt;
** &amp;nbsp;  for(rc=sqlite3_vtab_in_first(pList, &amp;pVal);
** &amp;nbsp;      rc==SQLITE_OK &amp;&amp; pVal;
** &amp;nbsp;      rc=sqlite3_vtab_in_next(pList, &amp;pVal)
** &amp;nbsp;  ){
** &amp;nbsp;    // do something with pVal
** &amp;nbsp;  }
** &amp;nbsp;  if( rc!=SQLITE_OK ){
** &amp;nbsp;    // an error has occurred
** &amp;nbsp;  }
** &lt;/pre&gt;&lt;/blockquote&gt;)^
**
** ^On success, the sqlite3_vtab_in_first(X,P) and sqlite3_vtab_in_next(X,P)
** routines return SQLITE_OK and set *P to point to the first or next value
** on the RHS of the IN constraint.  ^If there are no more values on the
** right hand side of the IN constraint, then *P is set to NULL and these
** routines return [SQLITE_DONE].  ^The return value might be
** some other value, such as SQLITE_NOMEM, in the event of a malfunction.
**
** The *ppOut values returned by these routines are only valid until the
** next call to either of these routines or until the end of the xFilter
** method from which these routines were called.  If the virtual table
** implementation needs to retain the *ppOut values for longer, it must make
** copies.  The *ppOut values are [protected sqlite3_value|protected].
*/</doc>
