<dec f='include/glib-2.0/gobject/gtype.h' l='1402'/>
<use f='include/glib-2.0/gio/gliststore.h' l='36' u='c'/>
<doc f='include/glib-2.0/gobject/gtype.h' l='1336'>/**
 * G_DECLARE_FINAL_TYPE:
 * @ModuleObjName: The name of the new type, in camel case (like GtkWidget)
 * @module_obj_name: The name of the new type in lowercase, with words
 *  separated by &apos;_&apos; (like &apos;gtk_widget&apos;)
 * @MODULE: The name of the module, in all caps (like &apos;GTK&apos;)
 * @OBJ_NAME: The bare name of the type, in all caps (like &apos;WIDGET&apos;)
 * @ParentName: the name of the parent type, in camel case (like GtkWidget)
 *
 * A convenience macro for emitting the usual declarations in the header file for a type which is not (at the
 * present time) intended to be subclassed.
 *
 * You might use it in a header as follows:
 *
 * |[
 * #ifndef _myapp_window_h_
 * #define _myapp_window_h_
 *
 * #include &lt;gtk/gtk.h&gt;
 *
 * #define MY_APP_TYPE_WINDOW my_app_window_get_type ()
 * G_DECLARE_FINAL_TYPE (MyAppWindow, my_app_window, MY_APP, WINDOW, GtkWindow)
 *
 * MyAppWindow *    my_app_window_new    (void);
 *
 * ...
 *
 * #endif
 * ]|
 *
 * This results in the following things happening:
 *
 * - the usual my_app_window_get_type() function is declared with a return type of #GType
 *
 * - the MyAppWindow types is defined as a typedef of struct _MyAppWindow.  The struct itself is not
 *   defined and should be defined from the .c file before G_DEFINE_TYPE() is used.
 *
 * - the MY_APP_WINDOW() cast is emitted as static inline function along with the MY_APP_IS_WINDOW() type
 *   checking function
 *
 * - the MyAppWindowClass type is defined as a struct containing GtkWindowClass.  This is done for the
 *   convenience of the person defining the type and should not be considered to be part of the ABI.  In
 *   particular, without a firm declaration of the instance structure, it is not possible to subclass the type
 *   and therefore the fact that the size of the class structure is exposed is not a concern and it can be
 *   freely changed at any point in the future.
 *
 * - g_autoptr() support being added for your type, based on the type of your parent class
 *
 * You can only use this function if your parent type also supports g_autoptr().
 *
 * Because the type macro (MY_APP_TYPE_WINDOW in the above example) is not a callable, you must continue to
 * manually define this as a macro for yourself.
 *
 * The declaration of the _get_type() function is the first thing emitted by the macro.  This allows this macro
 * to be used in the usual way with export control and API versioning macros.
 *
 * If you want to declare your own class structure, use G_DECLARE_DERIVABLE_TYPE().
 *
 * If you are writing a library, it is important to note that it is possible to convert a type from using
 * G_DECLARE_FINAL_TYPE() to G_DECLARE_DERIVABLE_TYPE() without breaking API or ABI.  As a precaution, you
 * should therefore use G_DECLARE_FINAL_TYPE() until you are sure that it makes sense for your class to be
 * subclassed.  Once a class structure has been exposed it is not possible to change its size or remove or
 * reorder items without breaking the API and/or ABI.
 *
 * Since: 2.44
 **/</doc>
