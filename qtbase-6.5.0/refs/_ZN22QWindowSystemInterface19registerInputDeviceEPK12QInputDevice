<dec f='qtbase-6.5.0/src/gui/kernel/qwindowsysteminterface.h' l='153' type='static void QWindowSystemInterface::registerInputDevice(const QInputDevice * device)'/>
<def f='qtbase-6.5.0/src/gui/kernel/qwindowsysteminterface.cpp' l='598' ll='602' type='static void QWindowSystemInterface::registerInputDevice(const QInputDevice * device)'/>
<use f='qtbase-6.5.0/src/gui/kernel/qwindowsysteminterface.cpp' l='1202' u='c' c='_ZN5QTest17createTouchDeviceEN12QInputDevice10DeviceTypeE6QFlagsINS0_10CapabilityEE'/>
<doc f='qtbase-6.5.0/src/gui/kernel/qwindowsysteminterface.cpp' l='582'>/*!
    \internal
    Register a new input \a device.

    It is expected that every platform plugin will discover available input
    devices at startup, and whenever a new device is plugged in, if possible.
    If that&apos;s not possible, then it at least must call this function before
    sending an event whose QInputEvent::source() is this device.

    When a device is unplugged, the platform plugin should destroy the
    corresponding QInputDevice instance. There is no unregisterInputDevice()
    function, because it&apos;s enough for the destructor to call
    QInputDevicePrivate::unregisterDevice(); while other parts of Qt can
    connect to the QObject::destroyed() signal to be notified when a device is
    unplugged or otherwise destroyed.
*/</doc>
<use f='qtbase-6.5.0/src/platformsupport/input/evdevtouch/qevdevtouchhandler.cpp' l='440' u='c' c='_ZN24QEvdevTouchScreenHandler22registerPointingDeviceEv'/>
<use f='qtbase-6.5.0/src/plugins/generic/tuiotouch/qtuiohandler.cpp' l='87' u='c' c='_ZN12QTuioHandlerC1ERK7QString'/>
