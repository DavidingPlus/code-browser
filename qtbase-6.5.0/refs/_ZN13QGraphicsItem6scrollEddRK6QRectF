<dec f='qtbase-6.5.0/src/widgets/graphicsview/qgraphicsitem.h' l='292' type='void QGraphicsItem::scroll(qreal dx, qreal dy, const QRectF &amp; rect = QRectF())'/>
<def f='qtbase-6.5.0/src/widgets/graphicsview/qgraphicsitem.cpp' l='5700' ll='5771' type='void QGraphicsItem::scroll(qreal dx, qreal dy, const QRectF &amp; rect = QRectF())'/>
<doc f='qtbase-6.5.0/src/widgets/graphicsview/qgraphicsitem.cpp' l='5673'>/*!
    \since 4.4
    Scrolls the contents of \a rect by \a dx, \a dy. If \a rect is a null rect
    (the default), the item&apos;s bounding rect is scrolled.

    Scrolling provides a fast alternative to simply redrawing when the
    contents of the item (or parts of the item) are shifted vertically or
    horizontally. Depending on the current transformation and the capabilities
    of the paint device (i.e., the viewport), this operation may consist of
    simply moving pixels from one location to another using memmove(). In most
    cases this is faster than rerendering the entire area.

    After scrolling, the item will issue an update for the newly exposed
    areas. If scrolling is not supported (e.g., you are rendering to an OpenGL
    viewport, which does not benefit from scroll optimizations), this function
    is equivalent to calling update(\a rect).

    \b{Note:} Scrolling is only supported when QGraphicsItem::ItemCoordinateCache
    is enabled; in all other cases calling this function is equivalent to calling
    update(\a rect). If you for sure know that the item is opaque and not overlapped
    by other items, you can map the \a rect to viewport coordinates and scroll the
    viewport.

    \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 19

    \sa boundingRect()
*/</doc>
<use f='qtbase-6.5.0/src/widgets/kernel/qwidget.cpp' l='10928' u='c' c='_ZN7QWidget6scrollEii'/>
<use f='qtbase-6.5.0/src/widgets/kernel/qwidget.cpp' l='10970' u='c' c='_ZN7QWidget6scrollEiiRK5QRect'/>
