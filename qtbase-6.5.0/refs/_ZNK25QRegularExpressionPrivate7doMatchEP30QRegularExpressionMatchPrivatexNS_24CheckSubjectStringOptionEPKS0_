<dec f='qtbase-6.5.0/src/corelib/text/qregularexpression.cpp' l='719' type='void QRegularExpressionPrivate::doMatch(QRegularExpressionMatchPrivate * priv, qsizetype offset, QRegularExpressionPrivate::CheckSubjectStringOption checkSubjectStringOption = CheckSubjectString, const QRegularExpressionMatchPrivate * previous = nullptr) const'/>
<def f='qtbase-6.5.0/src/corelib/text/qregularexpression.cpp' l='1101' ll='1262' type='void QRegularExpressionPrivate::doMatch(QRegularExpressionMatchPrivate * priv, qsizetype offset, QRegularExpressionPrivate::CheckSubjectStringOption checkSubjectStringOption = CheckSubjectString, const QRegularExpressionMatchPrivate * previous = nullptr) const'/>
<use f='qtbase-6.5.0/src/corelib/text/qregularexpression.cpp' l='1298' u='c' c='_ZNK30QRegularExpressionMatchPrivate9nextMatchEv'/>
<use f='qtbase-6.5.0/src/corelib/text/qregularexpression.cpp' l='1597' u='c' c='_ZNK18QRegularExpression5matchERK7QStringxNS_9MatchTypeE6QFlagsINS_11MatchOptionEE'/>
<use f='qtbase-6.5.0/src/corelib/text/qregularexpression.cpp' l='1645' u='c' c='_ZNK18QRegularExpression9matchViewE11QStringViewxNS_9MatchTypeE6QFlagsINS_11MatchOptionEE'/>
<doc f='qtbase-6.5.0/src/corelib/text/qregularexpression.cpp' l='1073'>/*!
    \internal

    Performs a match on the subject string view held by \a priv. The
    match will be of type priv-&gt;matchType and using the options
    priv-&gt;matchOptions; the matching \a offset is relative the
    substring, and if negative, it&apos;s taken as an offset from the end of
    the substring.

    It also advances a match if a previous result is given as \a
    previous. The subject string goes a Unicode validity check if
    \a checkSubjectString is CheckSubjectString and the match options don&apos;t
    include DontCheckSubjectStringMatchOption (PCRE doesn&apos;t like illegal
    UTF-16 sequences).

    \a priv is modified to hold the results of the match.

    Advancing a match is a tricky algorithm. If the previous match matched a
    non-empty string, we just do an ordinary match at the offset position.

    If the previous match matched an empty string, then an anchored, non-empty
    match is attempted at the offset position. If that succeeds, then we got
    the next match and we can return it. Otherwise, we advance by 1 position
    (which can be one or two code units in UTF-16!) and reattempt a &quot;normal&quot;
    match. We also have the problem of detecting the current newline format: if
    the new advanced offset is pointing to the beginning of a CRLF sequence, we
    must advance over it.
*/</doc>
