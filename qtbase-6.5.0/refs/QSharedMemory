<inh f='qtbase-6.5.0/src/corelib/kernel/qobject.h' l='89' c='QObject'/>
<def f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory.h' l='22' ll='77'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory.h' l='76' c='_ZN13QSharedMemoryC1ERKS_'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory.h' l='76' c='_ZN13QSharedMemoryaSERKS_'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory.h' l='76' c='_ZN13QSharedMemoryaSERKS_'/>
<size>16</size>
<smbr r='QSharedMemory::staticMetaObject' t='const QMetaObject'/>
<fun r='_ZNK13QSharedMemory10metaObjectEv'/>
<fun r='_ZN13QSharedMemory11qt_metacastEPKc'/>
<fun r='_ZN13QSharedMemory11qt_metacallEN11QMetaObject4CallEiPPv'/>
<fun r='_ZN13QSharedMemory2trEPKcS1_i'/>
<fun r='_ZN13QSharedMemory18qt_static_metacallEP7QObjectN11QMetaObject4CallEiPPv'/>
<fun r='_ZN13QSharedMemory6d_funcEv'/>
<fun r='_ZNK13QSharedMemory6d_funcEv'/>
<fun r='_ZN13QSharedMemoryC1EP7QObject'/>
<fun r='_ZN13QSharedMemoryC1ERK7QStringP7QObject'/>
<fun r='_ZN13QSharedMemoryD1Ev'/>
<fun r='_ZN13QSharedMemory6setKeyERK7QString'/>
<fun r='_ZNK13QSharedMemory3keyEv'/>
<fun r='_ZN13QSharedMemory12setNativeKeyERK7QString'/>
<fun r='_ZNK13QSharedMemory9nativeKeyEv'/>
<fun r='_ZN13QSharedMemory6createExNS_10AccessModeE'/>
<fun r='_ZNK13QSharedMemory4sizeEv'/>
<fun r='_ZN13QSharedMemory6attachENS_10AccessModeE'/>
<fun r='_ZNK13QSharedMemory10isAttachedEv'/>
<fun r='_ZN13QSharedMemory6detachEv'/>
<fun r='_ZN13QSharedMemory4dataEv'/>
<fun r='_ZNK13QSharedMemory9constDataEv'/>
<fun r='_ZNK13QSharedMemory4dataEv'/>
<fun r='_ZN13QSharedMemory4lockEv'/>
<fun r='_ZN13QSharedMemory6unlockEv'/>
<fun r='_ZNK13QSharedMemory5errorEv'/>
<fun r='_ZNK13QSharedMemory11errorStringEv'/>
<fun r='_ZN13QSharedMemoryC1ERKS_'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory_p.h' l='56' c='_ZN19QSharedMemoryLockerC1EP13QSharedMemory'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory_p.h' l='76'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory_p.h' l='82' c='_ZN20QSharedMemoryPrivate6q_funcEv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory_p.h' l='82' c='_ZN20QSharedMemoryPrivate6q_funcEv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory_p.h' l='82' c='_ZNK20QSharedMemoryPrivate6q_funcEv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory_p.h' l='82' c='_ZNK20QSharedMemoryPrivate6q_funcEv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory_p.h' l='82'/>
<size>16</size>
<doc f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory.cpp' l='83'>/*!
  \class QSharedMemory
  \inmodule QtCore
  \since 4.4

  \brief The QSharedMemory class provides access to a shared memory segment.

  QSharedMemory provides access to a shared memory segment by multiple
  threads and processes. It also provides a way for a single thread or
  process to lock the memory for exclusive access.

  When using this class, be aware of the following platform
  differences:

  \list

    \li Windows: QSharedMemory does not &quot;own&quot; the shared memory segment.
    When all threads or processes that have an instance of QSharedMemory
    attached to a particular shared memory segment have either destroyed
    their instance of QSharedMemory or exited, the Windows kernel
    releases the shared memory segment automatically.

    \li Unix: QSharedMemory &quot;owns&quot; the shared memory segment. When the
    last thread or process that has an instance of QSharedMemory
    attached to a particular shared memory segment detaches from the
    segment by destroying its instance of QSharedMemory, the destructor
    releases the shared memory segment. But if that last thread or
    process crashes without running the QSharedMemory destructor, the
    shared memory segment survives the crash.

    \li Unix: QSharedMemory can be implemented by one of two different
    backends, selected at Qt build time: System V or POSIX. Qt defaults to
    using the System V API if it is available, and POSIX if not. These two
    backends do not interoperate, so two applications must ensure they use the
    same one, even if the native key (see setNativeKey()) is the same.

    The POSIX backend can be explicitly selected using the
    \c{-feature-ipc_posix} option to the Qt configure script. If it is enabled,
    the \c{QT_POSIX_IPC} macro will be defined.

    \li Sandboxed applications on Apple platforms (including apps
    shipped through the Apple App Store): This environment requires
    the use of POSIX shared memory (instead of System V shared memory).

    Qt for iOS is built with support for POSIX shared memory out of the box.
    However, Qt for \macos builds (including those from the Qt installer) default
    to System V, making them unsuitable for App Store submission if QSharedMemory
    is needed. See above for instructions to explicitly select the POSIX backend
    when building Qt.

    In addition, in a sandboxed environment, the following caveats apply:

    \list
      \li The key must be in the form \c {&lt;application group identifier&gt;/&lt;custom identifier&gt;},
      as documented \l {https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html#//apple_ref/doc/uid/TP40011183-CH3-SW24}
      {here} and \l {https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_application-groups}
      {here}.

      \li The key length is limited to 30 characters.

      \li On process exit, the named shared memory entries are not
      cleaned up, so restarting the application and re-creating the
      shared memory under the same name will fail. To work around this,
      fall back to attaching to the existing shared memory entry:

      \code

          QSharedMemory shm(&quot;DEVTEAMID.app-group/shared&quot;);
          if (!shm.create(42) &amp;&amp; shm.error() == QSharedMemory::AlreadyExists)
              shm.attach();

      \endcode

    \endlist

    \li Android: QSharedMemory is not supported.

  \endlist

  Remember to lock the shared memory with lock() before reading from
  or writing to the shared memory, and remember to release the lock
  with unlock() after you are done.

  QSharedMemory automatically destroys the shared memory segment when
  the last instance of QSharedMemory is detached from the segment, and
  no references to the segment remain.

  \warning QSharedMemory changes the key in a Qt-specific way, unless otherwise
  specified. Interoperation with non-Qt applications is achieved by first creating
  a default shared memory with QSharedMemory() and then setting a native key with
  setNativeKey(), after ensuring they use the same low-level API (System V or
  POSIX). When using native keys, shared memory is not protected against multiple
  accesses on it (for example, unable to lock()) and a user-defined mechanism
  should be used to achieve such protection.

  \section2 Alternative: Memory-Mapped File

  Another way to share memory between processes is by opening the same file
  using \l QFile and mapping it into memory using QFile::map() (without
  specifying the QFileDevice::MapPrivateOption option). Any writes to the
  mapped segment will be observed by all other processes that have mapped the
  same file. This solution has the major advantages of being independent of the
  backend API and of being simpler to interoperate with from non-Qt
  applications. And since \l{QTemporaryFile} is a \l{QFile}, applications can
  use that class to achieve clean-up semantics and to create unique shared
  memory segments too.

  To achieve locking of the shared memory segment, applications will need to
  deploy their own mechanisms. This can be achieved by using \l
  QBasicAtomicInteger or \c{std::atomic} in a pre-determined offset in the
  segment itself. Higher-level locking primitives may be available on some
  operating systems; for example, on Linux, \c{pthread_mutex_create()} can be
  passed a flag to indicate that the mutex resides in a shared memory segment.

  A major drawback of using file-backed shared memory is that the operating
  system will attempt to write the data to permanent storage, possibly causing
  noticeable performance penalties. To avoid this, applications should locate a
  RAM-backed filesystem, such as \c{tmpfs} on Linux (see
  QStorageInfo::fileSystemType()), or pass a flag to the native file-opening
  function to inform the OS to avoid committing the contents to storage.

  File-backed shared memory must be used with care if another process
  participating is untrusted. The files may be truncated/shrunk and cause
  applications accessing memory beyond the file&apos;s size to crash.

  \section3 Linux hints on memory-mapped files

  On modern Linux systems, while the \c{/tmp} directory is often a \c{tmpfs}
  mount point, that is not a requirement. However, the \c{/dev/shm} directory
  is required to be a \c{tmpfs} and exists for this very purpose. Do note that
  it is world-readable and writable (like \c{/tmp} and \c{/var/tmp}), so one
  must be careful of the contents revealed there. Another alternative is to use
  the XDG Runtime Directory (see QStandardPaths::writableLocation() and
  \l{QStandardPaths::RuntimeLocation}), which on Linux systems using systemd is
  a user-specific \c{tmpfs}.

  An even more secure solution is to create a &quot;memfd&quot; using \c{memfd_create(2)}
  and use interprocess communication to pass the file descriptor, like
  \l{QDBusUnixFileDescriptor} or by letting the child process of a \l{QProcess}
  inherit it. &quot;memfds&quot; can also be sealed against being shrunk, so they are
  safe to be used when communicating with processes with a different privilege
  level.

  \section3 FreeBSD hints on memory-mapped files

  FreeBSD also has \c{memfd_create(2)} and can pass file descriptors to other
  processes using the same techniques as Linux. It does not have temporary
  filesystems mounted by default.

  \section3 Windows hints on memory-mapped files

  On Windows, the application can request the operating system avoid committing
  the file&apos;s contents to permanent storage. This request is performed by
  passing the \c{FILE_ATTRIBUTE_TEMPORARY} flag in the \c{dwFlagsAndAttributes}
  \c{CreateFile} Win32 function, the \c{_O_SHORT_LIVED} flag to \c{_open()}
  low-level function, or by including the modifier &quot;T&quot; to the \c{fopen()} C
  runtime function.

  There&apos;s also a flag to inform the operating system to delete the file when
  the last handle to it is closed (\c{FILE_FLAG_DELETE_ON_CLOSE},
  \c{_O_TEMPORARY}, and the &quot;D&quot; modifier), but do note that all processes
  attempting to open the file must agree on using this flag or not using it. A
  mismatch will likely cause a sharing violation and failure to open the file.
 */</doc>
<doc f='qtbase-6.5.0/src/corelib/kernel/qsharedmemory.cpp' l='248'>/*!
  \overload QSharedMemory()

  Constructs a shared memory object with the given \a parent.  The
  shared memory object&apos;s key is not set by the constructor, so the
  shared memory object does not have an underlying shared memory
  segment attached. The key must be set with setKey() or setNativeKey()
  before create() or attach() can be used.

  \sa setKey()
 */</doc>
<fun r='_ZN13QSharedMemoryC1EP7QObject'/>
<fun r='_ZN13QSharedMemoryC1ERK7QStringP7QObject'/>
<fun r='_ZN13QSharedMemoryD1Ev'/>
<fun r='_ZN13QSharedMemory6setKeyERK7QString'/>
<fun r='_ZN13QSharedMemory12setNativeKeyERK7QString'/>
<fun r='_ZNK13QSharedMemory3keyEv'/>
<fun r='_ZNK13QSharedMemory9nativeKeyEv'/>
<fun r='_ZN13QSharedMemory6createExNS_10AccessModeE'/>
<fun r='_ZNK13QSharedMemory4sizeEv'/>
<fun r='_ZN13QSharedMemory6attachENS_10AccessModeE'/>
<fun r='_ZNK13QSharedMemory10isAttachedEv'/>
<fun r='_ZN13QSharedMemory6detachEv'/>
<fun r='_ZN13QSharedMemory4dataEv'/>
<fun r='_ZNK13QSharedMemory9constDataEv'/>
<fun r='_ZNK13QSharedMemory4dataEv'/>
<fun r='_ZN13QSharedMemory4lockEv'/>
<fun r='_ZN13QSharedMemory6unlockEv'/>
<fun r='_ZNK13QSharedMemory5errorEv'/>
<fun r='_ZNK13QSharedMemory11errorStringEv'/>
