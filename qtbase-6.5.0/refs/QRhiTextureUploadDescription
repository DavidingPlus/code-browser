<def f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='571' ll='590'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1568' c='_ZN23QRhiResourceUpdateBatch13uploadTextureEP11QRhiTextureRK28QRhiTextureUploadDescription'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='123' c='_ZNK30QBackingStoreDefaultCompositor9toTextureERK6QImageP4QRhiP23QRhiResourceUpdateBatchRK7QRegionP6QFlagsIN21QPlatformBackingStore11TextureFlagEE'/>
<size>1432</size>
<fun r='_ZN28QRhiTextureUploadDescriptionC1Ev'/>
<fun r='_ZN28QRhiTextureUploadDescriptionC1ERK22QRhiTextureUploadEntry'/>
<fun r='_ZN28QRhiTextureUploadDescriptionC1ESt16initializer_listI22QRhiTextureUploadEntryE'/>
<fun r='_ZN28QRhiTextureUploadDescription10setEntriesESt16initializer_listI22QRhiTextureUploadEntryE'/>
<fun r='_ZN28QRhiTextureUploadDescription10setEntriesET_S0_'/>
<fun r='_ZNK28QRhiTextureUploadDescription13cbeginEntriesEv'/>
<fun r='_ZNK28QRhiTextureUploadDescription11cendEntriesEv'/>
<mbr r='QRhiTextureUploadDescription::m_entries' o='0' t='QVarLengthArray&lt;QRhiTextureUploadEntry, 16&gt;'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p_p.h' l='459' c='_ZN30QRhiResourceUpdateBatchPrivate9TextureOp6uploadEP11QRhiTextureRK28QRhiTextureUploadDescription'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6079' c='_ZN23QRhiResourceUpdateBatch13uploadTextureEP11QRhiTextureRK28QRhiTextureUploadDescription'/>
<size>1432</size>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='1906'>/*!
    \class QRhiTextureUploadDescription
    \internal
    \inmodule QtGui
    \brief Describes a texture upload operation.

    Used with QRhiResourceUpdateBatch::uploadTexture(). That function has two
    variants: one taking a QImage and one taking a
    QRhiTextureUploadDescription. The former is a convenience version,
    internally creating a QRhiTextureUploadDescription with a single image
    targeting level 0 for layer 0. However, when cubemaps, pre-generated mip
    images, or compressed textures are involved, applications will have to work
    directly with this class instead.

    QRhiTextureUploadDescription also enables specifying batched uploads, which
    are useful for example when generating an atlas or glyph cache texture:
    multiple, partial uploads for the same subresource (meaning the same layer
    and level) are supported, and can be, depending on the backend and the
    underlying graphics API, more efficient when batched into the same
    QRhiTextureUploadDescription as opposed to issuing individual
    \l{QRhiResourceUpdateBatch::uploadTexture()}{uploadTexture()} commands for
    each of them.

    \note Cubemaps have one layer for each of the six faces in the order +X,
    -X, +Y, -Y, +Z, -Z.

    For example, specifying the faces of a cubemap could look like the following:

    \badcode
        QImage faces[6];
        ...
        QList&lt;QRhiTextureUploadEntry&gt; entries;
        for (int i = 0; i &lt; 6; ++i)
          entries.append(QRhiTextureUploadEntry(i, 0, faces[i]));
        QRhiTextureUploadDescription desc;
        desc.setEntries(entries.cbegin(), entries.cend());
        resourceUpdates-&gt;uploadTexture(texture, desc);
    \endcode

    Another example that specifies mip images for a compressed texture:

    \badcode
        QList&lt;QRhiTextureUploadEntry&gt; entries;
        const int mipCount = rhi-&gt;mipLevelsForSize(compressedTexture-&gt;pixelSize());
        for (int level = 0; level &lt; mipCount; ++level) {
            const QByteArray compressedDataForLevel = ..
            entries.append(QRhiTextureUploadEntry(0, level, compressedDataForLevel));
        }
        QRhiTextureUploadDescription desc;
        desc.setEntries(entries.cbegin(), entries.cend());
        resourceUpdates-&gt;uploadTexture(compressedTexture, desc);
    \endcode

    With partial uploads targeting the same subresource, it is recommended to
    batch them into a single upload request, whenever possible:

    \badcode
      QRhiTextureSubresourceUploadDescription subresDesc(image);
      subresDesc.setSourceSize(QSize(10, 10));
      subResDesc.setDestinationTopLeft(QPoint(50, 40));
      QRhiTextureUploadEntry entry(0, 0, subresDesc); // layer 0, level 0

      QRhiTextureSubresourceUploadDescription subresDesc2(image);
      subresDesc2.setSourceSize(QSize(30, 40));
      subResDesc2.setDestinationTopLeft(QPoint(100, 200));
      QRhiTextureUploadEntry entry2(0, 0, subresDesc2); // layer 0, level 0, i.e. same subresource

      QRhiTextureUploadDescription desc({ entry, entry2});
      resourceUpdates-&gt;uploadTexture(texture, desc);
    \endcode
 */</doc>
<fun r='_ZN28QRhiTextureUploadDescriptionC1ERK22QRhiTextureUploadEntry'/>
<fun r='_ZN28QRhiTextureUploadDescriptionC1ESt16initializer_listI22QRhiTextureUploadEntryE'/>
