<dec f='qtbase-6.5.0/src/corelib/io/qiodevice.h' l='43' type='void QIODevice::~QIODevice()'/>
<ovr f='qtbase-6.5.0/src/corelib/io/qbuffer.cpp' l='170' c='_ZN7QBufferD1Ev'/>
<ovr f='qtbase-6.5.0/src/corelib/io/qfiledevice.cpp' l='193' c='_ZN11QFileDeviceD1Ev'/>
<def f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='462' ll='467' type='void QIODevice::~QIODevice()'/>
<doc f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='456'>/*!
  The destructor is virtual, and QIODevice is an abstract base
  class. This destructor does not call close(), but the subclass
  destructor might. If you are in doubt, call close() before
  destroying the QIODevice.
*/</doc>
<ovr f='qtbase-6.5.0/src/corelib/io/qnoncontiguousbytedevice.cpp' l='378' c='_ZN27QByteDeviceWrappingIoDeviceD1Ev'/>
<ovr f='qtbase-6.5.0/src/corelib/io/qprocess.cpp' l='1226' c='_ZN8QProcessD1Ev'/>
<ovr f='qtbase-6.5.0/src/network/access/qhttpmultipart_p.h' l='92' c='_ZN22QHttpMultiPartIODeviceD1Ev'/>
<ovr f='qtbase-6.5.0/src/network/access/qnetworkreply.cpp' l='455' c='_ZN13QNetworkReplyD1Ev'/>
<ovr f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='1407' c='_ZN15QAbstractSocketD1Ev'/>
<ovr f='qtbase-6.5.0/src/network/socket/qlocalsocket.cpp' l='370' c='_ZN12QLocalSocketD1Ev'/>
