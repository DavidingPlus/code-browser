<dec f='qtbase-6.5.0/src/corelib/serialization/qcborstreamwriter.h' l='75' type='void QCborStreamWriter::startArray(quint64 count)'/>
<def f='qtbase-6.5.0/src/corelib/serialization/qcborstreamwriter.cpp' l='734' ll='737' type='void QCborStreamWriter::startArray(quint64 count)'/>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcborstreamwriter.cpp' l='708'>/*!
   \overload

   Starts a CBOR Array with explicit length of \a count items in the CBOR
   stream. Each startArray call must be paired with one endArray() call and the
   current CBOR element extends until the end of the array.

   The array created by this function has an explicit length and therefore
   exactly \a count items must be added to the CBOR stream. Adding fewer or
   more items will result in failure during endArray() and the CBOR stream will
   be corrupt. However, explicit-length arrays are required by canonical CBOR
   encoding.

   The following example appends all strings found in the \l QStringList passed as input:

   \snippet code/src_corelib_serialization_qcborstream.cpp 21

   \b{Size limitations}: The parameter to this function is quint64, which would
   seem to allow up to 2\sup{64}-1 elements in the array. However, both
   QCborStreamWriter and QCborStreamReader are currently limited to 2\sup{32}-2
   items on 32-bit systems and 2\sup{64}-2 items on 64-bit ones. Also note that
   QCborArray is currently limited to 2\sup{27} elements in any platform.

   \sa startArray(), endArray(), startMap(), QCborStreamReader::isArray(),
   QCborStreamReader::isLengthKnown()
 */</doc>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.cpp' l='1344' u='c' c='_ZL12encodeToCborR17QCborStreamWriterPK21QCborContainerPrivatex6QFlagsIN10QCborValue14EncodingOptionEE'/>
