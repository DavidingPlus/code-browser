<dec f='qtbase-6.5.0/src/corelib/io/qiodevice.h' l='97' type='bool QIODevice::waitForBytesWritten(int msecs)'/>
<def f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='2106' ll='2110' type='bool QIODevice::waitForBytesWritten(int msecs)'/>
<doc f='qtbase-6.5.0/src/corelib/io/qiodevice.cpp' l='2080'>/*!
    For buffered devices, this function waits until a payload of
    buffered written data has been written to the device and the
    bytesWritten() signal has been emitted, or until \a msecs
    milliseconds have passed. If msecs is -1, this function will
    not time out. For unbuffered devices, it returns immediately.

    Returns \c true if a payload of data was written to the device;
    otherwise returns \c false (i.e. if the operation timed out, or if an
    error occurred).

    This function can operate without an event loop. It is
    useful when writing non-GUI applications and when performing
    I/O operations in a non-GUI thread.

    If called from within a slot connected to the bytesWritten() signal,
    bytesWritten() will not be reemitted.

    Reimplement this function to provide a blocking API for a custom
    device. The default implementation does nothing, and returns \c false.

    \warning Calling this function from the main (GUI) thread
    might cause your user interface to freeze.

    \sa waitForReadyRead()
*/</doc>
<ovr f='qtbase-6.5.0/src/corelib/io/qprocess.cpp' l='1835' c='_ZN8QProcess19waitForBytesWrittenEi'/>
<ovr f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2201' c='_ZN15QAbstractSocket19waitForBytesWrittenEi'/>
<ovr f='qtbase-6.5.0/src/network/socket/qlocalsocket_unix.cpp' l='512' c='_ZN12QLocalSocket19waitForBytesWrittenEi'/>
