<dec f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.h' l='113' type='bool QCborStreamReader::isLengthKnown() const'/>
<def f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='1063' ll='1066' type='bool QCborStreamReader::isLengthKnown() const'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='1085' u='c' c='_ZNK17QCborStreamReader6lengthEv'/>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcborstreamreader.cpp' l='1045'>/*!
   Returns true if the length of the current array, map, byte array or string
   is known (explicit in the CBOR stream), false otherwise. This function
   should only be called if the element is one of those.

   If the length is known, it may be obtained by calling length().

   If the length of a map or an array is not known, it is implied by the number
   of elements present in the stream. QCborStreamReader has no API to calculate
   the length in that condition.

   Strings and byte arrays may also have indeterminate length (that is, they
   may be transmitted in multiple chunks). Those cannot currently be created
   with QCborStreamWriter, but they could be with other encoders, so
   QCborStreamReader supports them.

   \sa length(), QCborStreamWriter::startArray(), QCborStreamWriter::startMap()
 */</doc>
