<def f='qtbase-6.5.0/src/corelib/thread/qmutex.h' l='231' ll='290'/>
<use f='qtbase-6.5.0/src/corelib/thread/qfutureinterface.h' l='284' c='_ZN16QFutureInterface12reportResultEPKT_i'/>
<use f='qtbase-6.5.0/src/corelib/thread/qfutureinterface.h' l='306' c='_ZN16QFutureInterface19reportAndMoveResultEOT_i'/>
<use f='qtbase-6.5.0/src/corelib/thread/qfutureinterface.h' l='336' c='_ZN16QFutureInterface13reportResultsERK5QListIT_Eii'/>
<use f='qtbase-6.5.0/src/corelib/thread/qfutureinterface.h' l='370' c='_ZNK16QFutureInterface15resultReferenceEi'/>
<use f='qtbase-6.5.0/src/corelib/thread/qfutureinterface.h' l='379' c='_ZNK16QFutureInterface13resultPointerEi'/>
<use f='qtbase-6.5.0/src/corelib/thread/qfutureinterface.h' l='394' c='_ZN16QFutureInterface7resultsEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qfutureinterface.h' l='416' c='_ZN16QFutureInterface10takeResultEv'/>
<fun r='_ZN12QMutexLockerC1EPT_'/>
<fun r='_ZN12QMutexLockerC1EO12QMutexLockerIT_E'/>
<fun r='_ZN12QMutexLockerD1Ev'/>
<fun r='_ZNK12QMutexLocker8isLockedEv'/>
<fun r='_ZN12QMutexLocker6unlockEv'/>
<fun r='_ZN12QMutexLocker6relockEv'/>
<fun r='_ZN12QMutexLocker4swapER12QMutexLockerIT_E'/>
<fun r='_ZNK12QMutexLocker5mutexEv'/>
<fun r='_ZN12QMutexLockerC1ERK12QMutexLockerIT_E'/>
<mbr r='QMutexLocker::m_mutex' t='Mutex *'/>
<mbr r='QMutexLocker::m_isLocked' t='bool'/>
<ovr f='qtbase-6.5.0/src/corelib/io/qprocess_p.h' l='114' c='QProcessEnvironmentPrivate::NameMapMutexLocker'/>
<use f='qtbase-6.5.0/src/corelib/io/qprocess_p.h' l='114'/>
<use f='qtbase-6.5.0/src/corelib/io/qprocess_p.h' l='116' c='_ZN26QProcessEnvironmentPrivate18NameMapMutexLockerC1EPKS_'/>
<size>16</size>
<use f='qtbase-6.5.0/src/corelib/kernel/qeventloop.cpp' l='143' c='_ZN10QEventLoop4execE6QFlagsINS_17ProcessEventsFlagEE'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qeventloop.cpp' l='146' c='_ZZN10QEventLoop4execE6QFlagsINS_17ProcessEventsFlagEEEN13LoopReferenceC1EP17QEventLoopPrivateR12QMutexLockerI6QMutexE'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qmutex.cpp' l='401'>/*!
    \class QMutexLocker
    \inmodule QtCore
    \brief The QMutexLocker class is a convenience class that simplifies
    locking and unlocking mutexes.

    \threadsafe

    \ingroup thread

    Locking and unlocking a QMutex or QRecursiveMutex in complex functions and
    statements or in exception handling code is error-prone and
    difficult to debug. QMutexLocker can be used in such situations
    to ensure that the state of the mutex is always well-defined.

    QMutexLocker should be created within a function where a
    QMutex needs to be locked. The mutex is locked when QMutexLocker
    is created. You can unlock and relock the mutex with \c unlock()
    and \c relock(). If locked, the mutex will be unlocked when the
    QMutexLocker is destroyed.

    For example, this complex function locks a QMutex upon entering
    the function and unlocks the mutex at all the exit points:

    \snippet code/src_corelib_thread_qmutex.cpp 4

    This example function will get more complicated as it is
    developed, which increases the likelihood that errors will occur.

    Using QMutexLocker greatly simplifies the code, and makes it more
    readable:

    \snippet code/src_corelib_thread_qmutex.cpp 5

    Now, the mutex will always be unlocked when the QMutexLocker
    object is destroyed (when the function returns since \c locker is
    an auto variable).

    The same principle applies to code that throws and catches
    exceptions. An exception that is not caught in the function that
    has locked the mutex has no way of unlocking the mutex before the
    exception is passed up the stack to the calling function.

    QMutexLocker also provides a \c mutex() member function that returns
    the mutex on which the QMutexLocker is operating. This is useful
    for code that needs access to the mutex, such as
    QWaitCondition::wait(). For example:

    \snippet code/src_corelib_thread_qmutex.cpp 6

    \sa QReadLocker, QWriteLocker, QMutex
*/</doc>
