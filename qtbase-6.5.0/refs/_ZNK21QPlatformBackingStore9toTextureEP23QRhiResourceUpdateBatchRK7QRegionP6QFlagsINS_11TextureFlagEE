<dec f='qtbase-6.5.0/src/gui/painting/qplatformbackingstore.h' l='160' type='QRhiTexture * QPlatformBackingStore::toTexture(QRhiResourceUpdateBatch * resourceUpdates, const QRegion &amp; dirtyRegion, QPlatformBackingStore::TextureFlags * flags) const'/>
<def f='qtbase-6.5.0/src/gui/painting/qplatformbackingstore.cpp' l='260' ll='265' type='QRhiTexture * QPlatformBackingStore::toTexture(QRhiResourceUpdateBatch * resourceUpdates, const QRegion &amp; dirtyRegion, QPlatformBackingStore::TextureFlags * flags) const'/>
<doc f='qtbase-6.5.0/src/gui/painting/qplatformbackingstore.cpp' l='234'>/*!
  May be reimplemented in subclasses to return the content of the
  backingstore as an QRhiTexture. \a dirtyRegion is the part of the
  backingstore which may have changed since the last call to this function. The
  caller of this function must ensure that there is a current context.

  The ownership of the texture is not transferred. The caller must not store
  the return value between calls, but instead call this function before each use.

  The default implementation returns a cached texture if \a dirtyRegion is
  empty and the existing texture&apos;s size matches the backingstore size,
  otherwise it retrieves the content using toImage() and performs a texture
  upload.

  If the red and blue components have to swapped, \a flags will be set to include \c
  TextureSwizzle. This allows creating textures from images in formats like
  QImage::Format_RGB32 without any further image conversion. Instead, the swizzling will
  be done in the shaders when performing composition. Other formats, that do not need
  such swizzling due to being already byte ordered RGBA, for example
  QImage::Format_RGBA8888, must result in having \a needsSwizzle set to false.

  If the image has to be flipped (e.g. because the texture is attached to an FBO), \a
  flags will be set to include \c TextureFlip.

  \note \a dirtyRegion is relative to the backingstore so no adjustment is needed.
 */</doc>
