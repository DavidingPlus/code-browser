<def f='qtbase-6.5.0/src/3rdparty/double-conversion/double-conversion/double-to-string.h' l='215' ll='217' type='bool double_conversion::DoubleToStringConverter::ToShortest(double value, double_conversion::StringBuilder * result_builder) const'/>
<doc f='qtbase-6.5.0/src/3rdparty/double-conversion/double-conversion/double-to-string.h' l='177'>// Computes the shortest string of digits that correctly represent the input
  // number. Depending on decimal_in_shortest_low and decimal_in_shortest_high
  // (see constructor) it then either returns a decimal representation, or an
  // exponential representation.
  // Example with decimal_in_shortest_low = -6,
  //              decimal_in_shortest_high = 21,
  //              EMIT_POSITIVE_EXPONENT_SIGN activated, and
  //              EMIT_TRAILING_DECIMAL_POINT deactivated:
  //   ToShortest(0.000001)  -&gt; &quot;0.000001&quot;
  //   ToShortest(0.0000001) -&gt; &quot;1e-7&quot;
  //   ToShortest(111111111111111111111.0)  -&gt; &quot;111111111111111110000&quot;
  //   ToShortest(100000000000000000000.0)  -&gt; &quot;100000000000000000000&quot;
  //   ToShortest(1111111111111111111111.0) -&gt; &quot;1.1111111111111111e+21&quot;
  //
  // Note: the conversion may round the output if the returned string
  // is accurate enough to uniquely identify the input-number.
  // For example the most precise representation of the double 9e59 equals
  // &quot;899999999999999918767229449717619953810131273674690656206848&quot;, but
  // the converter will return the shorter (but still correct) &quot;9e59&quot;.
  //
  // Returns true if the conversion succeeds. The conversion always succeeds
  // except when the input value is special and no infinity_symbol or
  // nan_symbol has been given to the constructor.
  //
  // The length of the longest result is the maximum of the length of the
  // following string representations (each with possible examples):
  // - NaN and negative infinity: &quot;NaN&quot;, &quot;-Infinity&quot;, &quot;-inf&quot;.
  // - -10^(decimal_in_shortest_high - 1):
  //      &quot;-100000000000000000000&quot;, &quot;-1000000000000000.0&quot;
  // - the longest string in range [0; -10^decimal_in_shortest_low]. Generally,
  //   this string is 3 + kBase10MaximalLength - decimal_in_shortest_low.
  //   (Sign, &apos;0&apos;, decimal point, padding zeroes for decimal_in_shortest_low,
  //   and the significant digits).
  //      &quot;-0.0000033333333333333333&quot;, &quot;-0.0012345678901234567&quot;
  // - the longest exponential representation. (A negative number with
  //   kBase10MaximalLength significant digits).
  //      &quot;-1.7976931348623157e+308&quot;, &quot;-1.7976931348623157E308&quot;
  // In addition, the buffer must be able to hold the trailing &apos;\0&apos; character.</doc>
