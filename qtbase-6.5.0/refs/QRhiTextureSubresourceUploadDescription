<def f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='511' ll='544'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='546'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='546'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='546'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='546'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='546'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='552' c='_ZN22QRhiTextureUploadEntryC1EiiRK39QRhiTextureSubresourceUploadDescription'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='560' c='_ZNK22QRhiTextureUploadEntry11descriptionEv'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='561' c='_ZN22QRhiTextureUploadEntry14setDescriptionERK39QRhiTextureSubresourceUploadDescription'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='566'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='119' c='_ZNK30QBackingStoreDefaultCompositor9toTextureERK6QImageP4QRhiP23QRhiResourceUpdateBatchRK7QRegionP6QFlagsIN21QPlatformBackingStore11TextureFlagEE'/>
<size>80</size>
<fun r='_ZN39QRhiTextureSubresourceUploadDescriptionC1Ev'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescriptionC1ERK6QImage'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescriptionC1EPKvj'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescriptionC1ERK10QByteArray'/>
<fun r='_ZNK39QRhiTextureSubresourceUploadDescription5imageEv'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescription8setImageERK6QImage'/>
<fun r='_ZNK39QRhiTextureSubresourceUploadDescription4dataEv'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescription7setDataERK10QByteArray'/>
<fun r='_ZNK39QRhiTextureSubresourceUploadDescription10dataStrideEv'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescription13setDataStrideEj'/>
<fun r='_ZNK39QRhiTextureSubresourceUploadDescription18destinationTopLeftEv'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescription21setDestinationTopLeftERK6QPoint'/>
<fun r='_ZNK39QRhiTextureSubresourceUploadDescription10sourceSizeEv'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescription13setSourceSizeERK5QSize'/>
<fun r='_ZNK39QRhiTextureSubresourceUploadDescription13sourceTopLeftEv'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescription16setSourceTopLeftERK6QPoint'/>
<mbr r='QRhiTextureSubresourceUploadDescription::m_image' o='0' t='QImage'/>
<mbr r='QRhiTextureSubresourceUploadDescription::m_data' o='192' t='QByteArray'/>
<mbr r='QRhiTextureSubresourceUploadDescription::m_dataStride' o='384' t='quint32'/>
<mbr r='QRhiTextureSubresourceUploadDescription::m_destinationTopLeft' o='416' t='QPoint'/>
<mbr r='QRhiTextureSubresourceUploadDescription::m_sourceSize' o='480' t='QSize'/>
<mbr r='QRhiTextureSubresourceUploadDescription::m_sourceTopLeft' o='544' t='QPoint'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p_p.h' l='452'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2_p_p.h' l='835' c='_ZN9QRhiGles219enqueueSubresUploadEP13QGles2TextureP19QGles2CommandBufferiiRK39QRhiTextureSubresourceUploadDescription'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='1899' c='_ZN22QRhiTextureUploadEntryC1EiiRK39QRhiTextureSubresourceUploadDescription'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='6101' c='_ZN23QRhiResourceUpdateBatch13uploadTextureEP11QRhiTextureRK6QImage'/>
<size>80</size>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='1765'>/*!
    \class QRhiTextureSubresourceUploadDescription
    \internal
    \inmodule QtGui
    \brief Describes the source for one mip level in a layer in a texture upload operation.

    The source content is specified either as a QImage or as a raw blob. The
    former is only allowed for uncompressed textures with a format that can be
    mapped to QImage, while the latter is supported for all formats, including
    floating point and compressed.

    \note image() and data() cannot be both set at the same time.

    destinationTopLeft() specifies the top-left corner of the target
    rectangle. Defaults to (0, 0).

    An empty sourceSize() (the default) indicates that size is assumed to be
    the size of the subresource. With QImage-based uploads this implies that
    the size of the source image() must match the subresource. When providing
    raw data instead, sufficient number of bytes must be provided in data().

    sourceTopLeft() is supported only for QImage-based uploads, and specifies
    the top-left corner of the source rectangle.

    \note Setting sourceSize() or sourceTopLeft() may trigger a QImage copy
    internally, depending on the format and the backend.

    When providing raw data, and the stride is not specified via
    setDataStride(), the stride (row pitch, row length in bytes) of the
    provided data must be equal to \c{width * pixelSize} where \c pixelSize is
    the number of bytes used for one pixel, and there must be no additional
    padding between rows. There is no row start alignment requirement.

    When there is unused data at the end of each row in the input raw data,
    call setDataStride() with the total number of bytes per row. The stride
    must always be a multiple of the number of bytes for one pixel. The row
    stride is only applicable to image data for textures with an uncompressed
    format.

    \note The format of the source data must be compatible with the texture
    format. With many graphics APIs the data is copied as-is into a staging
    buffer, there is no intermediate format conversion provided by QRhi. This
    applies to floating point formats as well, with, for example, RGBA16F
    requiring half floats in the source data.

    \note Setting the stride via setDataStride() is only functional when
    QRhi::ImageDataStride is reported as
    \l{QRhi::isFeatureSupported()}{supported}. In practice this can be expected
    to be supported everywhere except for OpenGL ES 2.0.

    \note When a QImage is given, the stride returned from
    QImage::bytesPerLine() is taken into account automatically.

    \warning When a QImage is given and the QImage does not own the underlying
    pixel data, it is up to the caller to ensure that the associated data stays
    valid until the end of the frame. (just submitting the resource update batch
    is not sufficient, the data must stay valid until QRhi::endFrame() is called
    in order to be portable across all backends) If this cannot be ensured, the
    caller is strongly encouraged to call QImage::detach() on the image before
    passing it to uploadTexture().
 */</doc>
<fun r='_ZN39QRhiTextureSubresourceUploadDescriptionC1ERK6QImage'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescriptionC1EPKvj'/>
<fun r='_ZN39QRhiTextureSubresourceUploadDescriptionC1ERK10QByteArray'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='2143' c='_ZN9QRhiGles219enqueueSubresUploadEP13QGles2TextureP19QGles2CommandBufferiiRK39QRhiTextureSubresourceUploadDescription'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='2339' c='_ZN9QRhiGles222enqueueResourceUpdatesEP17QRhiCommandBufferP23QRhiResourceUpdateBatch'/>
<size>80</size>
<use f='qtbase-6.5.0/src/gui/rhi/qrhinull.cpp' l='386' c='_ZN8QRhiNull21simulateTextureUploadERKN30QRhiResourceUpdateBatchPrivate9TextureOpE'/>
<size>80</size>
