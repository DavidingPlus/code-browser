<def f='qtbase-6.5.0/src/corelib/thread/qatomic_cxx11.h' l='37' ll='38'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic_cxx11.h' l='51' c='_ZN13QAtomicTraits10isLockFreeEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic_cxx11.h' l='104' c='_ZN13QAtomicTraits10isLockFreeEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic_cxx11.h' l='132' c='_ZN13QAtomicTraits10isLockFreeEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic_cxx11.h' l='161' c='_ZN13QAtomicTraits10isLockFreeEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic_cxx11.h' l='269' c='_ZN10QAtomicOps18isTestAndSetNativeEv'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qatomic_cxx11.h' l='20'>/* Attempt to detect whether the atomic operations exist in hardware
 * or whether they are emulated by way of a lock.
 *
 * C++11 29.4 [atomics.lockfree] p1 says
 *
 *  The ATOMIC_..._LOCK_FREE macros indicate the lock-free property of the
 *  corresponding atomic types, with the signed and unsigned variants grouped
 *  together. The properties also apply to the corresponding (partial)
 *  specializations of the atomic template. A value of 0 indicates that the
 *  types are never lock-free. A value of 1 indicates that the types are
 *  sometimes lock-free. A value of 2 indicates that the types are always
 *  lock-free.
 *
 * We have a problem when the value is 1: we&apos;d need to check at runtime, but
 * QAtomicInteger requires a constexpr answer (defect introduced in Qt 5.0). So
 * we&apos;ll err in the side of caution and say it isn&apos;t.
 */</doc>
<fun r='_ZN13QAtomicTraits10isLockFreeEv'/>
<fun r='_ZN13QAtomicTraits10isLockFreeEv'/>
<fun r='_ZN13QAtomicTraits10isLockFreeEv'/>
<fun r='_ZN13QAtomicTraits10isLockFreeEv'/>
<fun r='_ZN13QAtomicTraits10isLockFreeEv'/>
