<dec f='qtbase-6.5.0/src/3rdparty/libjpeg/src/jchuff.h' l='49' type='void jpeg_gen_optimal_table(j_compress_ptr cinfo, JHUFF_TBL * htbl, long * freq)'/>
<def f='qtbase-6.5.0/src/3rdparty/libjpeg/src/jchuff.c' l='930' ll='1065' macro='1' type='void jpeg_gen_optimal_table(j_compress_ptr cinfo, JHUFF_TBL * htbl, long * freq)'/>
<use f='qtbase-6.5.0/src/3rdparty/libjpeg/src/jchuff.c' l='1096' u='c' c='finish_pass_gather'/>
<use f='qtbase-6.5.0/src/3rdparty/libjpeg/src/jchuff.c' l='1103' u='c' c='finish_pass_gather'/>
<doc f='qtbase-6.5.0/src/3rdparty/libjpeg/src/jchuff.c' l='901'>/*
 * Generate the best Huffman code table for the given counts, fill htbl.
 * Note this is also used by jcphuff.c.
 *
 * The JPEG standard requires that no symbol be assigned a codeword of all
 * one bits (so that padding bits added at the end of a compressed segment
 * can&apos;t look like a valid code).  Because of the canonical ordering of
 * codewords, this just means that there must be an unused slot in the
 * longest codeword length category.  Annex K (Clause K.2) of
 * Rec. ITU-T T.81 (1992) | ISO/IEC 10918-1:1994 suggests reserving such a slot
 * by pretending that symbol 256 is a valid symbol with count 1.  In theory
 * that&apos;s not optimal; giving it count zero but including it in the symbol set
 * anyway should give a better Huffman code.  But the theoretically better code
 * actually seems to come out worse in practice, because it produces more
 * all-ones bytes (which incur stuffed zero bytes in the final file).  In any
 * case the difference is tiny.
 *
 * The JPEG standard requires Huffman codes to be no more than 16 bits long.
 * If some symbols have a very small but nonzero probability, the Huffman tree
 * must be adjusted to meet the code length restriction.  We currently use
 * the adjustment method suggested in JPEG section K.2.  This method is *not*
 * optimal; it may not choose the best possible limited-length code.  But
 * typically only very-low-frequency symbols will be given less-than-optimal
 * lengths, so the code is almost optimal.  Experimental comparisons against
 * an optimal limited-length-code algorithm indicate that the difference is
 * microscopic --- usually less than a hundredth of a percent of total size.
 * So the extra complexity of an optimal algorithm doesn&apos;t seem worthwhile.
 */</doc>
<use f='qtbase-6.5.0/src/3rdparty/libjpeg/src/jcphuff.c' l='1082' u='c' c='finish_pass_gather_phuff'/>
