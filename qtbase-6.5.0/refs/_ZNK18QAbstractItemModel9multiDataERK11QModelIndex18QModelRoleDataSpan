<dec f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.h' l='328' type='void QAbstractItemModel::multiData(const QModelIndex &amp; index, QModelRoleDataSpan roleDataSpan) const'/>
<use f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.h' l='496' u='c' c='_ZNK11QModelIndex9multiDataE18QModelRoleDataSpan'/>
<def f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='3664' ll='3670' type='void QAbstractItemModel::multiData(const QModelIndex &amp; index, QModelRoleDataSpan roleDataSpan) const'/>
<doc f='qtbase-6.5.0/src/corelib/itemmodels/qabstractitemmodel.cpp' l='3617'>/*!
    \since 6.0

    Fills the \a roleDataSpan with the requested data for the given \a index.

    The default implementation will call simply data() for each role in
    the span. A subclass can reimplement this function to provide data
    to views more efficiently:

    \snippet code/src_corelib_kernel_qabstractitemmodel.cpp 15

    In the snippet above, \c{index} is the same for the entire call.
    This means that accessing to the necessary data structures in order
    to retrieve the information for \c{index} can be done only once
    (hoisting the relevant code out of the loop).

    The usage of QModelRoleData::setData(), or similarly
    QVariant::setValue(), is encouraged over constructing a QVariant
    separately and  using a plain assignment operator; this is
    because the former allow to re-use the memory already allocated for
    the QVariant object stored inside a QModelRoleData, while the latter
    always allocates the new variant and then destroys the old one.

    Note that views may call multiData() with spans that have been used
    in previous calls, and therefore may already contain some data.
    Therefore, it is imperative that if the model cannot return the
    data for a given role, then it must clear the data in the
    corresponding QModelRoleData object. This can be done by calling
    QModelRoleData::clearData(), or similarly by setting a default
    constructed QVariant, and so on. Failure to clear the data will
    result in the view believing that the &quot;old&quot; data is meant to be
    used for the corresponding role.

    Finally, in order to avoid code duplication, a subclass may also
    decide to reimplement data() in terms of multiData(), by supplying
    a span of just one element:

    \snippet code/src_corelib_kernel_qabstractitemmodel.cpp 16

    \note Models are not allowed to modify the roles in the span, or
    to rearrange the span elements. Doing so results in undefined
    behavior.

    \note It is illegal to pass an invalid model index to this function.

    \sa QModelRoleDataSpan, data()
*/</doc>
<ovr f='qtbase-6.5.0/src/gui/itemmodels/qstandarditemmodel.cpp' l='2837' c='_ZNK18QStandardItemModel9multiDataERK11QModelIndex18QModelRoleDataSpan'/>
<use f='qtbase-6.5.0/src/gui/itemmodels/qstandarditemmodel.cpp' l='2843' u='c' c='_ZNK18QStandardItemModel9multiDataERK11QModelIndex18QModelRoleDataSpan'/>
