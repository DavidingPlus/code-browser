<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1564' type='void QRhiResourceUpdateBatch::updateDynamicBuffer(QRhiBuffer * buf, quint32 offset, quint32 size, const void * data)'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='271' u='c' c='_ZL15updateMatrix3x3P23QRhiResourceUpdateBatchP10QRhiBufferRK14QGenericMatrixILi3ELi3EfE'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='401' u='c' c='_ZN30QBackingStoreDefaultCompositor14updateUniformsEPNS_11PerQuadDataEP23QRhiResourceUpdateBatchRK10QMatrix4x4RK14QGenericMatrixILi3ELi3EfENS_19UpdateUniformOptionE'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='404' u='c' c='_ZN30QBackingStoreDefaultCompositor14updateUniformsEPNS_11PerQuadDataEP23QRhiResourceUpdateBatchRK10QMatrix4x4RK14QGenericMatrixILi3ELi3EfENS_19UpdateUniformOptionE'/>
<use f='qtbase-6.5.0/src/gui/painting/qbackingstoredefaultcompositor.cpp' l='406' u='c' c='_ZN30QBackingStoreDefaultCompositor14updateUniformsEPNS_11PerQuadDataEP23QRhiResourceUpdateBatchRK10QMatrix4x4RK14QGenericMatrixILi3ELi3EfENS_19UpdateUniformOptionE'/>
<def f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5993' ll='6003' type='void QRhiResourceUpdateBatch::updateDynamicBuffer(QRhiBuffer * buf, quint32 offset, quint32 size, const void * data)'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='5974'>/*!
    Enqueues updating a region of a QRhiBuffer \a buf created with the type
    QRhiBuffer::Dynamic.

    The region is specified \a offset and \a size. The actual bytes to write
    are specified by \a data which must have at least \a size bytes available.
    \a data can safely be destroyed or changed once this function returns.

    \note If host writes are involved, which is the case with
    updateDynamicBuffer() typically as such buffers are backed by host visible
    memory with most backends, they may accumulate within a frame. Thus pass 1
    reading a region changed by a batch passed to pass 2 may see the changes
    specified in pass 2&apos;s update batch.

    \note QRhi transparently manages double buffering in order to prevent
    stalling the graphics pipeline. The fact that a QRhiBuffer may have
    multiple native underneath can be safely ignored when using the QRhi and
    QRhiResourceUpdateBatch.
 */</doc>
