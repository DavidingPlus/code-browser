<dec f='qtbase-6.5.0/src/corelib/tools/qhashfunctions.h' l='74' type='size_t qHashBits(const void * p, size_t size, size_t seed = 0)'/>
<use f='qtbase-6.5.0/src/corelib/compat/removed_api.cpp' l='180' u='c' c='_Z5qHashRK10QByteArraym'/>
<use f='qtbase-6.5.0/src/corelib/compat/removed_api.cpp' l='185' u='c' c='_Z5qHashRK14QByteArrayViewm'/>
<def f='qtbase-6.5.0/src/corelib/tools/qhash.cpp' l='924' ll='954' type='size_t qHashBits(const void * p, size_t size, size_t seed = 0)'/>
<use f='qtbase-6.5.0/src/corelib/tools/qhash.cpp' l='958' u='c' c='_Z5qHash14QByteArrayViewm'/>
<use f='qtbase-6.5.0/src/corelib/tools/qhash.cpp' l='963' u='c' c='_Z5qHash11QStringViewm'/>
<use f='qtbase-6.5.0/src/corelib/tools/qhash.cpp' l='969' u='c' c='_Z5qHashRK9QBitArraym'/>
<use f='qtbase-6.5.0/src/corelib/tools/qhash.cpp' l='981' u='c' c='_Z5qHash17QLatin1StringViewm'/>
<doc f='qtbase-6.5.0/src/corelib/tools/qhash.cpp' l='1284'>/*! \fn size_t qHashBits(const void *p, size_t len, size_t seed = 0)
    \relates QHash
    \since 5.4

    Returns the hash value for the memory block of size \a len pointed
    to by \a p, using \a seed to seed the calculation.

    Use this function only to implement qHash() for your own custom
    types. For example, here&apos;s how you could implement a qHash() overload for
    std::vector&lt;int&gt;:

    \snippet code/src_corelib_tools_qhash.cpp qhashbits

    This takes advantage of the fact that std::vector lays out its data
    contiguously. If that is not the case, or the contained type has
    padding, you should use qHashRange() instead.

    It bears repeating that the implementation of qHashBits() - like
    the qHash() overloads offered by Qt - may change at any time. You
    \b{must not} rely on the fact that qHashBits() will give the same
    results (for the same inputs) across different Qt versions.

    \sa qHashRange(), qHashRangeCommutative()
*/</doc>
<use f='qtbase-6.5.0/src/network/kernel/qhostaddress.cpp' l='1235' u='c' c='_Z5qHashRK12QHostAddressm'/>
