<dec f='qtbase-6.5.0/src/corelib/kernel/qabstracteventdispatcher.h' l='50' type='void QAbstractEventDispatcher::wakeUp()'/>
<doc f='qtbase-6.5.0/src/corelib/kernel/qabstracteventdispatcher.cpp' l='262'>/*! \fn void QAbstractEventDispatcher::wakeUp()
    \threadsafe

    Wakes up the event loop.

    \omit
    ### FIXME - QTBUG-70229
    On Unix and Glib event dispatchers, if the dispatcher is already awake when
    this function is called, it is ensured that the current iteration won&apos;t block
    waiting for more events, but will instead do another event loop iteration.

    ### TODO - does other event dispatchers behave the same?
    \endomit

    \sa awake()
*/</doc>
<ovr f='qtbase-6.5.0/src/corelib/kernel/qeventdispatcher_glib.cpp' l='556' c='_ZN20QEventDispatcherGlib6wakeUpEv'/>
<ovr f='qtbase-6.5.0/src/corelib/kernel/qeventdispatcher_unix.cpp' l='501' c='_ZN20QEventDispatcherUNIX6wakeUpEv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qeventloop.cpp' l='269' u='c' c='_ZN10QEventLoop6wakeUpEv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qobject.cpp' l='1718' u='c' c='_ZN14QObjectPrivate20setThreadData_helperEP11QThreadDataS1_P14QBindingStatus'/>
<use f='qtbase-6.5.0/src/gui/kernel/qwindowsysteminterface.cpp' l='131' u='c' c='_ZN19QWindowSystemHelperIN22QWindowSystemInterface20AsynchronousDeliveryEE11handleEventEDpT0_'/>
