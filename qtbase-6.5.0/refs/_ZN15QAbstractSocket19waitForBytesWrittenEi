<dec f='qtbase-6.5.0/src/network/socket/qabstractsocket.h' l='180' type='bool QAbstractSocket::waitForBytesWritten(int msecs = 30000)'/>
<inh f='qtbase-6.5.0/src/corelib/io/qiodevice.h' l='97' c='_ZN9QIODevice19waitForBytesWrittenEi'/>
<def f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2201' ll='2264' type='bool QAbstractSocket::waitForBytesWritten(int msecs = 30000)'/>
<doc f='qtbase-6.5.0/src/network/socket/qabstractsocket.cpp' l='2185'>/*! \reimp

    This function blocks until at least one byte has been written on the socket
    and the \l{QIODevice::}{bytesWritten()} signal has been emitted. The
    function will timeout after \a msecs milliseconds; the default timeout is
    30000 milliseconds.

    The function returns \c true if the bytesWritten() signal is emitted;
    otherwise it returns \c false (if an error occurred or the operation timed
    out).

    \note This function may fail randomly on Windows. Consider using the event
    loop and the bytesWritten() signal if your software will run on Windows.

    \sa waitForReadyRead()
 */</doc>
<use f='qtbase-6.5.0/src/network/socket/qhttpsocketengine.cpp' l='358' u='c' c='_ZN17QHttpSocketEngine12waitForWriteEiPb'/>
<use f='qtbase-6.5.0/src/network/socket/qlocalsocket_unix.cpp' l='515' u='c' c='_ZN12QLocalSocket19waitForBytesWrittenEi'/>
<use f='qtbase-6.5.0/src/network/socket/qsocks5socketengine.cpp' l='1427' u='c' c='_ZN19QSocks5SocketEngine5closeEv'/>
<use f='qtbase-6.5.0/src/network/socket/qsocks5socketengine.cpp' l='1507' u='c' c='_ZN19QSocks5SocketEngine5writeEPKcx'/>
<use f='qtbase-6.5.0/src/network/socket/qsocks5socketengine.cpp' l='1783' u='c' c='_ZN19QSocks5SocketEngine12waitForWriteEiPb'/>
<use f='qtbase-6.5.0/src/network/socket/qsocks5socketengine.cpp' l='1787' u='c' c='_ZN19QSocks5SocketEngine12waitForWriteEiPb'/>
