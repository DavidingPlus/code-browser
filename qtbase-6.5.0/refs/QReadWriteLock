<def f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='16' ll='41'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='35' c='_ZN14QReadWriteLockC1ERKS_'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='35' c='_ZN14QReadWriteLockaSERKS_'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='35' c='_ZN14QReadWriteLockaSERKS_'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='51' c='_ZN11QReadLockerC1EP14QReadWriteLock'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='76' c='_ZNK11QReadLocker13readWriteLockEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='77' c='_ZNK11QReadLocker13readWriteLockEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='84' c='_ZN11QReadLockerC1EP14QReadWriteLock'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='95' c='_ZN12QWriteLockerC1EP14QReadWriteLock'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='120' c='_ZNK12QWriteLocker13readWriteLockEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='121' c='_ZNK12QWriteLocker13readWriteLockEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.h' l='129' c='_ZN12QWriteLockerC1EP14QReadWriteLock'/>
<use f='qtbase-6.5.0/src/corelib/thread/qwaitcondition.h' l='27' c='_ZN14QWaitCondition4waitEP14QReadWriteLock14QDeadlineTimer'/>
<use f='qtbase-6.5.0/src/corelib/thread/qwaitcondition.h' l='29' c='_ZN14QWaitCondition4waitEP14QReadWriteLockm'/>
<size>8</size>
<fun r='_ZN14QReadWriteLockC1ENS_13RecursionModeE'/>
<fun r='_ZN14QReadWriteLockD1Ev'/>
<fun r='_ZN14QReadWriteLock11lockForReadEv'/>
<fun r='_ZN14QReadWriteLock14tryLockForReadEv'/>
<fun r='_ZN14QReadWriteLock14tryLockForReadEi'/>
<fun r='_ZN14QReadWriteLock12lockForWriteEv'/>
<fun r='_ZN14QReadWriteLock15tryLockForWriteEv'/>
<fun r='_ZN14QReadWriteLock15tryLockForWriteEi'/>
<fun r='_ZN14QReadWriteLock6unlockEv'/>
<fun r='_ZN14QReadWriteLockC1ERKS_'/>
<mbr r='QReadWriteLock::d_ptr' o='0' t='QAtomicPointer&lt;QReadWriteLockPrivate&gt;'/>
<fun r='_ZNK14QReadWriteLock21stateForWaitConditionEv'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qcoreapplication_p.h' l='135'/>
<size>8</size>
<use f='qtbase-6.5.0/src/corelib/io/qabstractfileengine.cpp' l='74'/>
<size>1</size>
<use f='qtbase-6.5.0/src/corelib/kernel/qmetatype.cpp' l='101'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qmetatype.cpp' l='1692'/>
<size>1</size>
<use f='qtbase-6.5.0/src/corelib/text/qlocale_unix.cpp' l='30'/>
<size>8</size>
<doc f='qtbase-6.5.0/src/corelib/thread/qreadwritelock.cpp' l='48'>/*! \class QReadWriteLock
    \inmodule QtCore
    \brief The QReadWriteLock class provides read-write locking.

    \threadsafe

    \ingroup thread

    A read-write lock is a synchronization tool for protecting
    resources that can be accessed for reading and writing. This type
    of lock is useful if you want to allow multiple threads to have
    simultaneous read-only access, but as soon as one thread wants to
    write to the resource, all other threads must be blocked until
    the writing is complete.

    In many cases, QReadWriteLock is a direct competitor to QMutex.
    QReadWriteLock is a good choice if there are many concurrent
    reads and writing occurs infrequently.

    Example:

    \snippet code/src_corelib_thread_qreadwritelock.cpp 0

    To ensure that writers aren&apos;t blocked forever by readers, readers
    attempting to obtain a lock will not succeed if there is a blocked
    writer waiting for access, even if the lock is currently only
    accessed by other readers. Also, if the lock is accessed by a
    writer and another writer comes in, that writer will have
    priority over any readers that might also be waiting.

    Like QMutex, a QReadWriteLock can be recursively locked by the
    same thread when constructed with \l{QReadWriteLock::Recursive} as
    \l{QReadWriteLock::RecursionMode}. In such cases,
    unlock() must be called the same number of times lockForWrite() or
    lockForRead() was called. Note that the lock type cannot be
    changed when trying to lock recursively, i.e. it is not possible
    to lock for reading in a thread that already has locked for
    writing (and vice versa).

    \sa QReadLocker, QWriteLocker, QMutex, QSemaphore
*/</doc>
<fun r='_ZN14QReadWriteLockC1ENS_13RecursionModeE'/>
<fun r='_ZN14QReadWriteLockD1Ev'/>
<fun r='_ZN14QReadWriteLock11lockForReadEv'/>
<fun r='_ZN14QReadWriteLock14tryLockForReadEv'/>
<fun r='_ZN14QReadWriteLock14tryLockForReadEi'/>
<fun r='_ZN14QReadWriteLock12lockForWriteEv'/>
<fun r='_ZN14QReadWriteLock15tryLockForWriteEv'/>
<fun r='_ZN14QReadWriteLock15tryLockForWriteEi'/>
<fun r='_ZN14QReadWriteLock6unlockEv'/>
<fun r='_ZNK14QReadWriteLock21stateForWaitConditionEv'/>
<use f='qtbase-6.5.0/src/corelib/thread/qwaitcondition_unix.cpp' l='191' c='_ZN14QWaitCondition4waitEP14QReadWriteLockm'/>
<use f='qtbase-6.5.0/src/corelib/thread/qwaitcondition_unix.cpp' l='198' c='_ZN14QWaitCondition4waitEP14QReadWriteLock14QDeadlineTimer'/>
<size>8</size>
<use f='qtbase-6.5.0/src/corelib/time/qcalendar.cpp' l='52'/>
<size>1</size>
<use f='qtbase-6.5.0/src/dbus/qdbusconnection_p.h' l='302'/>
<size>8</size>
<use f='qtbase-6.5.0/src/dbus/qdbusmetatype.cpp' l='102'/>
<size>8</size>
<use f='qtbase-6.5.0/src/sql/kernel/qsqldatabase.cpp' l='45'/>
<size>8</size>
