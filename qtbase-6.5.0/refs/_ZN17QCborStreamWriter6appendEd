<dec f='qtbase-6.5.0/src/corelib/serialization/qcborstreamwriter.h' l='54' type='void QCborStreamWriter::append(double d)'/>
<def f='qtbase-6.5.0/src/corelib/serialization/qcborstreamwriter.cpp' l='575' ll='578' type='void QCborStreamWriter::append(double d)'/>
<doc f='qtbase-6.5.0/src/corelib/serialization/qcborstreamwriter.cpp' l='555'>/*!
   \overload

   Appends the floating point number \a d to the stream, creating a CBOR 64-bit
   Double-Precision Floating Point value. QCborStreamWriter always appends the
   number as-is, performing no check for whether the number is the canonical
   form for NaN, an infinite, whether it is denormal or if it could be written
   with a shorter format.

   The following code performs all those checks, except for the denormal one,
   which is expected to be taken into account by the system FPU or floating
   point emulation directly.

   \snippet code/src_corelib_serialization_qcborstream.cpp 15

   Determining if a double can be converted to an integral with no loss of
   precision is left as an exercise to the reader.

   \sa QCborStreamReader::isDouble(), QCborStreamReader::toDouble()
 */</doc>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.cpp' l='872' u='c' c='_ZL17writeDoubleToCborR17QCborStreamWriterd6QFlagsIN10QCborValue14EncodingOptionEE'/>
<use f='qtbase-6.5.0/src/corelib/serialization/qcborvalue.cpp' l='902' u='c' c='_ZL17writeDoubleToCborR17QCborStreamWriterd6QFlagsIN10QCborValue14EncodingOptionEE'/>
