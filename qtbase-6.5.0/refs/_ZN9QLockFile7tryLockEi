<dec f='qtbase-6.5.0/src/corelib/io/qlockfile.h' l='25' type='bool QLockFile::tryLock(int timeout = 0)'/>
<use f='qtbase-6.5.0/src/corelib/io/qlockfile.h' l='31' u='c' c='_ZN9QLockFile7tryLockENSt6chrono8durationIlSt5ratioILl1ELl1000EEEE'/>
<use f='qtbase-6.5.0/src/corelib/io/qlockfile.cpp' l='219' u='c' c='_ZN9QLockFile4lockEv'/>
<def f='qtbase-6.5.0/src/corelib/io/qlockfile.cpp' l='242' ll='283' type='bool QLockFile::tryLock(int timeout = 0)'/>
<use f='qtbase-6.5.0/src/corelib/io/qlockfile.cpp' l='263' u='c' c='_ZN9QLockFile7tryLockEi'/>
<doc f='qtbase-6.5.0/src/corelib/io/qlockfile.cpp' l='222'>/*!
    Attempts to create the lock file. This function returns \c true if the
    lock was obtained; otherwise it returns \c false. If another process (or
    another thread) has created the lock file already, this function will
    wait for at most \a timeout milliseconds for the lock file to become
    available.

    Note: Passing a negative number as the \a timeout is equivalent to
    calling lock(), i.e. this function will wait forever until the lock
    file can be locked if \a timeout is negative.

    If the lock was obtained, it must be released with unlock()
    before another process (or thread) can successfully lock it.

    Calling this function multiple times on the same lock from the same
    thread without unlocking first is not allowed, this function will
    \e always return false when attempting to lock the file recursively.

    \sa lock(), unlock()
*/</doc>
