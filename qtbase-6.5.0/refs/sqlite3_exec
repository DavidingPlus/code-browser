<dec f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='731' type='int sqlite3_exec(sqlite3 * , const char * sql, int (*)(void *, int, char **, char **) callback, void * , char ** errmsg)'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='62920' u='c' c='sqlite3PagerCheckpoint'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='97022' u='c' c='sqlite3VdbeExec'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='97086' u='c' c='sqlite3VdbeExec'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='116555' u='c' c='sqlite3AnalysisLoad'/>
<def f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='131911' ll='132022' type='int sqlite3_exec(sqlite3 * db, const char * zSql, sqlite3_callback xCallback, void * pArg, char ** pzErrMsg)'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='132931'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='137575' u='c' c='sqlite3InitOne'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='146636' u='c' c='sqlite3_get_table'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='180730' u='c' c='fts3DbExec'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='196203' u='c' c='sqlite3Fts3Optimize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='196207' u='c' c='sqlite3Fts3Optimize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='196210' u='c' c='sqlite3Fts3Optimize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='196211' u='c' c='sqlite3Fts3Optimize'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='202533' u='c' c='rtreeDestroy'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='204874' u='c' c='rtreeRename'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='205035' u='c' c='rtreeSqlInit'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='205759' u='c' c='rtreeCheckTable'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='205805' u='c' c='rtreeCheckTable'/>
<use f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='240533' u='c' c='fts5ExecPrintf'/>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='669'>/*
** CAPI3REF: One-Step Query Execution Interface
** METHOD: sqlite3
**
** The sqlite3_exec() interface is a convenience wrapper around
** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],
** that allows an application to run multiple statements of SQL
** without having to use a lot of C code.
**
** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,
** semicolon-separate SQL statements passed into its 2nd argument,
** in the context of the [database connection] passed in as its 1st
** argument.  ^If the callback function of the 3rd argument to
** sqlite3_exec() is not NULL, then it is invoked for each result row
** coming out of the evaluated SQL statements.  ^The 4th argument to
** sqlite3_exec() is relayed through to the 1st argument of each
** callback invocation.  ^If the callback pointer to sqlite3_exec()
** is NULL, then no callback is ever invoked and result rows are
** ignored.
**
** ^If an error occurs while evaluating the SQL statements passed into
** sqlite3_exec(), then execution of the current statement stops and
** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()
** is not NULL then any error message is written into memory obtained
** from [sqlite3_malloc()] and passed back through the 5th parameter.
** To avoid memory leaks, the application should invoke [sqlite3_free()]
** on error message strings returned through the 5th parameter of
** sqlite3_exec() after the error message string is no longer needed.
** ^If the 5th parameter to sqlite3_exec() is not NULL and no errors
** occur, then sqlite3_exec() sets the pointer in its 5th parameter to
** NULL before returning.
**
** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()
** routine returns SQLITE_ABORT without invoking the callback again and
** without running any subsequent SQL statements.
**
** ^The 2nd argument to the sqlite3_exec() callback function is the
** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()
** callback is an array of pointers to strings obtained as if from
** [sqlite3_column_text()], one for each column.  ^If an element of a
** result row is NULL then the corresponding string pointer for the
** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to the
** sqlite3_exec() callback is an array of pointers to strings where each
** entry represents the name of corresponding result column as obtained
** from [sqlite3_column_name()].
**
** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer
** to an empty string, or a pointer that contains only whitespace and/or
** SQL comments, then no SQL statements are evaluated and the database
** is not changed.
**
** Restrictions:
**
** &lt;ul&gt;
** &lt;li&gt; The application must ensure that the 1st parameter to sqlite3_exec()
**      is a valid and open [database connection].
** &lt;li&gt; The application must not close the [database connection] specified by
**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.
** &lt;li&gt; The application must not modify the SQL statement text passed into
**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.
** &lt;/ul&gt;
*/</doc>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.c' l='131901'>/*
** Execute SQL code.  Return one of the SQLITE_ success/failure
** codes.  Also write an error message into memory obtained from
** malloc() and make *pzErrMsg point to that message.
**
** If the SQL is a query, then for each row in the query result
** the xCallback() function is called.  pArg becomes the first
** argument to xCallback().  If xCallback=NULL then no callback
** is invoked, even for queries.
*/</doc>
<dec f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.h' l='425' type='int sqlite3_exec(sqlite3 * , const char * sql, int (*)(void *, int, char **, char **) callback, void * , char ** errmsg)'/>
<doc f='qtbase-6.5.0/src/3rdparty/sqlite/sqlite3.h' l='363'>/*
** CAPI3REF: One-Step Query Execution Interface
** METHOD: sqlite3
**
** The sqlite3_exec() interface is a convenience wrapper around
** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],
** that allows an application to run multiple statements of SQL
** without having to use a lot of C code.
**
** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,
** semicolon-separate SQL statements passed into its 2nd argument,
** in the context of the [database connection] passed in as its 1st
** argument.  ^If the callback function of the 3rd argument to
** sqlite3_exec() is not NULL, then it is invoked for each result row
** coming out of the evaluated SQL statements.  ^The 4th argument to
** sqlite3_exec() is relayed through to the 1st argument of each
** callback invocation.  ^If the callback pointer to sqlite3_exec()
** is NULL, then no callback is ever invoked and result rows are
** ignored.
**
** ^If an error occurs while evaluating the SQL statements passed into
** sqlite3_exec(), then execution of the current statement stops and
** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()
** is not NULL then any error message is written into memory obtained
** from [sqlite3_malloc()] and passed back through the 5th parameter.
** To avoid memory leaks, the application should invoke [sqlite3_free()]
** on error message strings returned through the 5th parameter of
** sqlite3_exec() after the error message string is no longer needed.
** ^If the 5th parameter to sqlite3_exec() is not NULL and no errors
** occur, then sqlite3_exec() sets the pointer in its 5th parameter to
** NULL before returning.
**
** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()
** routine returns SQLITE_ABORT without invoking the callback again and
** without running any subsequent SQL statements.
**
** ^The 2nd argument to the sqlite3_exec() callback function is the
** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()
** callback is an array of pointers to strings obtained as if from
** [sqlite3_column_text()], one for each column.  ^If an element of a
** result row is NULL then the corresponding string pointer for the
** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to the
** sqlite3_exec() callback is an array of pointers to strings where each
** entry represents the name of corresponding result column as obtained
** from [sqlite3_column_name()].
**
** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer
** to an empty string, or a pointer that contains only whitespace and/or
** SQL comments, then no SQL statements are evaluated and the database
** is not changed.
**
** Restrictions:
**
** &lt;ul&gt;
** &lt;li&gt; The application must ensure that the 1st parameter to sqlite3_exec()
**      is a valid and open [database connection].
** &lt;li&gt; The application must not close the [database connection] specified by
**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.
** &lt;li&gt; The application must not modify the SQL statement text passed into
**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.
** &lt;/ul&gt;
*/</doc>
