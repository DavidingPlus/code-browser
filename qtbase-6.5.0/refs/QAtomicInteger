<def f='qtbase-6.5.0/src/corelib/thread/qatomic.h' l='19' ll='111'/>
<ovr f='qtbase-6.5.0/src/corelib/thread/qatomic.h' l='113' c='QAtomicInt'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.h' l='113'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.h' l='119' c='_ZN10QAtomicIntC1Ei'/>
<fun r='_ZN14QAtomicIntegerC1ET_'/>
<fun r='_ZN14QAtomicIntegerC1ERK14QAtomicIntegerIT_E'/>
<fun r='_ZN14QAtomicIntegeraSERK14QAtomicIntegerIT_E'/>
<use f='qtbase-6.5.0/src/corelib/thread/qfuture_impl.h' l='1039'/>
<use f='qtbase-6.5.0/src/corelib/kernel/qobject_p_p.h' l='130'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1762'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1763'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1764'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1765'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1766'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1767'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1769'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1770'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1771'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1772'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1774'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1775'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1776'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1777'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1780'/>
<use f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='1781'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qatomic.cpp' l='19'>/*!
    \class QAtomicInteger
    \inmodule QtCore
    \brief The QAtomicInteger class provides platform-independent atomic operations on integers.
    \ingroup thread
    \since 5.3

    For atomic operations on pointers, see the QAtomicPointer class.

    An \e atomic operation is a complex operation that completes without interruption.
    The QAtomicInteger class provides atomic reference counting, test-and-set, fetch-and-store,
    and fetch-and-add for integers.

    The template parameter \c T must be a C++ integer type:
    \list
       \li 8-bit: bool, char, signed char, unsigned char, qint8, quint8, char8_t (C++20)
       \li 16-bit: short, unsigned short, qint16, quint16, char16_t (C++11)
       \li 32-bit: int, unsigned int, qint32, quint32, char32_t (C++11)
       \li 64-bit: long long, unsigned long long, qint64, quint64
       \li platform-specific size: long, unsigned long
       \li pointer size: qintptr, quintptr, qptrdiff
    \endlist

    Of the list above, only the 8-bit, 16-bit, 32-bit- and pointer-sized
    instantiations are guaranteed to work on all platforms. Support for other
    sizes depends on the compiler and processor architecture the code is being
    compiled for. To test whether the 64-bit types are supported on 32-bit
    platforms, check the macro \c Q_ATOMIC_INT64_IS_SUPPORTED.

    \section1 The Atomic API

    \section2 Reference counting

    The ref() and deref() functions provide an efficient reference
    counting API. The return value of these functions are used to
    indicate when the last reference has been released. These
    functions allow you to implement your own implicitly shared
    classes.

    \snippet code/src_corelib_thread_qatomic.cpp 0

    \section2 Memory ordering

    QAtomicInteger provides several implementations of the atomic
    test-and-set, fetch-and-store, and fetch-and-add functions. Each
    implementation defines a memory ordering semantic that describes
    how memory accesses surrounding the atomic instruction are
    executed by the processor. Since many modern architectures allow
    out-of-order execution and memory ordering, using the correct
    semantic is necessary to ensure that your application functions
    properly on all processors.

    \list

    \li Relaxed - memory ordering is unspecified, leaving the compiler
    and processor to freely reorder memory accesses.

    \li Acquire - memory access following the atomic operation (in
    program order) may not be re-ordered before the atomic operation.

    \li Release - memory access before the atomic operation (in program
    order) may not be re-ordered after the atomic operation.

    \li Ordered - the same Acquire and Release semantics combined.

    \endlist

    \section2 Test-and-set

    If the current value of the QAtomicInteger is an expected value, the
    test-and-set functions assign a new value to the QAtomicInteger and
    return true. If values are \a not the same, these functions do
    nothing and return false. This operation equates to the following
    code:

    \snippet code/src_corelib_thread_qatomic.cpp 1

    There are 4 test-and-set functions: testAndSetRelaxed(),
    testAndSetAcquire(), testAndSetRelease(), and
    testAndSetOrdered(). See above for an explanation of the different
    memory ordering semantics.

    \section2 Fetch-and-store

    The atomic fetch-and-store functions read the current value of the
    QAtomicInteger and then assign a new value, returning the original
    value. This operation equates to the following code:

    \snippet code/src_corelib_thread_qatomic.cpp 2

    There are 4 fetch-and-store functions: fetchAndStoreRelaxed(),
    fetchAndStoreAcquire(), fetchAndStoreRelease(), and
    fetchAndStoreOrdered(). See above for an explanation of the
    different memory ordering semantics.

    \section2 Fetch-and-add

    The atomic fetch-and-add functions read the current value of the
    QAtomicInteger and then add the given value to the current value,
    returning the original value. This operation equates to the
    following code:

    \snippet code/src_corelib_thread_qatomic.cpp 3

    There are 4 fetch-and-add functions: fetchAndAddRelaxed(),
    fetchAndAddAcquire(), fetchAndAddRelease(), and
    fetchAndAddOrdered(). See above for an explanation of the
    different memory ordering semantics.

    \section1 Feature Tests for the Atomic API

    Providing a platform-independent atomic API that works on all
    processors is challenging. The API provided by QAtomicInteger is
    guaranteed to work atomically on all processors. However, since
    not all processors implement support for every operation provided
    by QAtomicInteger, it is necessary to expose information about the
    processor.

    You can check at compile time which features are supported on your
    hardware using various macros. These will tell you if your
    hardware always, sometimes, or does not support a particular
    operation. The macros have the form
    Q_ATOMIC_INT\e{nn}_\e{OPERATION}_IS_\e{HOW}_NATIVE. \e{nn} is the
    size of the integer (in bits), \e{OPERATION}
    is one of REFERENCE_COUNTING, TEST_AND_SET,
    FETCH_AND_STORE, or FETCH_AND_ADD, and \e{HOW} is one of
    ALWAYS, SOMETIMES, or NOT. There will always be exactly one
    defined macro per operation. For example, if
    Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_ALWAYS_NATIVE is defined,
    neither Q_ATOMIC_INT_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE nor
    Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_NOT_NATIVE will be defined.

    An operation that completes in constant time is said to be
    wait-free. Such operations are not implemented using locks or
    loops of any kind. For atomic operations that are always
    supported, and that are wait-free, Qt defines the
    Q_ATOMIC_INT\e{nn}_\e{OPERATION}_IS_WAIT_FREE in addition to the
    Q_ATOMIC_INT\e{nn}_\e{OPERATION}_IS_ALWAYS_NATIVE.

    In cases where an atomic operation is only supported in newer
    generations of the processor, QAtomicInteger also provides a way to
    check at runtime what your hardware supports with the
    isReferenceCountingNative(), isTestAndSetNative(),
    isFetchAndStoreNative(), and isFetchAndAddNative()
    functions. Wait-free implementations can be detected using the
    isReferenceCountingWaitFree(), isTestAndSetWaitFree(),
    isFetchAndStoreWaitFree(), and isFetchAndAddWaitFree() functions.

    Below is a complete list of all feature macros for QAtomicInteger:

    \list

    \li Q_ATOMIC_INT\e{nn}_REFERENCE_COUNTING_IS_ALWAYS_NATIVE
    \li Q_ATOMIC_INT\e{nn}_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE
    \li Q_ATOMIC_INT\e{nn}_REFERENCE_COUNTING_IS_NOT_NATIVE
    \li Q_ATOMIC_INT\e{nn}_REFERENCE_COUNTING_IS_WAIT_FREE

    \li Q_ATOMIC_INT\e{nn}_TEST_AND_SET_IS_ALWAYS_NATIVE
    \li Q_ATOMIC_INT\e{nn}_TEST_AND_SET_IS_SOMETIMES_NATIVE
    \li Q_ATOMIC_INT\e{nn}_TEST_AND_SET_IS_NOT_NATIVE
    \li Q_ATOMIC_INT\e{nn}_TEST_AND_SET_IS_WAIT_FREE

    \li Q_ATOMIC_INT\e{nn}_FETCH_AND_STORE_IS_ALWAYS_NATIVE
    \li Q_ATOMIC_INT\e{nn}_FETCH_AND_STORE_IS_SOMETIMES_NATIVE
    \li Q_ATOMIC_INT\e{nn}_FETCH_AND_STORE_IS_NOT_NATIVE
    \li Q_ATOMIC_INT\e{nn}_FETCH_AND_STORE_IS_WAIT_FREE

    \li Q_ATOMIC_INT\e{nn}_FETCH_AND_ADD_IS_ALWAYS_NATIVE
    \li Q_ATOMIC_INT\e{nn}_FETCH_AND_ADD_IS_SOMETIMES_NATIVE
    \li Q_ATOMIC_INT\e{nn}_FETCH_AND_ADD_IS_NOT_NATIVE
    \li Q_ATOMIC_INT\e{nn}_FETCH_AND_ADD_IS_WAIT_FREE

    \endlist

    For compatibility with previous versions of Qt, macros with an empty \e{nn}
    are equivalent to the 32-bit macros. For example,
    Q_ATOMIC_INT_REFERENCE_COUNTING_IS_WAIT_FREE is the same as
    Q_ATOMIC_INT32_REFERENCE_COUNTING_IS_WAIT_FREE.

    \sa QAtomicPointer
*/</doc>
