<dec f='qtbase-6.5.0/src/widgets/itemviews/qitemdelegate.h' l='33' type='void QItemDelegate::paint(QPainter * painter, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index) const'/>
<doc f='qtbase-6.5.0/src/widgets/itemviews/qitemdelegate.h' l='32'>// painting</doc>
<inh f='qtbase-6.5.0/src/widgets/itemviews/qabstractitemdelegate.h' l='40' c='_ZNK21QAbstractItemDelegate5paintEP8QPainterRK20QStyleOptionViewItemRK11QModelIndex'/>
<def f='qtbase-6.5.0/src/widgets/itemviews/qitemdelegate.cpp' l='356' ll='426' type='void QItemDelegate::paint(QPainter * painter, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index) const'/>
<doc f='qtbase-6.5.0/src/widgets/itemviews/qitemdelegate.cpp' l='334'>/*!
    Renders the delegate using the given \a painter and style \a option for
    the item specified by \a index.

    When reimplementing this function in a subclass, you should update the area
    held by the option&apos;s \l{QStyleOption::rect}{rect} variable, using the
    option&apos;s \l{QStyleOption::state}{state} variable to determine the state of
    the item to be displayed, and adjust the way it is painted accordingly.

    For example, a selected item may need to be displayed differently to
    unselected items, as shown in the following code:

    \snippet itemviews/pixelator/pixeldelegate.cpp 2
    \dots

    After painting, you should ensure that the painter is returned to its
    the state it was supplied in when this function was called. For example,
    it may be useful to call QPainter::save() before painting and
    QPainter::restore() afterwards.

    \sa QStyle::State
*/</doc>
