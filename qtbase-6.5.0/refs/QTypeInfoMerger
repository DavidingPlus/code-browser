<def f='qtbase-6.5.0/src/corelib/global/qtypeinfo.h' l='90' ll='99'/>
<use f='qtbase-6.5.0/src/corelib/global/qtypeinfo.h' l='105'/>
<use f='qtbase-6.5.0/src/corelib/tools/qtaggedpointer.h' l='185'/>
<doc f='qtbase-6.5.0/src/corelib/global/qtypeinfo.h' l='69'>/*!
    \class QTypeInfoMerger
    \inmodule QtCore
    \internal

    \brief QTypeInfoMerger merges the QTypeInfo flags of T1, T2... and presents them
    as a QTypeInfo&lt;T&gt; would do.

    Let&apos;s assume that we have a simple set of structs:

    \snippet code/src_corelib_global_qglobal.cpp 50

    To create a proper QTypeInfo specialization for A struct, we have to check
    all sub-components; B, C and D, then take the lowest common denominator and call
    Q_DECLARE_TYPEINFO with the resulting flags. An easier and less fragile approach is to
    use QTypeInfoMerger, which does that automatically. So struct A would have
    the following QTypeInfo definition:

    \snippet code/src_corelib_global_qglobal.cpp 51
*/</doc>
<smbr r='QTypeInfoMerger::isComplex' t='const bool'/>
<smbr r='QTypeInfoMerger::isRelocatable' t='const bool'/>
<smbr r='QTypeInfoMerger::isPointer' t='const bool'/>
<smbr r='QTypeInfoMerger::isIntegral' t='const bool'/>
<smbr r='QTypeInfoMerger::isValueInitializationBitwiseZero' t='const bool'/>
<use f='qtbase-6.5.0/src/corelib/io/qurl.h' l='87'/>
<use f='qtbase-6.5.0/src/corelib/global/qendian.h' l='369'/>
<use f='qtbase-6.5.0/src/corelib/global/qendian.h' l='373'/>
<use f='qtbase-6.5.0/src/gui/math3d/qgenericmatrix.h' l='69'/>
<ovr f='qtbase-6.5.0/src/widgets/itemviews/qabstractitemview_p.h' l='52' c='QTypeInfo'/>
<use f='qtbase-6.5.0/src/widgets/styles/qstylesheetstyle_p.h' l='183'/>
<ovr f='qtbase-6.5.0/src/widgets/util/qscroller_p.h' l='172' c='QTypeInfo'/>
