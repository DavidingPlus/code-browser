<dec f='qtbase-6.5.0/src/corelib/thread/qfuturewatcher.h' l='75' type='void QFutureWatcherBase::setPaused(bool paused)'/>
<def f='qtbase-6.5.0/src/corelib/thread/qfuturewatcher.cpp' l='122' ll='125' type='void QFutureWatcherBase::setPaused(bool paused)'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qfuturewatcher.cpp' l='101'>/*! \fn template &lt;typename T&gt; void QFutureWatcher&lt;T&gt;::setPaused(bool paused)

    \deprecated [6.6] Use setSuspended() instead.

    If \a paused is true, this function pauses the asynchronous computation
    represented by the future(). If the computation is already paused, this
    function does nothing. QFutureWatcher will not immediately stop delivering
    progress and result ready signals when the future is paused. At the moment
    of pausing there may still be computations that are in progress and cannot
    be stopped. Signals for such computations will still be delivered after
    pause.

    If \a paused is false, this function resumes the asynchronous computation.
    If the computation was not previously paused, this function does nothing.

    Be aware that not all computations can be paused. For example, the
    QFuture returned by QtConcurrent::run() cannot be paused; but the QFuture
    returned by QtConcurrent::mappedReduced() can.

    \sa suspend(), resume(), toggleSuspended()
*/</doc>
