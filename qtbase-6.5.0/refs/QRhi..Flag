<def f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1635' ll='1640'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1641'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='410'>/*!
    \enum QRhi::Flag
    Describes what special features to enable.

    \value EnableProfiling This flag has currently no effect.

    \value EnableDebugMarkers Enables debug marker groups. Without this frame
    debugging features like making debug groups and custom resource name
    visible in external GPU debugging tools will not be available and functions
    like QRhiCommandBuffer::debugMarkBegin() will become a no-op. Avoid
    enabling in production builds as it may involve a performance penalty.

    \value PreferSoftwareRenderer Indicates that backends should prefer
    choosing an adapter or physical device that renders in software on the CPU.
    For example, with Direct3D there is typically a &quot;Basic Render Driver&quot;
    adapter available with \c{DXGI_ADAPTER_FLAG_SOFTWARE}. Setting this flag
    requests the backend to choose that adapter over any other, as long as no
    specific adapter was forced by other backend-specific means. With Vulkan
    this maps to preferring physical devices with
    \c{VK_PHYSICAL_DEVICE_TYPE_CPU}. When not available, or when it is not
    possible to decide if an adapter/device is software-based, this flag is
    ignored. It may also be ignored with graphics APIs that have no concept and
    means of enumerating adapters/devices.

    \value EnablePipelineCacheDataSave Enables retrieving the pipeline cache
    contents, where applicable. When not set, pipelineCacheData() will return
    an empty blob always. With backends where retrieving and restoring the
    pipeline cache contents is not supported, the flag has no effect and the
    serialized cache data is always empty. The flag provides an opt-in
    mechanism because the cost of maintaining the related data structures is
    not insignificant with some backends. With Vulkan this feature maps
    directly to VkPipelineCache, vkGetPipelineCacheData and
    VkPipelineCacheCreateInfo::pInitialData. With D3D11 there is no real
    pipline cache, but the results of HLSL-&gt;DXBC compilations are stored and
    can be serialized/deserialized via this mechanism. This allows skipping the
    time consuming D3DCompile() in future runs of the applications for shaders
    that come with HLSL source instead of offline pre-compiled bytecode. This
    can provide a huge boost in startup and load times, if there is a lot of
    HLSL source compilation happening. With OpenGL the &quot;pipeline cache&quot; is
    simulated by retrieving and loading shader program binaries (if supported
    by the driver). With OpenGL there are additional, disk-based caching
    mechanisms for shader/program binaries provided by Qt. Writing to those may
    get disabled whenever this flag is set since storing program binaries to
    multiple caches is not sensible.
 */</doc>
