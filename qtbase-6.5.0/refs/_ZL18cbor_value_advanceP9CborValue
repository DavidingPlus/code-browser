<use f='qtbase-6.5.0/src/3rdparty/tinycbor/src/cborparser.c' l='448' u='c' c='_ZL25cbor_value_validate_basicPK9CborValue'/>
<def f='qtbase-6.5.0/src/3rdparty/tinycbor/src/cborparser.c' l='518' ll='524' type='CborError cbor_value_advance(CborValue * it)'/>
<use f='qtbase-6.5.0/src/3rdparty/tinycbor/src/cborparser.c' l='1439' u='c' c='_ZL25cbor_value_map_find_valuePK9CborValuePKcPS_'/>
<use f='qtbase-6.5.0/src/3rdparty/tinycbor/src/cborparser.c' l='1448' u='c' c='_ZL25cbor_value_map_find_valuePK9CborValuePKcPS_'/>
<doc f='qtbase-6.5.0/src/3rdparty/tinycbor/src/cborparser.c' l='504'>/**
 * Advances the CBOR value \a it by one element, skipping over containers.
 * Unlike cbor_value_advance_fixed(), this function can be called on a CBOR
 * value of any type. However, if the type is a container (map or array) or a
 * string with a chunked payload, this function will not run in constant time
 * and will recurse into itself (it will run on O(n) time for the number of
 * elements or chunks and will use O(n) memory for the number of nested
 * containers).
 *
 * The number of recursions can be limited at compile time to avoid stack
 * exhaustion in constrained systems.
 *
 * \sa cbor_value_at_end(), cbor_value_advance_fixed(), cbor_value_enter_container(), cbor_value_leave_container()
 */</doc>
