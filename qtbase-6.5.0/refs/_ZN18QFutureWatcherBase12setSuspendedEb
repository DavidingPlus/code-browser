<dec f='qtbase-6.5.0/src/corelib/thread/qfuturewatcher.h' l='68' type='void QFutureWatcherBase::setSuspended(bool suspend)'/>
<def f='qtbase-6.5.0/src/corelib/thread/qfuturewatcher.cpp' l='164' ll='167' type='void QFutureWatcherBase::setSuspended(bool suspend)'/>
<doc f='qtbase-6.5.0/src/corelib/thread/qfuturewatcher.cpp' l='144'>/*! \fn template &lt;typename T&gt; void QFutureWatcher&lt;T&gt;::setSuspended(bool suspend)

    \since 6.0

    If \a suspend is true, this function suspends the asynchronous computation
    represented by the future(). If the computation is already suspended, this
    function does nothing. QFutureWatcher will not immediately stop delivering
    progress and result ready signals when the future is suspended. At the moment
    of suspending there may still be computations that are in progress and cannot
    be stopped. Signals for such computations will still be delivered.

    If \a suspend is false, this function resumes the asynchronous computation.
    If the computation was not previously suspended, this function does nothing.

    Be aware that not all computations can be suspended. For example, the
    QFuture returned by QtConcurrent::run() cannot be suspended; but the QFuture
    returned by QtConcurrent::mappedReduced() can.

    \sa suspend(), resume(), toggleSuspended()
*/</doc>
