<dec f='qtbase-6.5.0/src/gui/rhi/qrhi_p.h' l='1703' type='4'/>
<doc f='qtbase-6.5.0/src/gui/rhi/qrhi.cpp' l='778'>\value FramesInFlight The number of frames the backend may keep &quot;in
    flight&quot;: with backends like Vulkan or Metal, it is the responsibility of
    QRhi to block whenever starting a new frame and finding the CPU is already
    \c{N - 1} frames ahead of the GPU (because the command buffer submitted in
    frame no. \c{current} - \c{N} has not yet completed). The value N is what
    is returned from here, and is typically 2. This can be relevant to
    applications that integrate rendering done directly with the graphics API,
    as such rendering code may want to perform double (if the value is 2)
    buffering for resources, such as, buffers, similarly to the QRhi backends
    themselves. The current frame slot index (a value running 0, 1, .., N-1,
    then wrapping around) is retrievable from QRhi::currentFrameSlot(). The
    value is 1 for backends where the graphics API offers no such low level
    control over the command submission process. Note that pipelining may still
    happen even when this value is 1 (some backends, such as D3D11, are
    designed to attempt to enable this, for instance, by using an update
    strategy for uniform buffers that does not stall the pipeline), but that is
    then not controlled by QRhi and so not reflected here in the API.</doc>
<use f='qtbase-6.5.0/src/gui/rhi/qrhigles2.cpp' l='1333' c='_ZNK9QRhiGles213resourceLimitEN4QRhi13ResourceLimitE'/>
<use f='qtbase-6.5.0/src/gui/rhi/qrhinull.cpp' l='114' c='_ZNK8QRhiNull13resourceLimitEN4QRhi13ResourceLimitE'/>
